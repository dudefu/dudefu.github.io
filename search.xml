<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[Apache Flink 零基础入门（一）：基础概念解析]]></title>
      <url>/ApacheFlink%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E8%A7%A3%E6%9E%90.html</url>
      <content type="html"><![CDATA[<h3 id="一、Apache-Flink-的定义、架构及原理"><a href="#一、Apache-Flink-的定义、架构及原理" class="headerlink" title="一、Apache Flink 的定义、架构及原理"></a>一、Apache Flink 的定义、架构及原理</h3><p>Apache Flink 是一个分布式大数据处理引擎，可对有限数据流和无限数据流进行有状态或无状态的计算，能够部署在各种集群环境，对各种规模大小的数据进行快速计算。</p>
<a id="more"></a>
<h4 id="1-Flink-Application"><a href="#1-Flink-Application" class="headerlink" title="1. Flink Application"></a><strong>1. Flink Application</strong></h4><p>了解 Flink 应用开发需要先理解 Flink 的 Streams、State、Time 等基础处理语义以及 Flink 兼顾灵活性和方便性的多层次 API。</p>
<ul>
<li><strong>Streams：</strong>流，分为有限数据流与无限数据流，unbounded stream 是有始无终的数据流，即无限数据流；而 bounded stream 是限定大小的有始有终的数据集合，即有限数据流，二者的区别在于无限数据流的数据会随时间的推演而持续增加，计算持续进行且不存在结束的状态，相对的有限数据流数据大小固定，计算最终会完成并处于结束的状态。</li>
<li><strong>State</strong>，状态是计算过程中的数据信息，在容错恢复和 Checkpoint 中有重要的作用，流计算在本质上是 Incremental Processing，因此需要不断查询保持状态；另外，为了确保 Exactly- once 语义，需要数据能够写入到状态中；而持久化存储，能够保证在整个分布式系统运行失败或者挂掉的情况下做到 Exactly- once，这是状态的另外一个价值。</li>
<li><strong>Time</strong>，分为 Event time、Ingestion time、Processing time，Flink 的无限数据流是一个持续的过程，时间是我们判断业务状态是否滞后，数据处理是否及时的重要依据。</li>
<li><strong>API</strong>，API 通常分为三层，由上而下可分为 SQL / Table API、DataStream API、ProcessFunction 三层，API 的表达能力及业务抽象能力都非常强大，但越接近 SQL 层，表达能力会逐步减弱，抽象能力会增强，反之，ProcessFunction 层 API 的表达能力非常强，可以进行多种灵活方便的操作，但抽象能力也相对越小。</li>
</ul>
<h4 id="2-Flink-Architecture"><a href="#2-Flink-Architecture" class="headerlink" title="2.Flink Architecture"></a><strong>2.Flink Architecture</strong></h4><p>在架构部分，主要分为以下四点：</p>
<p><img src="https://yqfile.alicdn.com/f273ad0225d6b77b7e1e0151ed1964f12970cd25.jpeg" alt="1_16_001_jpeg"></p>
<p><strong>第一</strong>， Flink 具备统一的框架处理有界和无界两种数据流的能力</p>
<p><strong>第二</strong>， 部署灵活，Flink 底层支持多种资源调度器，包括 Yarn、Kubernetes 等。Flink 自身带的 Standalone 的调度器，在部署上也十分灵活。</p>
<p><strong>第三</strong>， 极高的可伸缩性，可伸缩性对于分布式系统十分重要，阿里巴巴双11大屏采用 Flink 处理海量数据，使用过程中测得 Flink 峰值可达 17 亿/秒。</p>
<p><strong>第四</strong>， 极致的流式处理性能。Flink 相对于 Storm 最大的特点是将状态语义完全抽象到框架中，支持本地状态读取，避免了大量网络 IO，可以极大提升状态存取的性能。</p>
<h4 id="3-Flink-Operation"><a href="#3-Flink-Operation" class="headerlink" title="3.Flink Operation"></a><strong>3.Flink Operation</strong></h4><p>后面会有专门课程讲解，此处简单分享 Flink 关于运维及业务监控的内容：</p>
<ul>
<li>Flink 具备 7 X 24 小时高可用的 SOA（面向服务架构），原因是在实现上 Flink 提供了一致性的 Checkpoint。Checkpoint 是 Flink 实现容错机制的核心，它周期性的记录计算过程中 Operator 的状态，并生成快照持久化存储。当 Flink 作业发生故障崩溃时，可以有选择的从 Checkpoint 中恢复，保证了计算的一致性。</li>
<li>Flink 本身提供监控、运维等功能或接口，并有内置的 WebUI，对运行的作业提供 DAG 图以及各种 Metric 等，协助用户管理作业状态。</li>
</ul>
<h4 id="4-Flink-的应用场景"><a href="#4-Flink-的应用场景" class="headerlink" title="4.Flink 的应用场景"></a>4.Flink 的应用场景</h4><h5 id="4-1-Flink-的应用场景：Data-Pipeline"><a href="#4-1-Flink-的应用场景：Data-Pipeline" class="headerlink" title="4.1 Flink 的应用场景：Data Pipeline"></a>4.1 Flink 的应用场景：Data Pipeline</h5><p><img src="https://yqfile.alicdn.com/a16e76642ea95d0d71843f29ad5da71b2bbf7196.jpeg" alt="2_16_004_jpeg"></p>
<p>Data Pipeline 的核心场景类似于数据搬运并在搬运的过程中进行部分数据清洗或者处理，而整个业务架构图的左边是 Periodic ETL，它提供了流式 ETL 或者实时 ETL，能够订阅消息队列的消息并进行处理，清洗完成后实时写入到下游的 Database 或 File system 中。场景举例：</p>
<ul>
<li><strong>实时数仓</strong></li>
</ul>
<p>当下游要构建实时数仓时，上游则可能需要实时的 Stream ETL。这个过程会进行实时清洗或扩展数据，清洗完成后写入到下游的实时数仓的整个链路中，可保证数据查询的时效性，形成实时数据采集、实时数据处理以及下游的实时 Query。</p>
<ul>
<li><strong>搜索引擎推荐</strong></li>
</ul>
<p>搜索引擎这块以淘宝为例，当卖家上线新商品时，后台会实时产生消息流，该消息流经过 Flink 系统时会进行数据的处理、扩展。然后将处理及扩展后的数据生成实时索引，写入到搜索引擎中。这样当淘宝卖家上线新商品时，能在秒级或者分钟级实现搜索引擎的搜索。</p>
<h5 id="4-2-Flink-应用场景：Data-Analytics"><a href="#4-2-Flink-应用场景：Data-Analytics" class="headerlink" title="4.2 Flink 应用场景：Data Analytics"></a><strong>4.2 Flink</strong> <strong>应用场景：Data Analytics</strong></h5><p><img src="https://yqfile.alicdn.com/c12e75424fe6c6058b895b614262f61c8d2f1baf.jpeg" alt="3_005_jpeg"></p>
<p>Data Analytics，如图，左边是 Batch Analytics，右边是 Streaming Analytics。Batch Analysis 就是传统意义上使用类似于 Map Reduce、Hive、Spark Batch 等，对作业进行分析、处理、生成离线报表，Streaming Analytics 使用流式分析引擎如 Storm，Flink 实时处理分析数据，应用较多的场景如实时大屏、实时报表。</p>
<h5 id="4-3-Flink-应用场景：Data-Driven"><a href="#4-3-Flink-应用场景：Data-Driven" class="headerlink" title="4.3 Flink 应用场景：Data Driven"></a><strong>4.3 Flink</strong> <strong>应用场景：Data Driven</strong></h5><p><img src="https://yqfile.alicdn.com/334b4162776f26b2bcc85017f719687a05fbc40d.jpeg" alt="4_006_jpeg"></p>
<p>从某种程度上来说，所有的实时的数据处理或者是流式数据处理都是属于 Data Driven，流计算本质上是 Data Driven 计算。应用较多的如风控系统，当风控系统需要处理各种各样复杂的规则时，Data Driven 就会把处理的规则和逻辑写入到Datastream 的 API 或者是 ProcessFunction 的 API 中，然后将逻辑抽象到整个 Flink 引擎中，当外面的数据流或者是事件进入就会触发相应的规则，这就是 Data Driven 的原理。在触发某些规则后，Data Driven 会进行处理或者是进行预警，这些预警会发到下游产生业务通知，这是 Data Driven 的应用场景，Data Driven 在应用上更多应用于复杂事件的处理。</p>
<h3 id="二、「有状态的流式处理」概念解析"><a href="#二、「有状态的流式处理」概念解析" class="headerlink" title="二、「有状态的流式处理」概念解析"></a><strong>二、「有状态的流式处理」概念解析</strong></h3><h4 id="1-传统批处理"><a href="#1-传统批处理" class="headerlink" title="1.传统批处理"></a>1.传统批处理</h4><p><img src="https://yqfile.alicdn.com/3b266c8f0ffc568f8d85703679581f20a7f8362a.png" alt="5_04"></p>
<p>传统批处理方法是持续收取数据，以时间作为划分多个批次的依据，再周期性地执行批次运算。但假设需要计算每小时出现事件转换的次数，如果事件转换跨越了所定义的时间划分，传统批处理会将中介运算结果带到下一个批次进行计算；除此之外，当出现接收到的事件顺序颠倒情况下，传统批处理仍会将中介状态带到下一批次的运算结果中，这种处理方式也不尽如人意。</p>
<h4 id="2-理想方法"><a href="#2-理想方法" class="headerlink" title="2.理想方法"></a>2.理想方法</h4><p><img src="https://yqfile.alicdn.com/a62d3ce6051eb3a9249855653fc6d953a41a6549.png" alt="6_07"></p>
<p><strong>第一点</strong>，要有理想方法，这个理想方法是引擎必须要有能力可以累积状态和维护状态，累积状态代表着过去历史中接收过的所有事件，会影响到输出。</p>
<p><strong>第二点</strong>，时间，时间意味着引擎对于数据完整性有机制可以操控，当所有数据都完全接受到后，输出计算结果。</p>
<p><strong>第三点</strong>，理想方法模型需要实时产生结果，但更重要的是采用新的持续性数据处理模型来处理实时数据，这样才最符合 continuous data 的特性。</p>
<h4 id="3-流式处理"><a href="#3-流式处理" class="headerlink" title="3.流式处理"></a>3.流式处理</h4><p><img src="https://yqfile.alicdn.com/f05cbff1caf39e9117ada3272484975fd28b4f2c.png" alt="7_08"></p>
<p>流式处理简单来讲即有一个无穷无尽的数据源在持续收取数据，以代码作为数据处理的基础逻辑，数据源的数据经过代码处理后产生出结果，然后输出，这就是流式处理的基本原理。</p>
<h4 id="4-分布式流式处理"><a href="#4-分布式流式处理" class="headerlink" title="4.分布式流式处理"></a>4.分布式流式处理</h4><p><img src="https://yqfile.alicdn.com/55a8733d374d7481323d03577386fa6d819e9032.png" alt="8_09"></p>
<p>假设 Input Streams 有很多个使用者，每个使用者都有自己的 ID，如果计算每个使用者出现的次数，我们需要让同一个使用者的出现事件流到同一运算代码，这跟其他批次需要做 group by 是同样的概念，所以跟 Stream 一样需要做分区，设定相应的 key，然后让同样的 key 流到同一个 computation instance 做同样的运算。</p>
<h4 id="5-有状态分布式流式处理"><a href="#5-有状态分布式流式处理" class="headerlink" title="5.有状态分布式流式处理"></a>5.有状态分布式流式处理</h4><p><img src="https://yqfile.alicdn.com/e9e371cc65f42705137953ccb9dd870216c0ce29.png" alt="9_10"></p>
<p>如图，上述代码中定义了变数 X，X 在数据处理过程中会进行读和写，在最后输出结果时，可以依据变数 X 决定输出的内容，即状态 X 会影响最终的输出结果。这个过程中，第一个重点是先进行了状态 co-partitioned key by，同样的 key 都会流到 computation instance，与使用者出现次数的原理相同，次数即所谓的状态，这个状态一定会跟同一个 key 的事件累积在同一个 computation instance。</p>
<p><img src="https://yqfile.alicdn.com/0d497c688f0a640d518c71aa5cae341caa5aa638.png" alt="10_11"></p>
<p>相当于根据输入流的 key 重新分区的 状态，当分区进入 stream 之后，这个 stream 会累积起来的状态也变成 copartiton 了。第二个重点是 embeded local state backend。有状态分散式流式处理的引擎，状态可能会累积到非常大，当 key 非常多时，状态可能就会超出单一节点的 memory 的负荷量，这时候状态必须有状态后端去维护它；在这个状态后端在正常状况下，用 in-memory 维护即可。</p>
<h3 id="三、Apache-Flink-的优势"><a href="#三、Apache-Flink-的优势" class="headerlink" title="三、Apache Flink 的优势"></a><strong>三、Apache Flink 的优势</strong></h3><h4 id="1-状态容错"><a href="#1-状态容错" class="headerlink" title="1.状态容错"></a>1.状态容错</h4><p>当我们考虑状态容错时难免会想到精确一次的状态容错，应用在运算时累积的状态，每笔输入的事件反映到状态，更改状态都是精确一次，如果修改超过一次的话也意味着数据引擎产生的结果是不可靠的。</p>
<ul>
<li>如何确保状态拥有精确一次（Exactly-once guarantee）的容错保证？</li>
<li>如何在分散式场景下替多个拥有本地状态的运算子产生一个全域一致的快照（Global consistent snapshot）？</li>
<li>更重要的是，如何在不中断运算的前提下产生快照？</li>
</ul>
<h5 id="1-1-简单场景的精确一次容错方法"><a href="#1-1-简单场景的精确一次容错方法" class="headerlink" title="1.1 简单场景的精确一次容错方法"></a>1.1 简单场景的精确一次容错方法</h5><p>还是以使用者出现次数来看，如果某个使用者出现的次数计算不准确，不是精确一次，那么产生的结果是无法作为参考的。在考虑精确的容错保证前，我们先考虑最简单的使用场景，如无限流的数据进入，后面单一的 Process 进行运算，每处理完一笔计算即会累积一次状态，这种情况下如果要确保 Process 产生精确一次的状态容错，每处理完一笔数据，更改完状态后进行一次快照，快照包含在队列中并与相应的状态进行对比，完成一致的快照，就能确保精确一次。</p>
<h5 id="1-2-分布式状态容错"><a href="#1-2-分布式状态容错" class="headerlink" title="1.2 分布式状态容错"></a>1.2 分布式状态容错</h5><p>Flink 作为分布式的处理引擎，在分布式的场景下，进行多个本地状态的运算，只产生一个全域一致的快照，如需要在不中断运算值的前提下产生全域一致的快照，就涉及到分散式状态容错。</p>
<ul>
<li><strong>Global consistent snapshot</strong></li>
</ul>
<p><img src="https://yqfile.alicdn.com/7ece51897efca57d6a6c0095d06e5409648f77fe.png" alt="11_21"></p>
<p>关于 Global consistent snapshot，当 Operator 在分布式的环境中，在各个节点做运算，首先产生 Global consistent snapshot 的方式就是处理每一笔数据的快照点是连续的，这笔运算流过所有的运算值，更改完所有的运算值后，能够看到每一个运算值的状态与该笔运算的位置，即可称为 consistent snapshot，当然，Global consistent snapshot 也是简易场景的延伸。</p>
<ul>
<li><strong>容错恢复</strong></li>
</ul>
<p><img src="https://yqfile.alicdn.com/108d0ac0398874ebafb0bc2318f3837e4fe789e1.png" alt="12_22"></p>
<p>首先了解一下 Checkpoint，上面提到连续性快照每个 Operator 运算值本地的状态后端都要维护状态，也就是每次将产生检查点时会将它们传入共享的 DFS 中。当任何一个 Process 挂掉后，可以直接从三个完整的 Checkpoint 将所有的运算值的状态恢复，重新设定到相应位置。Checkpoint 的存在使整个 Process 能够实现分散式环境中的 Exactly-once。</p>
<h5 id="1-3-分散式快照（Distributed-Snapshots）方法"><a href="#1-3-分散式快照（Distributed-Snapshots）方法" class="headerlink" title="1.3 分散式快照（Distributed Snapshots）方法"></a><strong>1.3</strong> <strong>分散式快照（Distributed Snapshots）方法</strong></h5><p><img src="https://yqfile.alicdn.com/f641b074b2334dd3fc0ef3a4db88fcaa511a29eb.png" alt="13_23"></p>
<p>关于 Flink 如何在不中断运算的状况下持续产生 Global consistent snapshot，其方式是基于用 simple lamport 演算法机制下延伸的。已知的一个点 Checkpoint barrier， Flink 在某个 Datastream 中会一直安插 Checkpoint barrier，Checkpoint barrier 也会 N — 1等等，Checkpoint barrier N 代表着所有在这个范围里面的数据都是Checkpoint barrier N。</p>
<p><img src="https://yqfile.alicdn.com/23a231fa509ef45a572bf036c51ee58355742fa0.png" alt="14_25"></p>
<p>举例：假设现在需要产生 Checkpoint barrier N，但实际上在 Flink 中是由 job manager 触发 Checkpoint，Checkpoint 被触发后开始从数据源产生 Checkpoint barrier。当 job 开始做 Checkpoint barrier N 的时候，可以理解为 Checkpoint barrier N 需要逐步填充左下角的表格。</p>
<p><img src="https://yqfile.alicdn.com/d064e1275ec4b0825a4311b85b4a8060a5a2e2bd.png" alt="15_26"></p>
<p>如图，当部分事件标为红色，Checkpoint barrier N 也是红色时，代表着这些数据或事件都由 Checkpoint barrier N 负责。Checkpoint barrier N 后面白色部分的数据或事件则不属于 Checkpoint barrier N。</p>
<p>在以上的基础上，当数据源收到 Checkpoint barrier N 之后会先将自己的状态保存，以读取 Kafka 资料为例，数据源的状态就是目前它在 Kafka 分区的位置，这个状态也会写入到上面提到的表格中。下游的 Operator 1 会开始运算属于 Checkpoint barrier N 的数据，当 Checkpoint barrier N 跟着这些数据流动到 Operator 1 之后,Operator 1 也将属于 Checkpoint barrier N 的所有数据都反映在状态中，当收到 Checkpoint barrier N 时也会直接对 Checkpoint 去做快照。</p>
<p><img src="https://yqfile.alicdn.com/b350e67de1c612366deb7d573d64733214cbfbfe.png" alt="16_27"></p>
<p>当快照完成后继续往下游走，Operator 2 也会接收到所有数据，然后搜索 Checkpoint barrier N 的数据并直接反映到状态，当状态收到 Checkpoint barrier N 之后也会直接写入到 Checkpoint N 中。以上过程到此可以看到 Checkpoint barrier N 已经完成了一个完整的表格，这个表格叫做 Distributed Snapshots，即分布式快照。分布式快照可以用来做状态容错，任何一个节点挂掉的时候可以在之前的 Checkpoint 中将其恢复。继续以上 Process，当多个 Checkpoint 同时进行，Checkpoint barrier N 已经流到 job manager 2，Flink job manager 可以触发其他的 Checkpoint，比如 Checkpoint N + 1，Checkpoint N + 2 等等也同步进行，利用这种机制，可以在不阻挡运算的状况下持续地产生 Checkpoint。</p>
<h4 id="2-状态维护"><a href="#2-状态维护" class="headerlink" title="2.状态维护"></a>2.状态维护</h4><p>状态维护即用一段代码在本地维护状态值，当状态值非常大时需要本地的状态后端来支持。</p>
<p><img src="https://yqfile.alicdn.com/942976c94cf14c11c3b7151d5f5205d8aa7359f0.png" alt="17_34"></p>
<p>如图，在 Flink 程序中，可以采用 getRuntimeContext().getState(desc); 这组 API 去注册状态。Flink 有多种状态后端，采用 API 注册状态后，读取状态时都是通过状态后端来读取的。Flink 有两种不同的状态值，也有两种不同的状态后端：</p>
<p><img src="https://yqfile.alicdn.com/39233b6ec882c80d2001c2fe1015dfd0c3ba2c5a.png" alt="18_37"></p>
<ul>
<li><strong>JVM Heap状态后端</strong>，适合数量较小的状态，当状态量不大时就可以采用 JVM Heap 的状态后端。JVM Heap 状态后端会在每一次运算值需要读取状态时，用 Java object read / writes 进行读或写，不会产生较大代价，但当 Checkpoint 需要将每一个运算值的本地状态放入 Distributed Snapshots 的时候，就需要进行序列化了。</li>
</ul>
<p><img src="https://yqfile.alicdn.com/5c2e8be0390d3ff995b6c7b29233f3caf5bfcb54.png" alt="19_40"></p>
<ul>
<li><strong>RocksDB 状态后端</strong>，它是一种 out of core 的状态后端。在 Runtime 的本地状态后端让使用者去读取状态的时候会经过磁盘，相当于将状态维护在磁盘里，与之对应的代价可能就是每次读取状态时，都需要经过序列化和反序列化的过程。当需要进行快照时只将应用序列化即可，序列化后的数据直接传输到中央的共享 DFS 中。</li>
</ul>
<p>Flink 目前支持以上两种状态后端，一种是纯 memory 的状态后端，另一种是有资源磁盘的状态后端，在维护状态时可以根据状态的数量选择相应的状态后端。</p>
<h4 id="3-Event-Time"><a href="#3-Event-Time" class="headerlink" title="3.Event - Time"></a>3.Event - Time</h4><p><strong>3.1</strong> <strong>不同时间种类</strong></p>
<p>在 Flink 及其他进阶的流式处理引擎出现之前，大数据处理引擎一直只支持 Processing-time 的处理。假设定义一个运算 windows 的窗口，windows 运算设定每小时进行结算。以 Processing-time 进行运算时可以发现数据引擎将 3 点至 4 点间收到的数据做结算。实际上在做报表或者分析结果时是想了解真实世界中 3 点至 4 点之间实际产生数据的输出结果，了解实际数据的输出结果就必须采用 Event – Time 了。</p>
<p><img src="https://yqfile.alicdn.com/2d0a56ba91f27c143db0cab6f5276e8d2d33834b.png" alt="20_42"></p>
<p>如图，Event - Time 相当于事件，它在数据最源头产生时带有时间戳，后面都需要用时间戳来进行运算。用图来表示，最开始的队列收到数据，每小时对数据划分一个批次，这就是 Event - Time Process 在做的事情。</p>
<p><strong>3.2</strong> <strong>Event - Time 处理</strong></p>
<p><img src="https://yqfile.alicdn.com/fb9c08413e705dc0e36d70beb44da682673b00a0.png" alt="21_44"></p>
<p>Event - Time 是用事件真实产生的时间戳去做 Re-bucketing，把对应时间 3 点到 4 点的数据放在 3 点到 4 点的 Bucket，然后 Bucket 产生结果。所以 Event - Time 跟 Processing - time 的概念是这样对比的存在。</p>
<p><img src="https://yqfile.alicdn.com/c51c6bad979faf3a0eb66f49dc025036c00f0f3a.png" alt="22_45"></p>
<p>Event - Time 的重要性在于记录引擎输出运算结果的时间。简单来说，流式引擎连续 24 小时在运行、搜集资料，假设 Pipeline 里有一个 windows Operator 正在做运算，每小时能产生结果，何时输出 windows 的运算值，这个时间点就是 Event - Time 处理的精髓，用来表示该收的数据已经收到。</p>
<p><strong>3.3</strong> <strong>Watermarks</strong></p>
<p><img src="https://yqfile.alicdn.com/460bbcae0f2a7366e24ca937c5c7b0cf7f738af9.png" alt="23_46"></p>
<p>Flink 实际上是用 watermarks 来实现 Event - Time 的功能。Watermarks 在 Flink 中也属于特殊事件，其精髓在于当某个运算值收到带有时间戳“ T ”的 watermarks 时就意味着它不会接收到新的数据了。使用 watermarks 的好处在于可以准确预估收到数据的截止时间。举例，假设预期收到数据时间与输出结果时间的时间差延迟 5 分钟，那么 Flink 中所有的 windows Operator 搜索 3 点至 4 点的数据，但因为存在延迟需要再多等5分钟直至收集完 4：05 分的数据，此时方能判定 4 点钟的资料收集完成了，然后才会产出 3 点至 4 点的数据结果。这个时间段的结果对应的就是 watermarks 的部分。</p>
<h4 id="4-状态保存与迁移"><a href="#4-状态保存与迁移" class="headerlink" title="4.状态保存与迁移"></a>4.状态保存与迁移</h4><p>流式处理应用无时无刻不在运行，运维上有几个重要考量：</p>
<ul>
<li>更改应用逻辑/修 bug 等，如何将前一执行的状态迁移到新的执行？</li>
<li>如何重新定义运行的平行化程度？</li>
<li>如何升级运算丛集的版本号？</li>
</ul>
<p>Checkpoint 完美符合以上需求，不过 Flink 中还有另外一个名词保存点（Savepoint），当手动产生一个 Checkpoint 的时候，就叫做一个 Savepoint。Savepoint 跟 Checkpoint 的差别在于检查点是 Flink 对于一个有状态应用在运行中利用分布式快照持续周期性的产生 Checkpoint，而 Savepoint 则是手动产生的 Checkpoint，Savepoint 记录着流式应用中所有运算元的状态。</p>
<p><img src="https://yqfile.alicdn.com/b3a404ef8a36871d98ba6485ede1e799d95d6e3e.png" alt="24_49"></p>
<p>如图，Savepoint A 和 Savepoint B，无论是变更底层代码逻辑、修 bug 或是升级 Flink 版本，重新定义应用、计算的平行化程度等，最先需要做的事情就是产生 Savepoint。</p>
<p>Savepoint 产生的原理是在 Checkpoint barrier 流动到所有的 Pipeline 中手动插入从而产生分布式快照，这些分布式快照点即 Savepoint。Savepoint 可以放在任何位置保存，当完成变更时，可以直接从 Savepoint 恢复、执行。</p>
<p>从 Savepoint 的恢复执行需要注意，在变更应用的过程中时间在持续，如 Kafka 在持续收集资料，当从 Savepoint 恢复时，Savepoint 保存着 Checkpoint 产生的时间以及 Kafka 的相应位置，因此它需要恢复到最新的数据。无论是任何运算，Event - Time 都可以确保产生的结果完全一致。</p>
<p>假设恢复后的重新运算用 Process Event - Time，将 windows 窗口设为 1 小时，重新运算能够在 10 分钟内将所有的运算结果都包含到单一的 windows 中。而如果使用 Event – Time，则类似于做 Bucketing。在 Bucketing 的状况下，无论重新运算的数量多大，最终重新运算的时间以及 windows 产生的结果都一定能保证完全一致。</p>
<h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>本文首先从 Apache Flink 的定义、架构、基本原理入手，对大数据流计算相关的基本概念进行辨析，在此基础上简单回顾了大数据处理方式的历史演进以及有状态的流式数据处理的原理，最后从目前有状态的流式处理面临的挑战分析 Apache Flink 作为业界公认为最好的流计算引擎之一所具备的天然优势。希望有助于大家厘清大数据流式处理引擎涉及的基本概念，能够更加得心应手的使用 Flink。</p>
]]></content>
      
        <categories>
            
            <category> 大数据 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Flink </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[图数据库洞察数据间的关联价值]]></title>
      <url>/%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B4%9E%E5%AF%9F%E6%95%B0%E6%8D%AE%E9%97%B4%E7%9A%84%E5%85%B3%E8%81%94%E4%BB%B7%E5%80%BC.html</url>
      <content type="html"><![CDATA[<p>大家好，我是吴敏。今天分享一个叫图数据库的技术产品。</p>
<p> <strong>01、 什么是图和图数据库</strong></p>
<a id="more"></a>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmsu5wrvqpj300z00t3y9.jpg" alt="图片"></p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmss77qt1fj30u00gtgpm.jpg" alt="图片"></p>
<p>先来介绍一下什么是图和图数据库，所谓的图和平常认知的图片其实不是同一个概念，图（Graph）在计算机科学里面是一种数据结构，这种数据结构有三个比较主要的概念：点、边和属性。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmss7lzpmzj30u00gun2h.jpg" alt="图片"></p>
<p>通俗的说，图结构还有其他的叫法，比如：网络结构、拓扑结构，大致上都是描述的同一种数据结构。</p>
<p>举个例子，上面这个图是典型的图结构（网络结构），人和公司，公司与公司都存在关联关系。这里面存在几个重要的概念，在网络结构中一家公司、一个人可以是一个<strong>点</strong>；还有另外一个概念是<strong>边</strong>，描述的是点与点之间的关系，对应上图中母公司和子公司之间的一个控股关系，也可以是某一个人是另外一个公司的董事长，这样的一个身份关系。点和边基本上组成一个网络结构。</p>
<p>图结构在工业界使用的时候还会加上一个概念就是<strong>属性</strong>。比如，中间的这个人（点）可以有他的身份证、性别、年龄属性，关系就是边上也可以有一些属性，比如说投资某家公司的投资金额、投资的比例、投资的时间等等，都可以构成这个投资关系的属性。</p>
<p>像基于上图这样的工商关系，微众银行、腾讯和我们（Nebula Graph）也都是有各自合作的项目。</p>
<p><strong>1、图数据库的案例 1：反欺诈</strong> </p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmss87lwiuj30u00gt11i.jpg" alt="图片"></p>
<p>下面来介绍下图的应用。</p>
<p>一般来说，图在安全场景里面的应用会比较多，上面这种图的中间部分是和 360金融合作的一个项目，主要用于识别诈骗团伙。</p>
<p>具体来说，现在是互联网时代，很多 APP 支持申请贷款，不管是持牌或者持其他牌照的平台，都可以提供一定的贷款能力。与此同时，也存在团伙“作案”，当然抢银行的少，诈骗、骗贷的团伙多，而这些团伙是有特征的，可以通过一定的方式进行关联。</p>
<p>在左边的这个例子里，有些的黑产团伙，他们控制的账号会登录一些设备（手机），这些设备和 Wi-Fi 有关联关系。通过这样的 账号-设备-WiFi 关联关系可以识别出来这些团伙。这些团伙被识别出来后，如果团伙相关的人来贷款或者说是来申请授信时，在风控环节会先识别出来。</p>
<p>在中间这个例子里，红色的点是已知存在风险的账号，最中间的那个区域就是一个风险的团伙，这些节点就是被识别出来的风险节点，它们基于 Wi-Fi 关系将其他点关联到了一起。</p>
<p>360 金融通过用图的方法大概识别了接近 100 万个有风险的团伙，所以这些团伙哪怕换一个马甲或者其他设备也能第一时间把他们识别出来，进行屏蔽。右边案例图是一些受害人，蓝色的点是诈骗团伙，诈骗团伙还是有挺明显的特征存在的。</p>
<p><strong>2 图数据库的案例 2：公司信用分 </strong></p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmss8qfi2zj30u00gtgqy.jpg" alt="图片"></p>
<p>上面的例子主要是识别有风险的人，在这个例子里主要讲下 BOSS 直聘的公司风控。在上图中显示了 BOSS 直聘的一些公司，有些公司是很早入驻 BOSS 直聘平台，有些是新注册的。当中存在部分公司不一定可信，需要对这些公司作区分给一定信用分。比如说，公司信用等级好的对它的运营策略会放松点，信用等级差的公司对它的运营审核严格些。因为不停地有新的公司在注册，可以通过不同的运营方式得到这些公司的不同信息，上图这里用的是同这些公司有关联关系的公司。举个例子，我新注册一家公司的时候，这家公司还是会和其它公司有一些互动和关联，例如：该公司的分公司，或是公司同失信被执行人之间有关联关系，通过一轮轮的迭代算出风险评级和信用评级，为新出来的公司提供一个启动初始信用分，这个方法类似于网页权重中使用的 Page Rank。每天晚上 BOSS 直聘会跑几百万社区的权重。</p>
<p><strong>3 图数据库的案例 3：可信设备 </strong></p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmss8wwl41j30u00gwwic.jpg" alt="图片"></p>
<p>这个例子比较直观。现在每个人基本上都有手机，然后会有常用的手机设备，也可能你会临时换一个设备。这个常用设备下，鉴权的要求比较低。而用临时设备鉴权的要求较高，风控等级较高。还有一种情况就是家人临时使用彼此的设备，这种情况下的鉴权要求可以不需要那么高。因为只要换一个新设备就判断为高风险场景的话，其实对于用户的侵入和打扰很明显。</p>
<p><strong>4 图数据库的案例 4：智能助理 </strong></p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmss9413kgj30u00gtgtf.jpg" alt="图片"></p>
<p>这个是和美团合作的项目，本身其实是有两方面，一方面是和知识图谱相关，一方面是和深度学习相关。目前来说大多数公司的推荐系统都有基于深度学习的模型。那么会存在一个问题：这个推荐出来的内容可解释性差。简单来说，用户不知道为什么产生这样的列表。因此，美团结合图谱做了一些应用，把所有的菜、地点、人、人与人之间的关系还有这些东西组成大的网，当深度学习模型算出推荐列表之后，取用户和商家之间所有可能的关系，取出一条路径或者多条路径的，在多条路径之间做一些加权或者说计算一些路径规则分，呈现给用户看上去更可理解的理由。比如，这里挺有意思的理由，叫“在北京喜欢北京菜的山东老乡都说这家店很赞”，看到这个理由的时候，你会觉得这个推荐略微合理。当然类似的方法也可以用于像问答机器人这样的 KBQA 的系统。</p>
<p><strong>5 图数据库的案例 5：外部作弊与刷单</strong></p>
<h3 id=""><a href="#" class="headerlink" title=""></a><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmss97m4e3j30u00gvq8j.jpg" alt="图片"></h3><p>这是一个刷单的例子，其实很多公司会有运营经费，特别是对新用户会有运营经费，但是这会招来一些羊毛党。这些专业的羊毛党技术很好，他们来薅羊毛的速度比一般的消费者速度快很多，一般前期的大多数的运营经费不是给新用户用掉而是给羊毛党薅走了，羊毛党一般就是那些人，把他们识别出来之后，就可以降低运营经费被薅走的概率。</p>
<p><strong>6 图数据库的案例 6：数据治理系统</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmss9hlsckj30u00gw43l.jpg" alt="图片"></p>
<p>这个例子是关于 IT 系统的。我相信现在大多数的公司都是有一个庞大的数仓，几万张甚至几百万张的表，表与表之间又有比较强的依赖关系。例如：一张表或者某几张表取当中几个字段，通过一个 job 清洗，生成下一张表。某一天 DBA 或者某个业务人员发现有一个数据不太对，想知道哪个环节出错了，一层一层往上查，上百层的依赖，用图的方式关联就可以很快的查到哪个地方更有可能出错。这也是我们和微众银行合作的，他们现在正在使用的东西。</p>
<p><strong>7 图数据库的案例 7、8：服务依赖分析 / 代码依赖分析</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmssa14ssmj30u00gvjx4.jpg" alt="图片"></p>
<p>左边是和运维相关的，右边是和研发相关的事。因为现在基本都是微服务化了，整个微服务之间的调用关系其实是很庞大的。特别是一个大型集团内的RPC 调用关系，运维自己都不一定搞得清楚全局是什么依赖情况。</p>
<p>这个是美团的例子，把所有的调用关系写到图谱里，大概是百万级别的调用关系。比如说运维想知道过去 7 天可用率低于 4 个 9 的链路有哪些，可以非常快速地识别出来，深度可以是 10 层也可以 100 层。</p>
<p>右边是一个辅助开发过程的小工具，对研发人员来说挺方便的。对于一个大型的代码仓库，函数之间相互调用。比如说研发今天想改用一个接口，但是我不知道有多少人在调用这个接口，是怎么调用的。对于测试来说，也不知道要测试哪些边界场景。那可以把这些关系都放到图谱里面去，这样大约是一个千万级别的调用关系，把整个调用关系全抽出来之后，那研发说我想看一眼这个接口被多少人调用了，调用方是怎么使用的；QA 要做测试的时候，可能有哪些边界场景受到影响也可以很快地知道。</p>
<p><strong>02 为什么使用图数据库</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/Rdx7pYibYTUzicyTnfmGwl45nNmmbN3xGrxibt5vsAZackqPZnib4em84QPP8q6ljQF0MQkYIB22lxl9OD060yBIww/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmssab1zbzj30u00gu78a.jpg" alt="图片"></p>
<p>刚才说的其实就是一些图的应用，当然其实这些应用不用图这种数据结构来处理，也是可以的。比如在数仓用 Spark 或者写 SQL 来做也可以。但是为什么更推荐用图数据库呢？有以下几个原因。</p>
<p><strong>1 一图胜千言 </strong></p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmssacu9ytj30u00gqdmr.jpg" alt="图片"></p>
<p>一个是图的表达能力更强。左边是用表的结构方式来处理人物关系和社区关系。右边当中人的是比较重要的节点，他在左边的表中对应的某一行，右边是用图的方式来看。通过不同的着色可以很容易地看出来不同的社区，然后不同的社区之间通过某些特殊的节点来关联。这样远比用表的方式直观得多，特别是在右边图里面查找中心节点比起在左边的表中查找属性值大小要方便的多。</p>
<p><strong>2 繁琐 vs 简洁 </strong></p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmssanp5huj30u00gxgrf.jpg" alt="图片"></p>
<p>第二个是对于图的遍历这种操作来说——相当于表操作中 join。如果用 SQL 来写，大约是左边这么长，也不是算非常复杂；但是用图的查询语言（右侧）来写的话，其实例子核心就是一句话，沿着一个点开始沿着这样一个路径取 Person 数据。所以对于图遍历操作，图专用的查询语言要更简洁。</p>
<p><strong>3 更快！ </strong></p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmssato1pij30u00gstcc.jpg" alt="图片"></p>
<p>使用图还有一个优势是更快，行业内的经典例子就是查询的数据深度越多的时候，图数据库的优势越加明显。对于 4、 5 层深度的查询，小时级别的时延和秒级别的时延，是两种不同的业务形态。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmssawspgdj30u00gwn15.jpg" alt="图片"></p>
<p><strong>4 流行趋势</strong></p>
<p>最后一个原因是关于流行趋势。在国际上，用于统计各种数据库类型流行情况的 DB-Engines 上，可以看到图数据库的趋势。上图这是这个月最新的数据，绿色是图这种数据库类型流行的趋势，最下面红色的线是关系型数据库的流行趋势。可以看到，图数据库在过去 8 年内保持了比较好的增速，增长了 11 倍。</p>
<p><strong>03 为什么选择 Nebula Graph</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/Rdx7pYibYTUzicyTnfmGwl45nNmmbN3xGrxibt5vsAZackqPZnib4em84QPP8q6ljQF0MQkYIB22lxl9OD060yBIww/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmssb7yaw9j30u00gvq6z.jpg" alt="图片"></p>
<p>当然，在整个图数据库领域，产品并不是只有 Nebula Graph 一个，也有很多的其他公司。今天早上也有其他同行在会场上，我想解释一下为什么会推荐 Nebula Graph。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmssbapbdmj30u00gxq4a.jpg" alt="图片"></p>
<p>一般大家选型基于不同的需求看的重点不一样，我想可能会对可靠性、成本性能、功能各个方面进行权衡。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmssbdjciej30u00gxgs3.jpg" alt="图片"></p>
<p>Nebula Graph 是一个开源的产品，源代码是开放在 GitHub 上的。虽然产品的研发时间不长，从 2018 年 10 月开始第一行代码，但是整个项目很活跃。</p>
<p>上图左下角是 Nebula Graph 中文论坛的情况，在国内有大量的使用者。而 Nebula Graph 本身是开源的项目，整个项目除了我们公司人员之外也有很多国内外贡献者，很多人在使用 Nebula 之后会发现一些 bug 这样就会 file 个 issue，也有不少人会自己动手 fix 和贡献 feature，这样提升了整个研发迭代速度。</p>
<p>右边是所有 Nebula 的 GitHub 贡献者列表，这些是公开情况，你可以在 GitHub 上面看到。总的来说，贡献者来源很多，并不是背后只有一家公司在研发。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmssbgb0w4j30u00gw78k.jpg" alt="图片"></p>
<p>上图是在生产环境使用 Nebula Graph 的公司。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmssbinu8fj30u00gnaii.jpg" alt="图片"></p>
<p>既然是 Nebula Graph 是开源代码的，那么所有人可以下载和评测。所有的用户都可以根据自己的业务场景做的评测，会更贴近自己的实际场景。而不像某些供应商自己提供的评测，用户难验证这样的评测里面隐藏了多少坑。</p>
<p>这张图第一个例子是去年和微信合作的项目，他们现在的生产环境单个集群是 50 台机器的规模，它的更新数据量大概是 4,000 亿这样的级别。第二个是美团的例子，美团所做的 Nebula 和其它竞争对手产品的评测。因为美团也是有一个非常高的可用需求，基本上都是要两地多机房。第三个是 BOSS 直聘的评测，从友商产品迁移到 Nebula 之后，从最初只能做 50 亿量级的边的产品，提升到做千亿点边的项目。下面这是贝壳做的评测，公开在今年的DTCC，也是和友商产品的的对比。右边是 360 金融做的评测，生产环境服务器数量减少到原先集群的 1/3，性能是原来的 20 倍以上。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmssbmqw5aj30u00gztbf.jpg" alt="图片"></p>
<p>虽然软件本身是开源的，但是开源软件是可以商业化的。这个在国内外也是一个比较普遍的事情。Nebula 的源代码是开放的，所以不管是社区版也好，企业版也好，在产品功能内核、可视化、生态方面基本上没有太大的差别。主要的差别是在服务上，社区版如果有问题可以通过开源社区的方式来解决，按照开源协议（Apache 2.0）的约定。而如果是企业版的话，那会提供企业版的严格的 SLA。另外，云这几年流行和增速也非常的快，云目前是在受邀公测的阶段。大家有什么兴趣可以联系我们。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvcGgzTFNtZUdOV09mR1JuQnB5QlRhQQ==" title="https://mp.weixin.qq.com/s/ph3LSmeGNWOfGRnBpyBTaA">文章原址<i class="fa fa-external-link"></i></span></p>
]]></content>
      
        <categories>
            
            <category> 图数据库 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> NebulaGraph </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Flink知识图谱]]></title>
      <url>/Flink%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1.html</url>
      <content type="html"><![CDATA[<p>社区整理了这样一份知识图谱，由 Apache Flink Committer 执笔，四位 PMC 成员审核，将 Flink 9 大技术版块详细拆分，突出重点内容并搭配全面的学习素材。看完这份图谱，才算真的搞懂 Flink！</p>
<a id="more"></a>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmrzenh51zj30u02s5x6t.jpg" alt="IMG_00001"></p>
<p>相关链接</p>
<p>ververica中文网站:</p>
<p><span class="exturl" data-url="aHR0cHM6Ly92ZXJ2ZXJpY2EuY24v" title="https://ververica.cn/">https://ververica.cn/<i class="fa fa-external-link"></i></span></p>
<p>Apache Flink 视频教程:</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZsaW5rLWNoaW5hL2ZsaW5rLXRyYWluaW5nLWNvdXJzZQ==" title="https://github.com/flink-china/flink-training-course">https://github.com/flink-china/flink-training-course<i class="fa fa-external-link"></i></span></p>
<p>Flink Forward Asia 2019:</p>
<p><span class="exturl" data-url="aHR0cHM6Ly92ZXJ2ZXJpY2EuY24vZGV2ZWxvcGVycy9mbGluay1mb3J3YXJkLWFzaWEtMjAxOS8=" title="https://ververica.cn/developers/flink-forward-asia-2019/">https://ververica.cn/developers/flink-forward-asia-2019/<i class="fa fa-external-link"></i></span></p>
<p>Flink Forward China 2018:</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZsaW5rLWNoaW5hL2ZsaW5rLWZvcndhcmQtY2hpbmEtMjAxOA==" title="https://github.com/flink-china/flink-forward-china-2018">https://github.com/flink-china/flink-forward-china-2018<i class="fa fa-external-link"></i></span></p>
<p>Flink Forward San Francisco 2015-2017: <span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vY2hhbm5lbC9VQ1k4X2xnaVpMWkVyWlBGNDdhMmhYTUE=" title="https://www.youtube.com/channel/UCY8_lgiZLZErZPF47a2hXMA">https://www.youtube.com/channel/UCY8_lgiZLZErZPF47a2hXMA<i class="fa fa-external-link"></i></span> (需要翻墙)</p>
<p>◀ Flink 中文社区微信公众号 Apache Flink Stateful Computations over Data</p>
<p>Streams 唯一官方发布渠道</p>
<p>​               扫码关注，获取更多技术干货</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZsaW5rLWNoaW5hL2ZsaW5rLXRyYWluaW5nLWNvdXJzZSMzNC1mbGluay1jZXAt5a6e5oiY" title="https://github.com/flink-china/flink-training-course#34-flink-cep-实战">https://github.com/flink-china/flink-training-course#34-flink-cep-%E5%AE%9E%E6%88%98<i class="fa fa-external-link"></i></span></p>
<p>State Processor API:</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9jaS5hcGFjaGUub3JnL3Byb2plY3RzL2ZsaW5rL2ZsaW5rLWRvY3MtcmVsZWFzZS0xLjkvZGV2L2xpYnMvc3RhdGVfcHJvY2Vzc29yX2FwaS5odG1s" title="https://ci.apache.org/projects/flink/flink-docs-release-1.9/dev/libs/state_processor_api.html">https://ci.apache.org/projects/flink/flink-docs-release-1.9/dev/libs/state_processor_api.html<i class="fa fa-external-link"></i></span></p>
<p>Gelly:</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9jaS5hcGFjaGUub3JnL3Byb2plY3RzL2ZsaW5rL2ZsaW5rLWRvY3MtcmVsZWFzZS0xLjkvZGV2L2xpYnMvZ2VsbHkv" title="https://ci.apache.org/projects/flink/flink-docs-release-1.9/dev/libs/gelly/">https://ci.apache.org/projects/flink/flink-docs-release-1.9/dev/libs/gelly/<i class="fa fa-external-link"></i></span></p>
<p>Table API &amp; SQL 相关链接</p>
<p>Dynamic Table:</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9mbGluay5hcGFjaGUub3JnL25ld3MvMjAxNy8wNC8wNC9keW5hbWljLXRhYmxlcy5odG1s" title="https://flink.apache.org/news/2017/04/04/dynamic-tables.html">https://flink.apache.org/news/2017/04/04/dynamic-tables.html<i class="fa fa-external-link"></i></span> <span class="exturl" data-url="aHR0cHM6Ly9jaS5hcGFjaGUub3JnL3Byb2plY3RzL2ZsaW5rL2ZsaW5rLWRvY3MtbWFzdGVyL2Rldi90YWJsZS9zdHJlYW1pbmcvZHluYW1pY190YWJsZXMuaHRtbA==" title="https://ci.apache.org/projects/flink/flink-docs-master/dev/table/streaming/dynamic_tables.html">https://ci.apache.org/projects/flink/flink-docs-master/dev/table/streaming/dynamic_tables.html<i class="fa fa-external-link"></i></span></p>
<p>Time Attributes:</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9jaS5hcGFjaGUub3JnL3Byb2plY3RzL2ZsaW5rL2ZsaW5rLWRvY3MtbWFzdGVyL2Rldi90YWJsZS9zdHJlYW1pbmcvdGltZV9hdHRyaWJ1dGVzLmh0bWw=" title="https://ci.apache.org/projects/flink/flink-docs-master/dev/table/streaming/time_attributes.html">https://ci.apache.org/projects/flink/flink-docs-master/dev/table/streaming/time_attributes.html<i class="fa fa-external-link"></i></span></p>
<p>Temporal Tables:</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9jaS5hcGFjaGUub3JnL3Byb2plY3RzL2ZsaW5rL2ZsaW5rLWRvY3MtbWFzdGVyL2Rldi90YWJsZS9zdHJlYW1pbmcvdGVtcG9yYWxfdGFibGVzLmh0bWw=" title="https://ci.apache.org/projects/flink/flink-docs-master/dev/table/streaming/temporal_tables.html">https://ci.apache.org/projects/flink/flink-docs-master/dev/table/streaming/temporal_tables.html<i class="fa fa-external-link"></i></span></p>
<p>Query Configuration:</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9jaS5hcGFjaGUub3JnL3Byb2plY3RzL2ZsaW5rL2ZsaW5rLWRvY3MtbWFzdGVyL2Rldi90YWJsZS9zdHJlYW1pbmcvcXVlcnlfY29uZmlndXJhdGlvbi5odG1s" title="https://ci.apache.org/projects/flink/flink-docs-master/dev/table/streaming/query_configuration.html">https://ci.apache.org/projects/flink/flink-docs-master/dev/table/streaming/query_configuration.html<i class="fa fa-external-link"></i></span></p>
<p>Flink SQL 编程:</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZsaW5rLWNoaW5hL2ZsaW5rLXRyYWluaW5nLWNvdXJzZSMxOS1mbGluay1zcWwt57yW56iL" title="https://github.com/flink-china/flink-training-course#19-flink-sql-编程">https://github.com/flink-china/flink-training-course#19-flink-sql-%E7%BC%96%E7%A8%8B<i class="fa fa-external-link"></i></span></p>
<p>Create Table/Databases/Function:</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9jaS5hcGFjaGUub3JnL3Byb2plY3RzL2ZsaW5rL2ZsaW5rLWRvY3MtbWFzdGVyL2Rldi90YWJsZS9zcWwvY3JlYXRlLmh0bWw=" title="https://ci.apache.org/projects/flink/flink-docs-master/dev/table/sql/create.html">https://ci.apache.org/projects/flink/flink-docs-master/dev/table/sql/create.html<i class="fa fa-external-link"></i></span></p>
<p>Drop Table/Databases/Function:</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9jaS5hcGFjaGUub3JnL3Byb2plY3RzL2ZsaW5rL2ZsaW5rLWRvY3MtbWFzdGVyL2Rldi90YWJsZS9zcWwvZHJvcC5odG1s" title="https://ci.apache.org/projects/flink/flink-docs-master/dev/table/sql/drop.html">https://ci.apache.org/projects/flink/flink-docs-master/dev/table/sql/drop.html<i class="fa fa-external-link"></i></span></p>
<p>Alter Table/Databases/Function:</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9jaS5hcGFjaGUub3JnL3Byb2plY3RzL2ZsaW5rL2ZsaW5rLWRvY3MtbWFzdGVyL2Rldi90YWJsZS9zcWwvYWx0ZXIuaHRtbA==" title="https://ci.apache.org/projects/flink/flink-docs-master/dev/table/sql/alter.html">https://ci.apache.org/projects/flink/flink-docs-master/dev/table/sql/alter.html<i class="fa fa-external-link"></i></span></p>
<p>Query:</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9jaS5hcGFjaGUub3JnL3Byb2plY3RzL2ZsaW5rL2ZsaW5rLWRvY3MtbWFzdGVyL2Rldi90YWJsZS9zcWwvcXVlcmllcy5odG1s" title="https://ci.apache.org/projects/flink/flink-docs-master/dev/table/sql/queries.html">https://ci.apache.org/projects/flink/flink-docs-master/dev/table/sql/queries.html<i class="fa fa-external-link"></i></span></p>
<p>SQL Client:</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9jaS5hcGFjaGUub3JnL3Byb2plY3RzL2ZsaW5rL2ZsaW5rLWRvY3MtbWFzdGVyL2Rldi90YWJsZS9zcWxDbGllbnQuaHRtbA==" title="https://ci.apache.org/projects/flink/flink-docs-master/dev/table/sqlClient.html">https://ci.apache.org/projects/flink/flink-docs-master/dev/table/sqlClient.html<i class="fa fa-external-link"></i></span></p>
<p>Flink Table API 编程:</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZsaW5rLWNoaW5hL2ZsaW5rLXRyYWluaW5nLWNvdXJzZSMxOC1mbGluay10YWJsZS1hcGkt57yW56iL" title="https://github.com/flink-china/flink-training-course#18-flink-table-api-编程">https://github.com/flink-china/flink-training-course#18-flink-table-api-%E7%BC%96%E7%A8%8B<i class="fa fa-external-link"></i></span></p>
<p>Simplify Machine Learning With Flink TableAPI:</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9maWxlcy5hbGljZG4uY29tL3Rwc3NlcnZpY2UvNjkxODFkMWZkODVkMTU2MzVhN2ZlNjRlYmFmYmYxNDAucGRm" title="https://files.alicdn.com/tpsservice/69181d1fd85d15635a7fe64ebafbf140.pdf">https://files.alicdn.com/tpsservice/69181d1fd85d15635a7fe64ebafbf140.pdf<i class="fa fa-external-link"></i></span> <span class="exturl" data-url="aHR0cHM6Ly95cS5hbGl5dW4uY29tL2xpdmUvNzAz" title="https://yq.aliyun.com/live/703">https://yq.aliyun.com/live/703<i class="fa fa-external-link"></i></span> (大概从视频52:00开始)</p>
<p>Apache Flink Python API 现状及规划:</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZsaW5rLWNoaW5hL2ZsaW5rLXRyYWluaW5nLWNvdXJzZSMyMTQtYXBhY2hlLWZsaW5rLXB5dGhvbi1hcGkt546w54q25Y+K6KeE5YiS" title="https://github.com/flink-china/flink-training-course#214-apache-flink-python-api-现状及规划">https://github.com/flink-china/flink-training-course#214-apache-flink-python-api-%E7%8E%B0%E7%8A%B6%E5%8F%8A%E8%A7%84%E5%88%92<i class="fa fa-external-link"></i></span></p>
<p>Built-in Functions:</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9jaS5hcGFjaGUub3JnL3Byb2plY3RzL2ZsaW5rL2ZsaW5rLWRvY3MtbWFzdGVyL2Rldi90YWJsZS9mdW5jdGlvbnMvc3lzdGVtRnVuY3Rpb25zLmh0bWw=" title="https://ci.apache.org/projects/flink/flink-docs-master/dev/table/functions/systemFunctions.html">https://ci.apache.org/projects/flink/flink-docs-master/dev/table/functions/systemFunctions.html<i class="fa fa-external-link"></i></span></p>
<p>User Defined Functions:</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9jaS5hcGFjaGUub3JnL3Byb2plY3RzL2ZsaW5rL2ZsaW5rLWRvY3MtbWFzdGVyL2Rldi90YWJsZS9mdW5jdGlvbnMvdWRmcy5odG1s" title="https://ci.apache.org/projects/flink/flink-docs-master/dev/table/functions/udfs.html">https://ci.apache.org/projects/flink/flink-docs-master/dev/table/functions/udfs.html<i class="fa fa-external-link"></i></span></p>
<p>Connect to External Systems:</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9jaS5hcGFjaGUub3JnL3Byb2plY3RzL2ZsaW5rL2ZsaW5rLWRvY3MtbWFzdGVyL2Rldi90YWJsZS9jb25uZWN0Lmh0bWw=" title="https://ci.apache.org/projects/flink/flink-docs-master/dev/table/connect.html">https://ci.apache.org/projects/flink/flink-docs-master/dev/table/connect.html<i class="fa fa-external-link"></i></span></p>
<p>User-defined Table Sources &amp; Sinks:</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9jaS5hcGFjaGUub3JnL3Byb2plY3RzL2ZsaW5rL2ZsaW5rLWRvY3MtbWFzdGVyL2Rldi90YWJsZS9zb3VyY2VTaW5rcy5odG1s" title="https://ci.apache.org/projects/flink/flink-docs-master/dev/table/sourceSinks.html">https://ci.apache.org/projects/flink/flink-docs-master/dev/table/sourceSinks.html<i class="fa fa-external-link"></i></span></p>
<p>深度探索 Flink SQL:</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZsaW5rLWNoaW5hL2ZsaW5rLXRyYWluaW5nLWNvdXJzZSMyMTMt5rex5bqm5o6i57SiLWZsaW5rLXNxbA==" title="https://github.com/flink-china/flink-training-course#213-深度探索-flink-sql">https://github.com/flink-china/flink-training-course#213-%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2-flink-sql<i class="fa fa-external-link"></i></span></p>
<p>Batch as a Special Case of Streaming and Alibaba’s contribution of Blink:</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9mbGluay5hcGFjaGUub3JnL25ld3MvMjAxOS8wMi8xMy91bmlmaWVkLWJhdGNoLXN0cmVhbWluZy1ibGluay5odG1s" title="https://flink.apache.org/news/2019/02/13/unified-batch-streaming-blink.html">https://flink.apache.org/news/2019/02/13/unified-batch-streaming-blink.html<i class="fa fa-external-link"></i></span></p>
<p>Modules:</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9jaS5hcGFjaGUub3JnL3Byb2plY3RzL2ZsaW5rL2ZsaW5rLWRvY3MtbWFzdGVyL2Rldi90YWJsZS9tb2R1bGVzLmh0bWw=" title="https://ci.apache.org/projects/flink/flink-docs-master/dev/table/modules.html">https://ci.apache.org/projects/flink/flink-docs-master/dev/table/modules.html<i class="fa fa-external-link"></i></span></p>
<p>Catalog:</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9jaS5hcGFjaGUub3JnL3Byb2plY3RzL2ZsaW5rL2ZsaW5rLWRvY3MtbWFzdGVyL2Rldi90YWJsZS9jYXRhbG9ncy5odG1s" title="https://ci.apache.org/projects/flink/flink-docs-master/dev/table/catalogs.html">https://ci.apache.org/projects/flink/flink-docs-master/dev/table/catalogs.html<i class="fa fa-external-link"></i></span></p>
<p>Hive Integration:</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9jaS5hcGFjaGUub3JnL3Byb2plY3RzL2ZsaW5rL2ZsaW5rLWRvY3MtbWFzdGVyL2Rldi90YWJsZS9oaXZlLw==" title="https://ci.apache.org/projects/flink/flink-docs-master/dev/table/hive/">https://ci.apache.org/projects/flink/flink-docs-master/dev/table/hive/<i class="fa fa-external-link"></i></span></p>
<p>Deployment and Operations 相关链接</p>
<p>Flink 安装部署、环境配置及运行应用程序:</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZsaW5rLWNoaW5hL2ZsaW5rLXRyYWluaW5nLWNvdXJzZSMxMy1mbGluay0lRTUlQUUlODklRTglQTMlODUlRTklODM=" title="https://github.com/flink-china/flink-training-course#13-flink-%E5%AE%89%E8%A3%85%E9%83">https://github.com/flink-china/flink-training-course#13-flink-%E5%AE%89%E8%A3%85%E9%83<i class="fa fa-external-link"></i></span> %A8%E7%BD%B2%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%8F%8A%E8%BF%90% E8%A1%8C%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F</p>
<p>Local Cluster:</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9jaS5hcGFjaGUub3JnL3Byb2plY3RzL2ZsaW5rL2ZsaW5rLWRvY3MtbWFzdGVyL29wcy9kZXBsb3ltZW50L2xvY2FsLmh0bWw=" title="https://ci.apache.org/projects/flink/flink-docs-master/ops/deployment/local.html">https://ci.apache.org/projects/flink/flink-docs-master/ops/deployment/local.html<i class="fa fa-external-link"></i></span></p>
<p>Standalone Cluster:</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9jaS5hcGFjaGUub3JnL3Byb2plY3RzL2ZsaW5rL2ZsaW5rLWRvY3MtbWFzdGVyL29wcy9kZXBsb3ltZW50L2NsdXN0ZXJfc2V0dXAuaHRtbA==" title="https://ci.apache.org/projects/flink/flink-docs-master/ops/deployment/cluster_setup.html">https://ci.apache.org/projects/flink/flink-docs-master/ops/deployment/cluster_setup.html<i class="fa fa-external-link"></i></span></p>
<p>YARN:</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9jaS5hcGFjaGUub3JnL3Byb2plY3RzL2ZsaW5rL2ZsaW5rLWRvY3MtbWFzdGVyL29wcy9kZXBsb3ltZW50L3lhcm5fc2V0dXAuaHRtbA==" title="https://ci.apache.org/projects/flink/flink-docs-master/ops/deployment/yarn_setup.html">https://ci.apache.org/projects/flink/flink-docs-master/ops/deployment/yarn_setup.html<i class="fa fa-external-link"></i></span></p>
<p>Mesos:</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9jaS5hcGFjaGUub3JnL3Byb2plY3RzL2ZsaW5rL2ZsaW5rLWRvY3MtbWFzdGVyL29wcy9kZXBsb3ltZW50L21lc29zLmh0bWw=" title="https://ci.apache.org/projects/flink/flink-docs-master/ops/deployment/mesos.html">https://ci.apache.org/projects/flink/flink-docs-master/ops/deployment/mesos.html<i class="fa fa-external-link"></i></span></p>
<p>Introducing Docker Images for Apache Flink:</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9mbGluay5hcGFjaGUub3JnL25ld3MvMjAxNy8wNS8xNi9vZmZpY2lhbC1kb2NrZXItaW1hZ2UuaHRtbA==" title="https://flink.apache.org/news/2017/05/16/official-docker-image.html">https://flink.apache.org/news/2017/05/16/official-docker-image.html<i class="fa fa-external-link"></i></span></p>
<p>Running Apache Flink on Kubernetes with KUDO:</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9mbGluay5hcGFjaGUub3JnL25ld3MvMjAxOS8xMi8wOS9mbGluay1rdWJlcm5ldGVzLWt1ZG8uaHRtbA==" title="https://flink.apache.org/news/2019/12/09/flink-kubernetes-kudo.html">https://flink.apache.org/news/2019/12/09/flink-kubernetes-kudo.html<i class="fa fa-external-link"></i></span></p>
<p>High Availability:</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9jaS5hcGFjaGUub3JnL3Byb2plY3RzL2ZsaW5rL2ZsaW5rLWRvY3MtbWFzdGVyL29wcy9qb2JtYW5hZ2VyX2hpZ2hfYXZhaWxhYmlsaXR5Lmh0bWw=" title="https://ci.apache.org/projects/flink/flink-docs-master/ops/jobmanager_high_availability.html">https://ci.apache.org/projects/flink/flink-docs-master/ops/jobmanager_high_availability.html<i class="fa fa-external-link"></i></span></p>
<p>Command-Line Interface:</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9jaS5hcGFjaGUub3JnL3Byb2plY3RzL2ZsaW5rL2ZsaW5rLWRvY3MtbWFzdGVyL29wcy9jbGkuaHRtbA==" title="https://ci.apache.org/projects/flink/flink-docs-master/ops/cli.html">https://ci.apache.org/projects/flink/flink-docs-master/ops/cli.html<i class="fa fa-external-link"></i></span></p>
<p>Python REPL:</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9jaS5hcGFjaGUub3JnL3Byb2plY3RzL2ZsaW5rL2ZsaW5rLWRvY3MtbWFzdGVyL29wcy9weXRob25fc2hlbGwuaHRtbA==" title="https://ci.apache.org/projects/flink/flink-docs-master/ops/python_shell.html">https://ci.apache.org/projects/flink/flink-docs-master/ops/python_shell.html<i class="fa fa-external-link"></i></span></p>
<p>Scala REPL:</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9jaS5hcGFjaGUub3JnL3Byb2plY3RzL2ZsaW5rL2ZsaW5rLWRvY3MtbWFzdGVyL29wcy9zY2FsYV9zaGVsbC5odG1s" title="https://ci.apache.org/projects/flink/flink-docs-master/ops/scala_shell.html">https://ci.apache.org/projects/flink/flink-docs-master/ops/scala_shell.html<i class="fa fa-external-link"></i></span></p>
<p>Kerberos:</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9jaS5hcGFjaGUub3JnL3Byb2plY3RzL2ZsaW5rL2ZsaW5rLWRvY3MtbWFzdGVyL29wcy9zZWN1cml0eS1rZXJiZXJvcy5odG1s" title="https://ci.apache.org/projects/flink/flink-docs-master/ops/security-kerberos.html">https://ci.apache.org/projects/flink/flink-docs-master/ops/security-kerberos.html<i class="fa fa-external-link"></i></span></p>
<p>SSL:</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9jaS5hcGFjaGUub3JnL3Byb2plY3RzL2ZsaW5rL2ZsaW5rLWRvY3MtbWFzdGVyL29wcy9zZWN1cml0eS1zc2wuaHRtbA==" title="https://ci.apache.org/projects/flink/flink-docs-master/ops/security-ssl.html">https://ci.apache.org/projects/flink/flink-docs-master/ops/security-ssl.html<i class="fa fa-external-link"></i></span></p>
<p>Libraries 相关链接</p>
<p>Flink CEP 实战:</p>
]]></content>
      
        <categories>
            
            <category> 大数据 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Flink </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[2019_Flink社区年度文章合集]]></title>
      <url>/2019-Flink%E7%A4%BE%E5%8C%BA%E5%B9%B4%E5%BA%A6%E6%96%87%E7%AB%A0%E5%90%88%E9%9B%86.html</url>
      <content type="html"><![CDATA[<p>在过去的一年中 Apache Flink 社区官方微信公众号为小伙伴们推送了大数据及 Flink 相关活动资讯 46 篇；Apache Flink 的系列基础教程 19 篇、企业级应用实践 20+、实操系列以及实时数仓、风控、CEP 等典型应用场景及技术干货 50+。</p>
<a id="more"></a>
<h2 id="实时资讯"><a href="#实时资讯" class="headerlink" title="实时资讯"></a>实时资讯</h2><p>部分 Flink 社区实时资讯：</p>
<p>| <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYWxpeXVuLmNvbS9hcnRpY2xlLzc0MzA3MD9zcG09YTJjNmguMTI4NzM1ODEuMC4wLjQ0Njc0NjNhUDR0eWFvJmFtcDtncm91cENvZGU9c2M=" title="https://developer.aliyun.com/article/743070?spm=a2c6h.12873581.0.0.4467463aP4tyao&amp;groupCode=sc">最新消息！Cloudera 全球发行版正式集成 Apache Flink<i class="fa fa-external-link"></i></span><br>| <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYWxpeXVuLmNvbS9hcnRpY2xlLzc0Mjg3NT9zcG09YTJjNmguMTI4NzM1ODEuMC4wLjQ0Njc0NjNhUDR0eWFvJmFtcDtncm91cENvZGU9c2M=" title="https://developer.aliyun.com/article/742875?spm=a2c6h.12873581.0.0.4467463aP4tyao&amp;groupCode=sc">实至名归！Flink 再度成为 Apache 基金会最活跃的开源项目<i class="fa fa-external-link"></i></span><br>| <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYWxpeXVuLmNvbS9hcnRpY2xlLzczOTU3Mz9zcG09YTJjNmguMTI4NzM1ODEuMC4wLjQ0Njc0NjNhUDR0eWFvJmFtcDtncm91cENvZGU9c2M=" title="https://developer.aliyun.com/article/739573?spm=a2c6h.12873581.0.0.4467463aP4tyao&amp;groupCode=sc">仅 1 年 GitHub Star 数翻倍，Flink 做了什么？<i class="fa fa-external-link"></i></span><br>| <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYWxpeXVuLmNvbS9hcnRpY2xlLzc0MDg5NT9zcG09YTJjNmguMTI4NzM1ODEuMC4wLjQ0Njc0NjNhUDR0eWFvJmFtcDtncm91cENvZGU9c2M=" title="https://developer.aliyun.com/article/740895?spm=a2c6h.12873581.0.0.4467463aP4tyao&amp;groupCode=sc">年度回顾 | 2019 年的 Apache Flink<i class="fa fa-external-link"></i></span><br>| <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYWxpeXVuLmNvbS9hcnRpY2xlLzczNzc2Mj9zcG09YTJjNmguMTI4NzM1ODEuMC4wLjQ0Njc0NjNhUDR0eWFvJmFtcDtncm91cENvZGU9c2M=" title="https://developer.aliyun.com/article/737762?spm=a2c6h.12873581.0.0.4467463aP4tyao&amp;groupCode=sc">Flink Forward Asia 2019 - 总结和展望<i class="fa fa-external-link"></i></span><br>| <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYWxpeXVuLmNvbS9hcnRpY2xlLzc0Mjc3Nz9zcG09YTJjNmguMTI4NzM1ODEuMC4wLjQ0Njc0NjNhUDR0eWFvJmFtcDtncm91cENvZGU9c2M=" title="https://developer.aliyun.com/article/742777?spm=a2c6h.12873581.0.0.4467463aP4tyao&amp;groupCode=sc">Flink Weekly | 每周社区动态更新 - 20200114<i class="fa fa-external-link"></i></span><br>| <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYWxpeXVuLmNvbS9hcnRpY2xlLzc0MjMwNz9zcG09YTJjNmguMTI4NzM1ODEuMC4wLjQ0Njc0NjNhUDR0eWFvJmFtcDtncm91cENvZGU9c2M=" title="https://developer.aliyun.com/article/742307?spm=a2c6h.12873581.0.0.4467463aP4tyao&amp;groupCode=sc">Flink Weekly | 每周社区动态更新 - 20200107<i class="fa fa-external-link"></i></span><br>| <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYWxpeXVuLmNvbS9hcnRpY2xlLzc0MTYzOD9zcG09YTJjNmguMTI4NzM1ODEuMC4wLjQ0Njc0NjNhUDR0eWFvJmFtcDtncm91cENvZGU9c2M=" title="https://developer.aliyun.com/article/741638?spm=a2c6h.12873581.0.0.4467463aP4tyao&amp;groupCode=sc">Flink Weekly | 每周社区动态更新 - 20201231<i class="fa fa-external-link"></i></span><br>| <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYWxpeXVuLmNvbS9hcnRpY2xlLzc0MDQzNz9zcG09YTJjNmguMTI4NzM1ODEuMC4wLjQ0Njc0NjNhUDR0eWFvJmFtcDtncm91cENvZGU9c2M=" title="https://developer.aliyun.com/article/740437?spm=a2c6h.12873581.0.0.4467463aP4tyao&amp;groupCode=sc">Flink Weekly | 每周社区动态更新 - 20201224<i class="fa fa-external-link"></i></span></p>
<h2 id="企业实践"><a href="#企业实践" class="headerlink" title="企业实践"></a>企业实践</h2><p>企业实践部分优质内容：</p>
<p>| <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYWxpeXVuLmNvbS9hcnRpY2xlLzc0MjI4Nz9zcG09YTJjNmguMTI4NzM1ODEuMC4wLjQ0Njc0NjNhUDR0eWFvJmFtcDtncm91cENvZGU9c2M=" title="https://developer.aliyun.com/article/742287?spm=a2c6h.12873581.0.0.4467463aP4tyao&amp;groupCode=sc">小米流式平台架构演进与实践<i class="fa fa-external-link"></i></span><br>| <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYWxpeXVuLmNvbS9hcnRpY2xlLzc0MTQ2OD9zcG09YTJjNmguMTI4NzM1ODEuMC4wLjQ0Njc0NjNhUDR0eWFvJmFtcDtncm91cENvZGU9c2M=" title="https://developer.aliyun.com/article/741468?spm=a2c6h.12873581.0.0.4467463aP4tyao&amp;groupCode=sc">美团点评基于 Flink 的实时数仓平台实践<i class="fa fa-external-link"></i></span><br>| <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYWxpeXVuLmNvbS9hcnRpY2xlLzc0MTQ2NT9zcG09YTJjNmguMTI4NzM1ODEuMC4wLjQ0Njc0NjNhUDR0eWFvJmFtcDtncm91cENvZGU9c2M=" title="https://developer.aliyun.com/article/741465?spm=a2c6h.12873581.0.0.4467463aP4tyao&amp;groupCode=sc">监控指标10K+！携程实时智能检测平台实践<i class="fa fa-external-link"></i></span><br>| <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYWxpeXVuLmNvbS9hcnRpY2xlLzczOTU4MD9zcG09YTJjNmguMTI4NzM1ODEuMC4wLjQ0Njc0NjNhUDR0eWFvJmFtcDtncm91cENvZGU9c2M=" title="https://developer.aliyun.com/article/739580?spm=a2c6h.12873581.0.0.4467463aP4tyao&amp;groupCode=sc">Lyft 基于 Flink 的大规模准实时数据分析平台<i class="fa fa-external-link"></i></span><br>| <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYWxpeXVuLmNvbS9hcnRpY2xlLzczODQ1ND9zcG09YTJjNmguMTI4NzM1ODEuMC4wLjQ0Njc0NjNhUDR0eWFvJmFtcDtncm91cENvZGU9c2M=" title="https://developer.aliyun.com/article/738454?spm=a2c6h.12873581.0.0.4467463aP4tyao&amp;groupCode=sc">基于 Flink 构建 CEP 引擎的挑战和实践<i class="fa fa-external-link"></i></span><br>| <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYWxpeXVuLmNvbS9hcnRpY2xlLzcyNjYxMT9zcG09YTJjNmguMTI4NzM1ODEuMC4wLjQ0Njc0NjNhUDR0eWFvJmFtcDtncm91cENvZGU9c2M=" title="https://developer.aliyun.com/article/726611?spm=a2c6h.12873581.0.0.4467463aP4tyao&amp;groupCode=sc">趣头条基于 Flink 的实时平台建设实践<i class="fa fa-external-link"></i></span><br>| <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYWxpeXVuLmNvbS9hcnRpY2xlLzcyNzM3Mz9zcG09YTJjNmguMTI4NzM1ODEuMC4wLjQ0Njc0NjNhdlFmelNUJmFtcDtncm91cENvZGU9c2M=" title="https://developer.aliyun.com/article/727373?spm=a2c6h.12873581.0.0.4467463avQfzST&amp;groupCode=sc">Apache Flink 的迁移之路，2 年处理效果提升 5 倍<i class="fa fa-external-link"></i></span><br>| <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYWxpeXVuLmNvbS9hcnRpY2xlLzc0MDQ1ND9zcG09YTJjNmguMTI4NzM1ODEuMC4wLjQ0Njc0NjNhdlFmelNUJmFtcDtncm91cENvZGU9c2M=" title="https://developer.aliyun.com/article/740454?spm=a2c6h.12873581.0.0.4467463avQfzST&amp;groupCode=sc">日均百亿级日志处理：微博基于 Flink 的实时计算平台建设<i class="fa fa-external-link"></i></span><br>| <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYWxpeXVuLmNvbS9hcnRpY2xlLzcxNzk4OT9zcG09YTJjNmguMTI4NzM1ODEuMC4wLjQ0Njc0NjNhdlFmelNUJmFtcDtncm91cENvZGU9c2M=" title="https://developer.aliyun.com/article/717989?spm=a2c6h.12873581.0.0.4467463avQfzST&amp;groupCode=sc">Flink 在同程艺龙实时计算平台的研发与应用实践<i class="fa fa-external-link"></i></span><br>| <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYWxpeXVuLmNvbS9hcnRpY2xlLzcxNDU5Mj9zcG09YTJjNmguMTI4NzM1ODEuMC4wLjQ0Njc0NjNhdlFmelNUJmFtcDtncm91cENvZGU9c2M=" title="https://developer.aliyun.com/article/714592?spm=a2c6h.12873581.0.0.4467463avQfzST&amp;groupCode=sc">Apache Flink 在 eBay 监控系统上的实践和应用<i class="fa fa-external-link"></i></span><br>| <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYWxpeXVuLmNvbS9hcnRpY2xlLzcxMjczNj9zcG09YTJjNmguMTI4NzM1ODEuMC4wLjQ0Njc0NjNhdlFmelNUJmFtcDtncm91cENvZGU9c2M=" title="https://developer.aliyun.com/article/712736?spm=a2c6h.12873581.0.0.4467463avQfzST&amp;groupCode=sc">每天30亿条笔记展示，小红书如何实现实时高效推荐？<i class="fa fa-external-link"></i></span><br>| <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYWxpeXVuLmNvbS9hcnRpY2xlLzcxMjcxND9zcG09YTJjNmguMTI4NzM1ODEuMC4wLjQ0Njc0NjNhdlFmelNUJmFtcDtncm91cENvZGU9c2M=" title="https://developer.aliyun.com/article/712714?spm=a2c6h.12873581.0.0.4467463avQfzST&amp;groupCode=sc">58 集团大规模 Storm 任务平滑迁移至 Flink 的秘密<i class="fa fa-external-link"></i></span><br>| <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYWxpeXVuLmNvbS9hcnRpY2xlLzcyMTE3OT9zcG09YTJjNmguMTI4NzM1ODEuMC4wLjQ0Njc0NjNhdlFmelNUJmFtcDtncm91cENvZGU9c2M=" title="https://developer.aliyun.com/article/721179?spm=a2c6h.12873581.0.0.4467463avQfzST&amp;groupCode=sc">从 Storm 到 Flink，汽车之家基于 Flink 的实时 SQL 平台设计思路与实践<i class="fa fa-external-link"></i></span><br>| <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYWxpeXVuLmNvbS9hcnRpY2xlLzcxMjQzNj9zcG09YTJjNmguMTI4NzM1ODEuMC4wLjQ0Njc0NjNhdlFmelNUJmFtcDtncm91cENvZGU9c2M=" title="https://developer.aliyun.com/article/712436?spm=a2c6h.12873581.0.0.4467463avQfzST&amp;groupCode=sc">日均处理万亿数据！Apache Flink在快手的应用实践与技术演进之路<i class="fa fa-external-link"></i></span></p>
<h2 id="系列基础教程"><a href="#系列基础教程" class="headerlink" title="系列基础教程"></a>系列基础教程</h2><p>Apache Flink 零基础入门教程：</p>
<p><strong>▼ 进阶篇 ▼</strong></p>
<p>|<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYWxpeXVuLmNvbS9hcnRpY2xlLzcxMjcwMT9zcG09YTJjNmguMTI4NzM1ODEuMC4wLjQ0Njc0NjNhdlFmelNUJmFtcDtncm91cENvZGU9c2M=" title="https://developer.aliyun.com/article/712701?spm=a2c6h.12873581.0.0.4467463avQfzST&amp;groupCode=sc">Flink 基础概念解析<i class="fa fa-external-link"></i></span><br>|<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYWxpeXVuLmNvbS9hcnRpY2xlLzcxMjcwMj9zcG09YTJjNmguMTI4NzM1ODEuMC4wLjQ0Njc0NjNhdlFmelNUJmFtcDtncm91cENvZGU9c2M=" title="https://developer.aliyun.com/article/712702?spm=a2c6h.12873581.0.0.4467463avQfzST&amp;groupCode=sc">Flink 开发环境搭建和应用的配置、部署及运行<i class="fa fa-external-link"></i></span><br>|<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYWxpeXVuLmNvbS9hcnRpY2xlLzcxMjcwMz9zcG09YTJjNmguMTI4NzM1ODEuMC4wLjQ0Njc0NjNhdlFmelNUJmFtcDtncm91cENvZGU9c2M=" title="https://developer.aliyun.com/article/712703?spm=a2c6h.12873581.0.0.4467463avQfzST&amp;groupCode=sc">Flink Datastream API 编程<i class="fa fa-external-link"></i></span><br>|<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYWxpeXVuLmNvbS9hcnRpY2xlLzcxMjcwND9zcG09YTJjNmguMTI4NzM1ODEuMC4wLjQ0Njc0NjNhdlFmelNUJmFtcDtncm91cENvZGU9c2M=" title="https://developer.aliyun.com/article/712704?spm=a2c6h.12873581.0.0.4467463avQfzST&amp;groupCode=sc">Flink 客户端操作<i class="fa fa-external-link"></i></span><br>|<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYWxpeXVuLmNvbS9hcnRpY2xlLzcxMjcwOD9zcG09YTJjNmguMTI4NzM1ODEuMC4wLjQ0Njc0NjNhdlFmelNUJmFtcDtncm91cENvZGU9c2M=" title="https://developer.aliyun.com/article/712708?spm=a2c6h.12873581.0.0.4467463avQfzST&amp;groupCode=sc">Flink Time &amp; Window<i class="fa fa-external-link"></i></span><br>|<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYWxpeXVuLmNvbS9hcnRpY2xlLzcxMjcxMT9zcG09YTJjNmguMTI4NzM1ODEuMC4wLjQ0Njc0NjNhdlFmelNUJmFtcDtncm91cENvZGU9c2M=" title="https://developer.aliyun.com/article/712711?spm=a2c6h.12873581.0.0.4467463avQfzST&amp;groupCode=sc">Flink 状态管理及容错机制<i class="fa fa-external-link"></i></span><br>|<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYWxpeXVuLmNvbS9hcnRpY2xlLzcxNjgyMj9zcG09YTJjNmguMTI4NzM1ODEuMC4wLjQ0Njc0NjNhdlFmelNUJmFtcDtncm91cENvZGU9c2M=" title="https://developer.aliyun.com/article/716822?spm=a2c6h.12873581.0.0.4467463avQfzST&amp;groupCode=sc">Flink Table API 编程<i class="fa fa-external-link"></i></span><br>|<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYWxpeXVuLmNvbS9hcnRpY2xlLzcxNTEzNz9zcG09YTJjNmguMTI4NzM1ODEuMC4wLjQ0Njc0NjNhdlFmelNUJmFtcDtncm91cENvZGU9c2M=" title="https://developer.aliyun.com/article/715137?spm=a2c6h.12873581.0.0.4467463avQfzST&amp;groupCode=sc">Flink SQL 编程实践<i class="fa fa-external-link"></i></span><br>|<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYWxpeXVuLmNvbS9hcnRpY2xlLzcxNzgzMz9zcG09YTJjNmguMTI4NzM1ODEuMC4wLjQ0Njc0NjNhdlFmelNUJmFtcDtncm91cENvZGU9c2M=" title="https://developer.aliyun.com/article/717833?spm=a2c6h.12873581.0.0.4467463avQfzST&amp;groupCode=sc">Runtime 核心机制剖析<i class="fa fa-external-link"></i></span><br>|<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYWxpeXVuLmNvbS9hcnRpY2xlLzcxOTI0Mj9zcG09YTJjNmguMTI4NzM1ODEuMC4wLjQ0Njc0NjNhdlFmelNUJmFtcDtncm91cENvZGU9c2M=" title="https://developer.aliyun.com/article/719242?spm=a2c6h.12873581.0.0.4467463avQfzST&amp;groupCode=sc">Checkpoint 原理剖析与应用实践<i class="fa fa-external-link"></i></span></p>
<h2 id="技术干货"><a href="#技术干货" class="headerlink" title="技术干货"></a>技术干货</h2><p>部分技术干货文章节选:</p>
<p>| <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYWxpeXVuLmNvbS9hcnRpY2xlLzczODQ1ND9zcG09YTJjNmguMTI4NzM1ODEuMC4wLjQ0Njc0NjNhdlFmelNUJmFtcDtncm91cENvZGU9c2M=" title="https://developer.aliyun.com/article/738454?spm=a2c6h.12873581.0.0.4467463avQfzST&amp;groupCode=sc">Apache Flink CEP 实战<i class="fa fa-external-link"></i></span><br>| <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYWxpeXVuLmNvbS9hcnRpY2xlLzczOTAwNj9zcG09YTJjNmguMTI4NzM1ODEuMC4wLjQ0Njc0NjNhdlFmelNUJmFtcDtncm91cENvZGU9c2M=" title="https://developer.aliyun.com/article/739006?spm=a2c6h.12873581.0.0.4467463avQfzST&amp;groupCode=sc">Flink Batch SQL 1.10 实践<i class="fa fa-external-link"></i></span><br>| <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYWxpeXVuLmNvbS9hcnRpY2xlLzcyNjczOD9zcG09YTJjNmguMTI4NzM1ODEuMC4wLjQ0Njc0NjNhdlFmelNUJmFtcDtncm91cENvZGU9c2M=" title="https://developer.aliyun.com/article/726738?spm=a2c6h.12873581.0.0.4467463avQfzST&amp;groupCode=sc">Flink State 有可能代替数据库吗？<i class="fa fa-external-link"></i></span><br>| <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYWxpeXVuLmNvbS9hcnRpY2xlLzczOTc5Mz9zcG09YTJjNmguMTI4NzM1ODEuMC4wLjQ0Njc0NjNhdlFmelNUJmFtcDtncm91cENvZGU9c2M=" title="https://developer.aliyun.com/article/739793?spm=a2c6h.12873581.0.0.4467463avQfzST&amp;groupCode=sc">Flink SQL 如何实现数据流的 Join？<i class="fa fa-external-link"></i></span><br>| <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYWxpeXVuLmNvbS9hcnRpY2xlLzcxODgxNz9zcG09YTJjNmguMTI4NzM1ODEuMC4wLjQ0Njc0NjNhdlFmelNUJmFtcDtncm91cENvZGU9c2M=" title="https://developer.aliyun.com/article/718817?spm=a2c6h.12873581.0.0.4467463avQfzST&amp;groupCode=sc">Flink SQL 系列 | 开篇，新架构与 Planner<i class="fa fa-external-link"></i></span><br>| <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYWxpeXVuLmNvbS9hcnRpY2xlLzcxNjExMD9zcG09YTJjNmguMTI4NzM1ODEuMC4wLjQ0Njc0NjNhdlFmelNUJmFtcDtncm91cENvZGU9c2M=" title="https://developer.aliyun.com/article/716110?spm=a2c6h.12873581.0.0.4467463avQfzST&amp;groupCode=sc">如何在 Flink 1.9 中使用 Hive？<i class="fa fa-external-link"></i></span><br>| <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYWxpeXVuLmNvbS9hcnRpY2xlLzcxMjQzMT9zcG09YTJjNmguMTI4NzM1ODEuMC4wLjQ0Njc0NjNhdlFmelNUJmFtcDtncm91cENvZGU9c2M=" title="https://developer.aliyun.com/article/712431?spm=a2c6h.12873581.0.0.4467463avQfzST&amp;groupCode=sc">Apache Flink 1.9.0 为什么将支持 Python API ？<i class="fa fa-external-link"></i></span><br>| <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYWxpeXVuLmNvbS9hcnRpY2xlLzczODg4ND9zcG09YTJjNmguMTI4NzM1ODEuMC4wLjQ0Njc0NjNhdlFmelNUJmFtcDtncm91cENvZGU9c2M=" title="https://developer.aliyun.com/article/738884?spm=a2c6h.12873581.0.0.4467463avQfzST&amp;groupCode=sc">在 Cloudera Data Flow 上运行你的第一个 Flink 例子<i class="fa fa-external-link"></i></span><br>| <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYWxpeXVuLmNvbS9hcnRpY2xlLzcxOTI2Mj9zcG09YTJjNmguMTI4NzM1ODEuMC4wLjQ0Njc0NjNhdlFmelNUJmFtcDtncm91cENvZGU9c2M=" title="https://developer.aliyun.com/article/719262?spm=a2c6h.12873581.0.0.4467463avQfzST&amp;groupCode=sc">Flink on YARN（上）：一张图轻松掌握基础架构与启动流程<i class="fa fa-external-link"></i></span><br>| <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYWxpeXVuLmNvbS9hcnRpY2xlLzcxOTcwMz9zcG09YTJjNmguMTI4NzM1ODEuMC4wLjQ0Njc0NjNhdlFmelNUJmFtcDtncm91cENvZGU9c2M=" title="https://developer.aliyun.com/article/719703?spm=a2c6h.12873581.0.0.4467463avQfzST&amp;groupCode=sc">Flink on YARN（下）：常见问题与排查思路<i class="fa fa-external-link"></i></span><br>| <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYWxpeXVuLmNvbS9hcnRpY2xlLzcxNTkyNT9zcG09YTJjNmguMTI4NzM1ODEuMC4wLjQ0Njc0NjNhdlFmelNUJmFtcDtncm91cENvZGU9c2M=" title="https://developer.aliyun.com/article/715925?spm=a2c6h.12873581.0.0.4467463avQfzST&amp;groupCode=sc">修改代码150万行！Apache Flink 1.9.0做了这些重大修改！<i class="fa fa-external-link"></i></span><br>| <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYWxpeXVuLmNvbS9hcnRpY2xlLzc0NDQ4NT9zcG09YTJjNmguMTQxNjQ4OTYuMC4wLjQ4MTg0MDk2cVVleWVOIw==" title="https://developer.aliyun.com/article/744485?spm=a2c6h.14164896.0.0.48184096qUeyeN#">如何在 PyFlink 1.10 中自定义 Python UDF？<i class="fa fa-external-link"></i></span></p>
]]></content>
      
        <categories>
            
            <category> 大数据 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Flink </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[正则表达式学习]]></title>
      <url>/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0.html</url>
      <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmrx9asrcuj30rg0fuq5u.jpg" alt="img"></p>
<a id="more"></a>
<p>正则表达式在几乎所有语言中都可以使用，无论是前端的JavaScript、还是后端的Java、c#。他们都提供相应的接口/函数支持正则表达式。</p>
<p>但很神奇的是：<strong><em>无论你大学选择哪一门计算机语言，都没有关于正则表达式的课程给你修，在你学会正则之前，你只能看着那些正则大师们，写了一串外星文似的字符串，替代了你用一大篇幅的if else代码来做一些数据校验</em></strong>。</p>
<p>既然喜欢，那就动手学呗，可当你百度出一一堆相关资料时，你发现无一不例外的枯燥至极，难以学习。</p>
<p>本文旨在用最通俗的语言讲述最枯燥的基本知识！</p>
<h2 id="正则基础知识点："><a href="#正则基础知识点：" class="headerlink" title="正则基础知识点："></a><strong>正则基础知识点：</strong></h2><h3 id="1-元字符"><a href="#1-元字符" class="headerlink" title="1.元字符"></a><strong>1.元字符</strong></h3><p>万物皆有缘，正则也是如此，元字符是构造正则表达式的一种基本元素。<br>我们先来记几个常用的元字符：</p>
<p><img src="https://pic2.zhimg.com/50/v2-4cb7311c65df765b3b0af137e53375eb_hd.jpg?source=1940ef5c" alt="img"><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmrx8s4dyij30h008tgm5.jpg" alt="img"></p>
<p>有了元字符之后，我们就可以利用这些元字符来写一些简单的正则表达式了，<br>比如：</p>
<ol>
<li>匹配有abc开头的字符串：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>   \babc或者^abc</span><br></pre></td></tr></table></figure>
<p>\2. 匹配8位数字的QQ号码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>   ^\d\d\d\d\d\d\d\d$</span><br></pre></td></tr></table></figure>
<p>\3. 匹配1开头11位数字的手机号码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>   ^<span class="number">1</span>\d\d\d\d\d\d\d\d\d\d$</span><br></pre></td></tr></table></figure>
<h3 id="2-重复限定符"><a href="#2-重复限定符" class="headerlink" title="2. 重复限定符"></a><strong>2. 重复限定符</strong></h3><p>有了元字符就可以写不少的正则表达式了，但细心的你们可能会发现：别人写的正则简洁明了，而不理君写的正则一堆乱七八糟而且重复的元字符组成的。正则没提供办法处理这些重复的元字符吗？</p>
<p>答案是有的！<br>为了处理这些重复问题，正则表达式中一些重复限定符，把重复部分用合适的限定符替代，下面我们来看一些限定符：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmrx8owvb1j30h007p0t3.jpg" alt="img"><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmrx8n0nlpj30h007p0t3.jpg" alt="img"></p>
<p>有了这些限定符之后，我们就可以对之前的正则表达式进行改造了，比如：</p>
<p>\1. 匹配8位数字的QQ号码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>   ^\d&#123;<span class="number">8</span>&#125;$</span><br></pre></td></tr></table></figure>
<p>\2. 匹配1开头11位数字的手机号码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>   ^<span class="number">1</span>\d&#123;<span class="number">10</span>&#125;$</span><br></pre></td></tr></table></figure>
<p>\3. 匹配银行卡号是14~18位的数字：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>   ^\d&#123;<span class="number">14</span>,<span class="number">18</span>&#125;$</span><br></pre></td></tr></table></figure>
<p>\4. 匹配以a开头的，0个或多个b结尾的字符串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>   ^ab*$</span><br></pre></td></tr></table></figure>
<h3 id="3-分组"><a href="#3-分组" class="headerlink" title="3. 分组"></a><strong>3. 分组</strong></h3><p>从上面的例子（4）中看到，<em>限定符是作用在与他左边最近的一个字符，那么问题来了，如果我想要ab同时被</em>限定那怎么办呢？</p>
<blockquote>
<p>正则表达式中用小括号()来做分组，也就是括号中的内容作为一个整体。</p>
</blockquote>
<p>因此当我们要匹配多个ab时，我们可以这样<br>如：匹配字符串中包含0到多个ab开头：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>   ^(ab)*</span><br></pre></td></tr></table></figure>
<h3 id="4-转义"><a href="#4-转义" class="headerlink" title="4. 转义"></a><strong>4. 转义</strong></h3><p>我们看到正则表达式用小括号来做分组，那么问题来了：</p>
<blockquote>
<p>如果要匹配的字符串中本身就包含小括号，那是不是冲突？应该怎么办？</p>
</blockquote>
<p>针对这种情况，正则提供了转义的方式，也就是要把这些元字符、限定符或者关键字转义成普通的字符，做法很简答，就是在要转义的字符前面加个斜杠，也就是\即可。<br>如：要匹配以(ab)开头：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>   ^(\(ab\))*</span><br></pre></td></tr></table></figure>
<h3 id="5-条件或"><a href="#5-条件或" class="headerlink" title="5. 条件或"></a><strong>5. 条件或</strong></h3><p>回到我们刚才的手机号匹配，我们都知道：国内号码都来自三大网，它们都有属于自己的号段，比如联通有130/131/132/155/156/185/186/145/176等号段，假如让我们匹配一个联通的号码，那按照我们目前所学到的正则，应该无从下手的，因为这里包含了一些并列的条件，也就是“或”，那么在正则中是如何表示“或”的呢？</p>
<blockquote>
<p>正则用符号 | 来表示或，也叫做分支条件，当满足正则里的分支条件的任何一种条件时，都会当成是匹配成功。</p>
</blockquote>
<p>那么我们就可以用或条件来处理这个问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>   ^(<span class="number">130</span>|<span class="number">131</span>|<span class="number">132</span>|<span class="number">155</span>|<span class="number">156</span>|<span class="number">185</span>|<span class="number">186</span>|<span class="number">145</span>|<span class="number">176</span>)\d&#123;<span class="number">8</span>&#125;$</span><br></pre></td></tr></table></figure>
<h3 id="6-区间"><a href="#6-区间" class="headerlink" title="6. 区间"></a><strong>6. 区间</strong></h3><p>看到上面的例子，是不是看到有什么规律？是不是还有一种想要简化的冲动？<br>实际是有的</p>
<blockquote>
<p>正则提供一个元字符中括号 [] 来表示区间条件。</p>
</blockquote>
<ol>
<li>限定0到9 可以写成[0-9]</li>
<li>限定A-Z 写成[A-Z]</li>
<li>限定某些数字 [165]</li>
</ol>
<p>那上面的正则我们还改成这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>   ^((<span class="number">13</span>[<span class="number">0</span>-<span class="number">2</span>])|(<span class="number">15</span>[<span class="number">56</span>])|(<span class="number">18</span>[<span class="number">5</span>-<span class="number">6</span>])|<span class="number">145</span>|<span class="number">176</span>)\d&#123;<span class="number">8</span>&#125;$</span><br></pre></td></tr></table></figure>
<p>好了，正则表达式的基本用法就讲到这里了，其实它还有非常多的知识点以及元字符，我们在此只列举了部分元字符和语法来讲，旨在给那些不懂正则或者想学正则但有看不下去文档的人做一个快速入门级的教程，看完本教程，即使你不能写出高大上的正则，至少也能写一些简单的正则或者看得懂别人写的正则了。</p>
<h2 id="正则进阶知识点："><a href="#正则进阶知识点：" class="headerlink" title="正则进阶知识点："></a><strong>正则进阶知识点：</strong></h2><h3 id="1-零宽断言"><a href="#1-零宽断言" class="headerlink" title="1. 零宽断言"></a><strong>1. 零宽断言</strong></h3><blockquote>
<p>无论是零宽还是断言，听起来都古古怪怪的，<br>那先解释一下这两个词。</p>
</blockquote>
<ol>
<li>断言：俗话的断言就是“我断定什么什么”，而正则中的断言，就是说正则可以指明在指定的内容的前面或后面会出现满足指定规则的内容，<br>意思正则也可以像人类那样断定什么什么，比如”ss1aa2bb3”,正则可以用断言找出aa2前面有bb3，也可以找出aa2后面有ss1.</li>
<li>零宽：就是没有宽度，在正则中，断言只是匹配位置，不占字符，也就是说，匹配结果里是不会返回断言本身。</li>
</ol>
<p>意思是讲明白了，那他有什么用呢？<br>我们来举个栗子：<br>假设我们要用爬虫抓取csdn里的文章阅读量。通过查看源代码可以看到文章阅读量这个内容是这样的结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1   &quot;&lt;span class=&quot;read-count&quot;&gt;阅读数：641&lt;/span&gt;&quot;</span><br></pre></td></tr></table></figure>
<p>其中也就‘641’这个是变量，也就是说不同文章不同的值，当我们拿到这个字符串时，需要获得这里边的‘641’有很多种办法，但如果正则应该怎么匹配呢？</p>
<p>下面先来讲几种类型的断言：</p>
<ol>
<li>正向先行断言（正前瞻）：</li>
</ol>
<ul>
<li>语法：（?=pattern）</li>
<li>作用：匹配pattern表达式的前面内容，不返回本身。</li>
</ul>
<p>这样子说，还是一脸懵逼，好吧，回归刚才那个栗子，要取到阅读量，在正则表达式中就意味着要能匹配到‘’前面的数字内容<br>按照上所说的正向先行断言可以匹配表达式前面的内容，那意思就是:(?=) 就可以匹配到前面的内容了。<br>匹配什么内容呢？如果要所有内容那就是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>   String reg=<span class="string">".+(?=&lt;/span&gt;)"</span>;</span><br><span class="line"> <span class="number">2</span></span><br><span class="line"> <span class="number">3</span>   String test = <span class="string">"&lt;span class=\"read-count\"&gt;阅读数：641&lt;/span&gt;"</span>;</span><br><span class="line"> <span class="number">4</span>   Pattern pattern = Pattern.compile(reg);</span><br><span class="line"> <span class="number">5</span>   Matcher mc=    pattern.matcher(test);</span><br><span class="line"> <span class="number">6</span>   <span class="keyword">while</span>(mc.find())&#123;</span><br><span class="line"> <span class="number">7</span>    System.out.println(<span class="string">"匹配结果："</span>)</span><br><span class="line"> <span class="number">8</span>    System.out.println(mc.group());</span><br><span class="line"> <span class="number">9</span>   &#125;</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">11</span>   <span class="comment">//匹配结果：</span></span><br><span class="line"><span class="number">12</span>   <span class="comment">//&lt;span class="read-count"&gt;阅读数：641</span></span><br></pre></td></tr></table></figure>
<p>可是老哥我们要的只是前面的数字呀，那也简单咯，匹配数字 \d,那可以改成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>   String reg=<span class="string">"\\d+(?=&lt;/span&gt;)"</span>;</span><br><span class="line"><span class="number">2</span>   String test = <span class="string">"&lt;span class=\"read-count\"&gt;阅读数：641&lt;/span&gt;"</span>;</span><br><span class="line"><span class="number">3</span>   Pattern pattern = Pattern.compile(reg);</span><br><span class="line"><span class="number">4</span>   Matcher mc=    pattern.matcher(test);</span><br><span class="line"><span class="number">5</span>   <span class="keyword">while</span>(mc.find())&#123;</span><br><span class="line"><span class="number">6</span>     System.out.println(mc.group());</span><br><span class="line"><span class="number">7</span>   &#125;</span><br><span class="line"><span class="number">8</span>   <span class="comment">//匹配结果：</span></span><br><span class="line"><span class="number">9</span>   <span class="comment">//641</span></span><br></pre></td></tr></table></figure>
<p>大功告成！</p>
<p>\2. 正向后行断言（正后顾）:</p>
<ul>
<li>语法：（?&lt;=pattern）</li>
<li>作用：匹配pattern表达式的后面的内容，不返回本身。</li>
</ul>
<p>有先行就有后行，先行是匹配前面的内容，那后行就是匹配后面的内容啦。<br>上面的栗子，我们也可以用后行断言来处理.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>   <span class="comment">//(?&lt;=&lt;span class="read-count"&gt;阅读数：)\d+</span></span><br><span class="line"> <span class="number">2</span>   String reg=<span class="string">"(?&lt;=&lt;span class=\"read-count\"&gt;阅读数：)\\d+"</span>;</span><br><span class="line"> <span class="number">3</span></span><br><span class="line"> <span class="number">4</span>   String test = <span class="string">"&lt;span class=\"read-count\"&gt;阅读数：641&lt;/span&gt;"</span>;</span><br><span class="line"> <span class="number">5</span>   Pattern pattern = Pattern.compile(reg);</span><br><span class="line"> <span class="number">6</span>   Matcher mc=    pattern.matcher(test);</span><br><span class="line"> <span class="number">7</span>        <span class="keyword">while</span>(mc.find())&#123;</span><br><span class="line"> <span class="number">8</span>          System.out.println(mc.group());</span><br><span class="line"> <span class="number">9</span>        &#125;</span><br><span class="line"><span class="number">10</span>   <span class="comment">//匹配结果：</span></span><br><span class="line"><span class="number">11</span>   <span class="comment">//641</span></span><br></pre></td></tr></table></figure>
<p>就这么简单。</p>
<p>\3. 负向先行断言（负前瞻）</p>
<ul>
<li>语法：(?!pattern)</li>
<li>作用：匹配非pattern表达式的前面内容，不返回本身。</li>
</ul>
<p>有正向也有负向，负向在这里其实就是非的意思。<br>举个栗子：比如有一句 “我爱祖国，我是祖国的花朵”<br>现在要找到不是’的花朵’前面的祖国<br>用正则就可以这样写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>   祖国(?!的花朵)</span><br></pre></td></tr></table></figure>
<p>\4. 负向后行断言（负后顾）</p>
<ul>
<li>语法：(?&lt;!pattern)</li>
<li>作用：匹配非pattern表达式的后面内容，不返回本身。</li>
</ul>
<h3 id="2-捕获和非捕获"><a href="#2-捕获和非捕获" class="headerlink" title="2. 捕获和非捕获"></a><strong>2. 捕获和非捕获</strong></h3><p>单纯说到捕获，他的意思是匹配表达式，但捕获通常和分组联系在一起，也就是“捕获组”</p>
<blockquote>
<p>捕获组：匹配子表达式的内容，把匹配结果保存到内存中中数字编号或显示命名的组里，以深度优先进行编号，之后可以通过序号或名称来使用这些匹配结果。</p>
</blockquote>
<p>而根据命名方式的不同，又可以分为两种组：</p>
<p>\1. 数字编号捕获组：<br>语法：(exp)<br>解释：从表达式左侧开始，每出现一个左括号和它对应的右括号之间的内容为一个分组，在分组中，第0组为整个表达式，第一组开始为分组。<br>比如固定电话的：020-85653333<br>他的正则表达式为：(0\d{2})-(\d{8})<br>按照左括号的顺序，这个表达式有如下分组：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmrx8gjeffj30h204hq34.jpg" alt="img"><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmrx8e2aizj30h204hq34.jpg" alt="img"></p>
<p>我们用Java来验证一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>   String test = <span class="string">"020-85653333"</span>;</span><br><span class="line"> <span class="number">2</span>        String reg=<span class="string">"(0\\d&#123;2&#125;)-(\\d&#123;8&#125;)"</span>;</span><br><span class="line"> <span class="number">3</span>        Pattern pattern = Pattern.compile(reg);</span><br><span class="line"> <span class="number">4</span>        Matcher mc= pattern.matcher(test);</span><br><span class="line"> <span class="number">5</span>        <span class="keyword">if</span>(mc.find())&#123;</span><br><span class="line"> <span class="number">6</span>          System.out.println(<span class="string">"分组的个数有："</span>+mc.groupCount());</span><br><span class="line"> <span class="number">7</span>            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=mc.groupCount();i++)&#123;</span><br><span class="line"> <span class="number">8</span>                System.out.println(<span class="string">"第"</span>+i+<span class="string">"个分组为："</span>+mc.group(i));</span><br><span class="line"> <span class="number">9</span>            &#125;</span><br><span class="line"><span class="number">10</span>        &#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>   分组的个数有：<span class="number">2</span></span><br><span class="line"><span class="number">2</span>   第<span class="number">0</span>个分组为：<span class="number">020</span>-<span class="number">85653333</span></span><br><span class="line"><span class="number">3</span>   第<span class="number">1</span>个分组为：<span class="number">020</span></span><br><span class="line"><span class="number">4</span>   第<span class="number">2</span>个分组为：<span class="number">85653333</span></span><br></pre></td></tr></table></figure>
<p>可见，分组个数是2，但是因为第0个为整个表达式本身，因此也一起输出了。</p>
<p>\2. 命名编号捕获组：<br>语法：(?<name>exp)<br>解释：分组的命名由表达式中的name指定<br>比如区号也可以这样写:(?<quhao>\0\d{2})-(?<haoma>\d{8})<br>按照左括号的顺序，这个表达式有如下分组：</haoma></quhao></name></p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmrx87gv3vj30gz04fjrm.jpg" alt="img"><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmrx85mxkrj30gz04fjrm.jpg" alt="img"></p>
<p>用代码来验证一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>   String test = <span class="string">"020-85653333"</span>;</span><br><span class="line"><span class="number">2</span>        String reg=<span class="string">"(?&lt;quhao&gt;0\\d&#123;2&#125;)-(?&lt;haoma&gt;\\d&#123;8&#125;)"</span>;</span><br><span class="line"><span class="number">3</span>        Pattern pattern = Pattern.compile(reg);</span><br><span class="line"><span class="number">4</span>        Matcher mc= pattern.matcher(test);</span><br><span class="line"><span class="number">5</span>        <span class="keyword">if</span>(mc.find())&#123;</span><br><span class="line"><span class="number">6</span>            System.out.println(<span class="string">"分组的个数有："</span>+mc.groupCount());</span><br><span class="line"><span class="number">7</span>            System.out.println(mc.group(<span class="string">"quhao"</span>));</span><br><span class="line"><span class="number">8</span>            System.out.println(mc.group(<span class="string">"haoma"</span>));</span><br><span class="line"><span class="number">9</span>        &#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>   分组的个数有：<span class="number">2</span></span><br><span class="line"><span class="number">2</span>   分组名称为:quhao,匹配内容为：<span class="number">020</span></span><br><span class="line"><span class="number">3</span>   分组名称为:haoma,匹配内容为：<span class="number">85653333</span></span><br></pre></td></tr></table></figure>
<p>\3. 非捕获组：<br>语法：(?:exp)<br>解释：和捕获组刚好相反，它用来标识那些不需要捕获的分组，说的通俗一点，就是你可以根据需要去保存你的分组。</p>
<p>比如上面的正则表达式，程序不需要用到第一个分组，那就可以这样写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>   (?:\<span class="number">0</span>\d&#123;<span class="number">2</span>&#125;)-(\d&#123;<span class="number">8</span>&#125;)</span><br></pre></td></tr></table></figure>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmrx80kguhj30gy039aa5.jpg" alt="img"><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmrx82sg21j30gy039aa5.jpg" alt="img"></p>
<p>验证一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>   String test = <span class="string">"020-85653333"</span>;</span><br><span class="line"> <span class="number">2</span>        String reg=<span class="string">"(?:0\\d&#123;2&#125;)-(\\d&#123;8&#125;)"</span>;</span><br><span class="line"> <span class="number">3</span>        Pattern pattern = Pattern.compile(reg);</span><br><span class="line"> <span class="number">4</span>        Matcher mc= pattern.matcher(test);</span><br><span class="line"> <span class="number">5</span>        <span class="keyword">if</span>(mc.find())&#123;</span><br><span class="line"> <span class="number">6</span>                System.out.println(<span class="string">"分组的个数有："</span>+mc.groupCount());</span><br><span class="line"> <span class="number">7</span>                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=mc.groupCount();i++)&#123;</span><br><span class="line"> <span class="number">8</span>                    System.out.println(<span class="string">"第"</span>+i+<span class="string">"个分组为："</span>+mc.group(i));</span><br><span class="line"> <span class="number">9</span>                &#125;</span><br><span class="line"><span class="number">10</span>        &#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>   分组的个数有：<span class="number">1</span></span><br><span class="line"><span class="number">2</span>   第<span class="number">0</span>个分组为：<span class="number">020</span>-<span class="number">85653333</span></span><br><span class="line"><span class="number">3</span>   第<span class="number">1</span>个分组为：<span class="number">85653333</span></span><br></pre></td></tr></table></figure>
<h3 id="3-反向引用"><a href="#3-反向引用" class="headerlink" title="3. 反向引用"></a><strong>3. 反向引用</strong></h3><p>上面讲到捕获，我们知道：<strong><em>捕获会返回一个捕获组，这个分组是保存在内存中，不仅可以在正则表达式外部通过程序进行引用，也可以在正则表达式内部进行引用，这种引用方式就是反向引用</em></strong>。</p>
<p>根据捕获组的命名规则，反向引用可分为：</p>
<ol>
<li>数字编号组反向引用：\k<br>或\number</li>
<li>命名编号组反向引用：\k<br>或者\’name’</li>
</ol>
<p>好了 讲完了，懂吗？不懂！！！<br>可能连前面讲的捕获有什么用都还不懂吧？<br>其实只是看完捕获不懂不会用是很正常的！<br>因为捕获组通常是和反向引用一起使用的</p>
<p>上面说到捕获组是匹配子表达式的内容按序号或者命名保存起来以便使用<br>注意两个字眼：“内容” 和 “使用”<br>这里所说的“内容”，是匹配结果，而不是子表达式本身，强调这个有什么用？嗯，先记住<br>那这里所说的“使用”是怎样使用呢？</p>
<p>因为它的作用主要是用来查找一些重复的内容或者做替换指定字符。</p>
<p>还是举栗子吧：<br>比如要查找一串字母”aabbbbgbddesddfiid”里成对的字母<br>如果按照我们之前学到的正则，什么区间啊限定啊断言啊可能是办不到的，<br>现在我们先用程序思维理一下思路：</p>
<ul>
<li>1）匹配到一个字母</li>
<li>2）匹配第下一个字母，检查是否和上一个字母是否一样</li>
<li>3）如果一样，则匹配成功，否则失败</li>
</ul>
<p>这里的思路2中匹配下一个字母时，需要用到上一个字母，那怎么记住上一个字母呢？？？<br>这下子捕获就有用处啦，我们可以利用捕获把上一个匹配成功的内容用来作为本次匹配的条件<br>好了，有思路就要实践<br>首先匹配一个字母：\w<br>我们需要做成分组才能捕获，因此写成这样：(\w)</p>
<p>那这个表达式就有一个捕获组：（\w）<br>然后我们要用这个捕获组作为条件，那就可以：(\w)\1<br>这样就大功告成了<br>可能有人不明白了，\1是什么意思呢？<br>还记得捕获组有两种命名方式吗，<strong>一种是是根据捕获分组顺序命名，一种是自定义命名来作为捕获组的命名</strong><br><strong><em>在默认情况下都是以数字来命名，而且数字命名的顺序是从1开始的\</em></strong><br>因此要引用第一个捕获组，根据反向引用的数字命名规则 就需要 \k<1>或者\1<br>当然，通常都是是后者。<br>我们来测试一下：</1></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>   String test = <span class="string">"aabbbbgbddesddfiid"</span>;</span><br><span class="line"><span class="number">2</span>        Pattern pattern = Pattern.compile(<span class="string">"(\\w)\\1"</span>);</span><br><span class="line"><span class="number">3</span>        Matcher mc= pattern.matcher(test);</span><br><span class="line"><span class="number">4</span>        <span class="keyword">while</span>(mc.find())&#123;</span><br><span class="line"><span class="number">5</span>            System.out.println(mc.group());</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span>        &#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>   aa</span><br><span class="line"><span class="number">2</span>   bb</span><br><span class="line"><span class="number">3</span>   bb</span><br><span class="line"><span class="number">4</span>   dd</span><br><span class="line"><span class="number">5</span>   dd</span><br><span class="line"><span class="number">6</span>   ii</span><br></pre></td></tr></table></figure>
<p>嗯，这就是我们想要的了。</p>
<p>在举个替换的例子，假如想要把字符串中abc换成a</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>   String test = <span class="string">"abcbbabcbcgbddesddfiid"</span>;</span><br><span class="line"><span class="number">2</span>   String reg=<span class="string">"(a)(b)c"</span>;</span><br><span class="line"><span class="number">3</span>   System.out.println(test.replaceAll(reg, <span class="string">"$1"</span>));;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>   abbabcgbddesddfiid</span><br></pre></td></tr></table></figure>
<h3 id="4-贪婪和非贪婪"><a href="#4-贪婪和非贪婪" class="headerlink" title="4. 贪婪和非贪婪"></a><strong>4. 贪婪和非贪婪</strong></h3><p><strong>1.贪婪</strong></p>
<p>我们都知道，贪婪就是不满足，尽可能多的要。<br>在正则中，贪婪也是差不多的意思:</p>
<blockquote>
<p>贪婪匹配：当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符，这匹配方式叫做贪婪匹配。<br>特性：一次性读入整个字符串进行匹配，每当不匹配就舍弃最右边一个字符，继续匹配，依次匹配和舍弃（这种匹配-舍弃的方式也叫做回溯），直到匹配成功或者把整个字符串舍弃完为止，因此它是一种最大化的数据返回，能多不会少。</p>
</blockquote>
<p>前面我们讲过重复限定符，其实这些限定符就是贪婪量词，比如表达式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>   \d&#123;<span class="number">3</span>,<span class="number">6</span>&#125;</span><br></pre></td></tr></table></figure>
<p>用来匹配3到6位数字，在这种情况下，它是一种贪婪模式的匹配，也就是假如字符串里有6个个数字可以匹配，那它就是全部匹配到。<br>如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>   String reg=<span class="string">"\\d&#123;3,6&#125;"</span>;        </span><br><span class="line"><span class="number">2</span>   String test=<span class="string">"61762828 176 2991 871"</span>;</span><br><span class="line"><span class="number">3</span>   System.out.println(<span class="string">"文本："</span>+test);</span><br><span class="line"><span class="number">4</span>   System.out.println(<span class="string">"贪婪模式："</span>+reg);</span><br><span class="line"><span class="number">5</span>   Pattern p1 =Pattern.compile(reg);</span><br><span class="line"><span class="number">6</span>   Matcher m1 = p1.matcher(test);</span><br><span class="line"><span class="number">7</span>    <span class="keyword">while</span>(m1.find())&#123;</span><br><span class="line"><span class="number">8</span>      System.out.println(<span class="string">"匹配结果："</span>+m1.group(<span class="number">0</span>));</span><br><span class="line"><span class="number">9</span>   &#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>   文本：<span class="number">61762828</span> <span class="number">176</span> <span class="number">2991</span> <span class="number">44</span> <span class="number">871</span></span><br><span class="line"><span class="number">2</span>   贪婪模式：\d&#123;<span class="number">3</span>,<span class="number">6</span>&#125;</span><br><span class="line"><span class="number">3</span>   匹配结果：<span class="number">617628</span></span><br><span class="line"><span class="number">4</span>   匹配结果：<span class="number">176</span></span><br><span class="line"><span class="number">5</span>   匹配结果：<span class="number">2991</span></span><br><span class="line"><span class="number">6</span>   匹配结果：<span class="number">871</span></span><br></pre></td></tr></table></figure>
<p>由结果可见：本来字符串中的“61762828”这一段，其实只需要出现3个（617）就已经匹配成功了的，但是他并不满足，而是匹配到了最大能匹配的字符，也就是6个。<br>一个量词就如此贪婪了，<br>那有人会问，如果多个贪婪量词凑在一起，那他们是如何支配自己的匹配权的呢？</p>
<blockquote>
<p>是这样的，多个贪婪在一起时，如果字符串能满足他们各自最大程度的匹配时，就互不干扰，但如果不能满足时，会根据深度优先原则，也就是从左到右的每一个贪婪量词，优先最大数量的满足，剩余再分配下一个量词匹配。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>   String reg=<span class="string">"(\\d&#123;1,2&#125;)(\\d&#123;3,4&#125;)"</span>;        </span><br><span class="line"><span class="number">2</span>   String test=<span class="string">"61762828 176 2991 87321"</span>;</span><br><span class="line"><span class="number">3</span>   System.out.println(<span class="string">"文本："</span>+test);</span><br><span class="line"><span class="number">4</span>   System.out.println(<span class="string">"贪婪模式："</span>+reg);</span><br><span class="line"><span class="number">5</span>   Pattern p1 =Pattern.compile(reg);</span><br><span class="line"><span class="number">6</span>   Matcher m1 = p1.matcher(test);</span><br><span class="line"><span class="number">7</span>    <span class="keyword">while</span>(m1.find())&#123;</span><br><span class="line"><span class="number">8</span>      System.out.println(<span class="string">"匹配结果："</span>+m1.group(<span class="number">0</span>));</span><br><span class="line"><span class="number">9</span>     &#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>   文本：<span class="number">61762828</span> <span class="number">176</span> <span class="number">2991</span> <span class="number">87321</span></span><br><span class="line"><span class="number">2</span>   贪婪模式：(\d&#123;<span class="number">1</span>,<span class="number">2</span>&#125;)(\d&#123;<span class="number">3</span>,<span class="number">4</span>&#125;)</span><br><span class="line"><span class="number">3</span>   匹配结果：<span class="number">617628</span></span><br><span class="line"><span class="number">4</span>   匹配结果：<span class="number">2991</span></span><br><span class="line"><span class="number">5</span>   匹配结果：<span class="number">87321</span></span><br></pre></td></tr></table></figure>
<ol>
<li>“617628” 是前面的\d{1,2}匹配出了61，后面的匹配出了7628</li>
<li>“2991” 是前面的\d{1,2}匹配出了29 ，后面的匹配出了91</li>
<li>“87321”是前面的\d{1,2}匹配出了87，后面的匹配出了321</li>
</ol>
<p><strong>2. 懒惰（非贪婪）</strong></p>
<blockquote>
<p>懒惰匹配：当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能少的字符，这匹配方式叫做懒惰匹配。<br>特性：从左到右，从字符串的最左边开始匹配，每次试图不读入字符匹配，匹配成功，则完成匹配，否则读入一个字符再匹配，依此循环（读入字符、匹配）直到匹配成功或者把字符串的字符匹配完为止。</p>
</blockquote>
<p>懒惰量词是在贪婪量词后面加个“？”</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmrx7t2lygj30h206mq3g.jpg" alt="img"><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmrx7r9n6wj30h206mq3g.jpg" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>   String reg=<span class="string">"(\\d&#123;1,2&#125;?)(\\d&#123;3,4&#125;)"</span>;        </span><br><span class="line"><span class="number">2</span>        String test=<span class="string">"61762828 176 2991 87321"</span>;</span><br><span class="line"><span class="number">3</span>        System.out.println(<span class="string">"文本："</span>+test);</span><br><span class="line"><span class="number">4</span>        System.out.println(<span class="string">"贪婪模式："</span>+reg);</span><br><span class="line"><span class="number">5</span>        Pattern p1 =Pattern.compile(reg);</span><br><span class="line"><span class="number">6</span>        Matcher m1 = p1.matcher(test);</span><br><span class="line"><span class="number">7</span>        <span class="keyword">while</span>(m1.find())&#123;</span><br><span class="line"><span class="number">8</span>            System.out.println(<span class="string">"匹配结果："</span>+m1.group(<span class="number">0</span>));</span><br><span class="line"><span class="number">9</span>        &#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>   文本：<span class="number">61762828</span> <span class="number">176</span> <span class="number">2991</span> <span class="number">87321</span></span><br><span class="line"><span class="number">2</span>   贪婪模式：(\d&#123;<span class="number">1</span>,<span class="number">2</span>&#125;?)(\d&#123;<span class="number">3</span>,<span class="number">4</span>&#125;)</span><br><span class="line"><span class="number">3</span>   匹配结果：<span class="number">61762</span></span><br><span class="line"><span class="number">4</span>   匹配结果：<span class="number">2991</span></span><br><span class="line"><span class="number">5</span>   匹配结果：<span class="number">87321</span></span><br></pre></td></tr></table></figure>
<p>解答：</p>
<blockquote>
<p>“61762” 是左边的懒惰匹配出6，右边的贪婪匹配出1762<br>“2991”  是左边的懒惰匹配出2，右边的贪婪匹配出991<br>“87321” 左边的懒惰匹配出8，右边的贪婪匹配出7321</p>
</blockquote>
<h3 id="5-反义"><a href="#5-反义" class="headerlink" title="5. 反义"></a><strong>5. 反义</strong></h3><p>前面说到元字符的都是要匹配什么什么，当然如果你想反着来，不想匹配某些字符，正则也提供了一些常用的反义元字符：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmrx7e070dj30h307twf5.jpg" alt="img"><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmrx7i6xktj30h307twf5.jpg" alt="img"></p>
<p>正则进阶知识就讲到这里，正则是一门博大精深的语言，其实学会它的一些语法和知识点还算不太难，但想要做到真正学以致用能写出非常6的正则，还有很远的距离，只有真正对它感兴趣的，并且经常研究和使用它，才会渐渐的理解它的博大精深之处，我就带你们走到这，剩下的，靠自己啦。</p>
<p>作者：老刘<br>链接：<span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzQ4MjE5NDAxL2Fuc3dlci83NDI0NDQzMjY=" title="https://www.zhihu.com/question/48219401/answer/742444326">https://www.zhihu.com/question/48219401/answer/742444326<i class="fa fa-external-link"></i></span><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 正则表达式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[linux netcat 命令——网络工具中的瑞士军刀]]></title>
      <url>/%E5%91%BD%E4%BB%A4%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7%E4%B8%AD%E7%9A%84%E7%91%9E%E5%A3%AB%E5%86%9B%E5%88%80.html</url>
      <content type="html"><![CDATA[<p><strong>netcat</strong>是网络工具中的瑞士军刀，它能通过TCP和UDP在网络中读写数据。通过与其他工具结合和重定向，你可以在脚本中以多种方式使用它。使用netcat命令所能完成的事情令人惊讶。</p>
<a id="more"></a>
<p><strong>netcat</strong>所做的就是在两台电脑之间建立链接并返回两个数据流，在这之后所能做的事就看你的想像力了。你能建立一个服务器，传输文件，与朋友聊天，传输流媒体或者用它作为其它协议的独立客户端。</p>
<p>下面是一些使用netcat的例子.</p>
<p>[A(172.31.100.7) B(172.31.100.23)]</p>
<p>Linux netcat 命令实例：</p>
<h3 id="1，端口扫描"><a href="#1，端口扫描" class="headerlink" title="1，端口扫描"></a>1，端口扫描</h3><p>端口扫描经常被系统管理员和黑客用来发现在一些机器上开放端口，帮助他们识别系统中的漏洞。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$nc -z -v -n 172.31.100.7 21-25</span><br></pre></td></tr></table></figure>
<p>可以运行在TCP或者UDP模式，默认是TCP，-u参数调整为udp.</p>
<p>z 参数告诉netcat使用0 IO,指的是一旦连接关闭，不进行数据交换(译者注：这里翻译不准，如有其它更好的，请指出)</p>
<p>v 参数指使用冗余选项（译者注：即详细输出）</p>
<p>n 参数告诉netcat 不要使用DNS反向查询IP地址的域名</p>
<p>这个命令会打印21到25 所有开放的端口。Banner是一个文本，Banner是一个你连接的服务发送给你的文本信息。当你试图鉴别漏洞或者服务的类型和版本的时候，Banner信息是非常有用的。但是，并不是所有的服务都会发送banner。</p>
<p>一旦你发现开放的端口，你可以容易的使用netcat 连接服务抓取他们的banner。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nc -v 172.31.100.7 21</span><br></pre></td></tr></table></figure>
<p>netcat 命令会连接开放端口21并且打印运行在这个端口上服务的banner信息。</p>
<h3 id="Chat-Server"><a href="#Chat-Server" class="headerlink" title="Chat Server"></a>Chat Server</h3><p>假如你想和你的朋友聊聊，有很多的软件和信息服务可以供你使用。但是，如果你没有这么奢侈的配置，比如你在计算机实验室，所有的对外的连接都是被限制的，你怎样和整天坐在隔壁房间的朋友沟通那？不要郁闷了，netcat提供了这样一种方法，你只需要创建一个Chat服务器，一个预先确定好的端口，这样子他就可以联系到你了。</p>
<p>Server</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$nc -l 1567</span><br></pre></td></tr></table></figure>
<p>netcat 命令在1567端口启动了一个tcp 服务器，所有的标准输出和输入会输出到该端口。输出和输入都在此shell中展示。</p>
<p>Client</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$nc 172.31.100.7 1567</span><br></pre></td></tr></table></figure>
<p>不管你在机器B上键入什么都会出现在机器A上。</p>
<h3 id="3，文件传输"><a href="#3，文件传输" class="headerlink" title="3，文件传输"></a>3，文件传输</h3><p>大部分时间中，我们都在试图通过网络或者其他工具传输文件。有很多种方法，比如FTP,SCP,SMB等等，但是当你只是需要临时或者一次传输文件，真的值得浪费时间来安装配置一个软件到你的机器上嘛。假设，你想要传一个文件file.txt 从A 到B。A或者B都可以作为服务器或者客户端，以下，让A作为服务器，B为客户端。</p>
<p>Server</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$nc -l 1567 &lt; file.txt</span><br></pre></td></tr></table></figure>
<p>Client</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$nc -n 172.31.100.7 1567 &gt; file.txt</span><br></pre></td></tr></table></figure>
<p>这里我们创建了一个服务器在A上并且重定向netcat的输入为文件file.txt，那么当任何成功连接到该端口，netcat会发送file的文件内容。</p>
<p>在客户端我们重定向输出到file.txt，当B连接到A，A发送文件内容，B保存文件内容到file.txt.</p>
<p>没有必要创建文件源作为Server，我们也可以相反的方法使用。像下面的我们发送文件从B到A，但是服务器创建在A上，这次我们仅需要重定向netcat的输出并且重定向B的输入文件。</p>
<p>B作为Server</p>
<p>Server</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$nc -l 1567 &gt; file.txt</span><br></pre></td></tr></table></figure>
<p>Client</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc 172.31.100.23 1567 &lt; file.txt</span><br></pre></td></tr></table></figure>
<h3 id="4，目录传输"><a href="#4，目录传输" class="headerlink" title="4，目录传输"></a>4，目录传输</h3><p>发送一个文件很简单，但是如果我们想要发送多个文件，或者整个目录，一样很简单，只需要使用压缩工具tar，压缩后发送压缩包。</p>
<p>如果你想要通过网络传输一个目录从A到B。</p>
<p>Server</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$tar -cvf – dir_name | nc -l 1567</span><br></pre></td></tr></table></figure>
<p>Client</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$nc -n 172.31.100.7 1567 | tar -xvf -</span><br></pre></td></tr></table></figure>
<p>这里在A服务器上，我们创建一个tar归档包并且通过-在控制台重定向它，然后使用管道，重定向给netcat，netcat可以通过网络发送它。</p>
<p>在客户端我们下载该压缩包通过netcat 管道然后打开文件。</p>
<p>如果想要节省带宽传输压缩包，我们可以使用bzip2或者其他工具压缩。</p>
<p>Server</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$tar -cvf – dir_name| bzip2 -z | nc -l 1567</span><br></pre></td></tr></table></figure>
<p>通过bzip2压缩</p>
<p>Client</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$nc -n 172.31.100.7 1567 | bzip2 -d |tar -xvf -</span><br></pre></td></tr></table></figure>
<p>使用bzip2解压</p>
<h3 id="5-加密你通过网络发送的数据"><a href="#5-加密你通过网络发送的数据" class="headerlink" title="5. 加密你通过网络发送的数据"></a>5. 加密你通过网络发送的数据</h3><p>如果你担心你在网络上发送数据的安全，你可以在发送你的数据之前用如mcrypt的工具加密。</p>
<p>服务端</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$nc localhost 1567 | mcrypt –flush –bare -F -q -d -m ecb &gt; file.txt</span><br></pre></td></tr></table></figure>
<p>使用mcrypt工具加密数据。</p>
<p>客户端</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$mcrypt –flush –bare -F -q -m ecb &lt; file.txt | nc -l 1567</span><br></pre></td></tr></table></figure>
<p>使用mcrypt工具解密数据。</p>
<p>以上两个命令会提示需要密码，确保两端使用相同的密码。</p>
<p>这里我们是使用mcrypt用来加密，使用其它任意加密工具都可以。</p>
<h3 id="6-流视频"><a href="#6-流视频" class="headerlink" title="6. 流视频"></a>6. 流视频</h3><p>虽然不是生成流视频的最好方法，但如果服务器上没有特定的工具，使用netcat，我们仍然有希望做成这件事。</p>
<p>服务端</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$cat video.avi | nc -l 1567</span><br></pre></td></tr></table></figure>
<p>这里我们只是从一个视频文件中读入并重定向输出到netcat客户端</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$nc 172.31.100.7 1567 | mplayer -vo x11 -cache 3000 -</span><br></pre></td></tr></table></figure>
<p>这里我们从socket中读入数据并重定向到mplayer。</p>
<h3 id="7，克隆一个设备"><a href="#7，克隆一个设备" class="headerlink" title="7，克隆一个设备"></a>7，克隆一个设备</h3><p>如果你已经安装配置一台Linux机器并且需要重复同样的操作对其他的机器，而你不想在重复配置一遍。不在需要重复配置安装的过程，只启动另一台机器的一些引导可以随身碟和克隆你的机器。</p>
<p>克隆Linux PC很简单，假如你的系统在磁盘/dev/sda上</p>
<p>Server</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$dd if=/dev/sda | nc -l 1567</span><br></pre></td></tr></table></figure>
<p>Client</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$nc -n 172.31.100.7 1567 | dd of=/dev/sda</span><br></pre></td></tr></table></figure>
<p>dd是一个从磁盘读取原始数据的工具，我通过netcat服务器重定向它的输出流到其他机器并且写入到磁盘中，它会随着分区表拷贝所有的信息。但是如果我们已经做过分区并且只需要克隆root分区，我们可以根据我们系统root分区的位置，更改sda 为sda1，sda2.等等。</p>
<h3 id="8，打开一个shell"><a href="#8，打开一个shell" class="headerlink" title="8，打开一个shell"></a>8，打开一个shell</h3><p>我们已经用过远程shell-使用telnet和ssh，但是如果这两个命令没有安装并且我们没有权限安装他们，我们也可以使用netcat创建远程shell。</p>
<p>假设你的netcat支持 -c -e 参数(默认 netcat)</p>
<p>Server</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$nc -l 1567 -e /bin/bash -i</span><br></pre></td></tr></table></figure>
<p>Client</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$nc 172.31.100.7 1567</span><br></pre></td></tr></table></figure>
<p>这里我们已经创建了一个netcat服务器并且表示当它连接成功时执行/bin/bash</p>
<p>假如netcat 不支持-c 或者 -e 参数（openbsd netcat）,我们仍然能够创建远程shell</p>
<p>Server</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$mkfifo /tmp/tmp_fifo</span><br><span class="line">$cat /tmp/tmp_fifo | /bin/sh -i 2&gt;&amp;1 | nc -l 1567 &gt; /tmp/tmp_fifo</span><br></pre></td></tr></table></figure>
<p>这里我们创建了一个fifo文件，然后使用管道命令把这个fifo文件内容定向到shell 2&gt;&amp;1中。是用来重定向标准错误输出和标准输出，然后管道到netcat 运行的端口1567上。至此，我们已经把netcat的输出重定向到fifo文件中。</p>
<p>说明：</p>
<p>从网络收到的输入写到fifo文件中</p>
<p>cat 命令读取fifo文件并且其内容发送给sh命令</p>
<p>sh命令进程受到输入并把它写回到netcat。</p>
<p>netcat 通过网络发送输出到client</p>
<p>至于为什么会成功是因为管道使命令平行执行，fifo文件用来替代正常文件，因为fifo使读取等待而如果是一个普通文件，cat命令会尽快结束并开始读取空文件。</p>
<p>在客户端仅仅简单连接到服务器</p>
<p>Client</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$nc -n 172.31.100.7 1567</span><br></pre></td></tr></table></figure>
<p>你会得到一个shell提示符在客户端</p>
<h3 id="反向shell"><a href="#反向shell" class="headerlink" title="反向shell"></a>反向shell</h3><p>反向shell是人曾经在客户端打开的shell。反向shell这样命名是因为不同于其他配置，这里服务器使用的是由客户提供的服务。</p>
<p>服务端</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$nc -l 1567</span><br></pre></td></tr></table></figure>
<p>在客户端，简单地告诉netcat在连接完成后，执行shell。</p>
<p>客户端</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$nc 172.31.100.7 1567 -e /bin/bash</span><br></pre></td></tr></table></figure>
<p>现在，什么是反向shell的特别之处呢<br>反向shell经常被用来绕过防火墙的限制，如阻止入站连接。例如，我有一个专用IP地址为172.31.100.7，我使用代理服务器连接到外部网络。如果我想从网络外部访问 这台机器如1.2.3.4的shell，那么我会用反向外壳用于这一目的。 </p>
<h3 id="10-指定源端口"><a href="#10-指定源端口" class="headerlink" title="10. 指定源端口"></a><strong>10. 指定源端口</strong></h3><p>假设你的防火墙过滤除25端口外其它所有端口，你需要使用-p选项指定源端口。</p>
<p>服务器端</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$nc -l 1567</span><br></pre></td></tr></table></figure>
<p>客户端</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$nc 172.31.100.7 1567 -p 25</span><br></pre></td></tr></table></figure>
<p>使用1024以内的端口需要root权限。</p>
<p>该命令将在客户端开启25端口用于通讯，否则将使用随机端口。</p>
<h3 id="11-指定源地址"><a href="#11-指定源地址" class="headerlink" title="11. 指定源地址"></a><strong>11. 指定源地址</strong></h3><p>假设你的机器有多个地址，希望明确指定使用哪个地址用于外部数据通讯。我们可以在netcat中使用-s选项指定ip地址。</p>
<p>服务器端</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$nc -u -l 1567 &lt; file.txt</span><br></pre></td></tr></table></figure>
<p>客户端</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$nc -u 172.31.100.7 1567 -s 172.31.100.5 &gt; file.txt</span><br></pre></td></tr></table></figure>
<p>该命令将绑定地址172.31.100.5。</p>
<p>这仅仅是使用netcat的一些示例。</p>
<p>其它用途有：</p>
<ul>
<li>使用-t选项模拟Telnet客户端，</li>
<li>HTTP客户端用于下载文件，</li>
<li>连接到邮件服务器，使用SMTP协议检查邮件，</li>
<li>使用ffmpeg截取屏幕并通过流式传输分享，等等。其它更多用途。</li>
</ul>
<p>简单来说，只要你了解协议就可以使用netcat作为网络通讯媒介，实现各种客户端。</p>
<p>原文地址：<span class="exturl" data-url="aHR0cDovL3d3dy5vc2NoaW5hLm5ldC90cmFuc2xhdGUvbGludXgtbmV0Y2F0LWNvbW1hbmQ=" title="http://www.oschina.net/translate/linux-netcat-command">http://www.oschina.net/translate/linux-netcat-command<i class="fa fa-external-link"></i></span></p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> netstat </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[应对Hadoop集群数据疯长，这里祭出了4个治理对策！]]></title>
      <url>/%E5%BA%94%E5%AF%B9Hadoop%E9%9B%86%E7%BE%A4%E6%95%B0%E6%8D%AE%E7%96%AF%E9%95%BF%EF%BC%8C%E8%BF%99%E9%87%8C%E7%A5%AD%E5%87%BA%E4%BA%864%E4%B8%AA%E6%B2%BB%E7%90%86%E5%AF%B9%E7%AD%96%EF%BC%81.html</url>
      <content type="html"><![CDATA[<p><strong>一、背景</strong></p>
<p>在目前规模比较大的互联网公司中，总数据量能达到10PB甚至几十PB数据量的公司，我认为中国已经有超过了20家了。而在这些公司中，也有很多家公司的日数据增长达到100TB+了。 </p>
<a id="more"></a>
<p>所以我们每天都要观察集群的数据增长，观察是否有哪一天、哪个路径增长过猛了，是否增长了很多垃圾数据；继续深挖下去，看看是不是可以删掉无用的数据。</p>
<p>此外我们还要做“容量预估“，把未来的数据增长规划出来，主要是依靠数据增长斜率计算出未来一个季度后的数据量，再把机器采购需求汇报出去。</p>
<p>在上一篇《基于FsImage的HDFS数据深度分析》（<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zMjIwMzk1Me+8ieS4re+8jOaIkeS7rOWIm+W7uuS6huWfuuS6jkZzaW1hZ2XnmoRIREZT5pWw5o2u5YiG5p6Q5LuT5bqT77yM5bm25Yib5bu65LqG5LiA5Lqb5YiG5p6Q5Zu+6KGo77yM5q+U5aaC4oCcSERGU+WinumVv+i2i+WKv+WbvuKAne+8jOWFheWIhuWcsOino+WGs+S6huWPkeeOsOKAnOaVsOaNruWinumVv+W8guW4uOKAneeahOmXrumimOOAgg==" title="https://zhuanlan.zhihu.com/p/32203951）中，我们创建了基于Fsimage的HDFS数据分析仓库，并创建了一些分析图表，比如“HDFS增长趋势图”，充分地解决了发现“数据增长异常”的问题。">https://zhuanlan.zhihu.com/p/32203951）中，我们创建了基于Fsimage的HDFS数据分析仓库，并创建了一些分析图表，比如“HDFS增长趋势图”，充分地解决了发现“数据增长异常”的问题。<i class="fa fa-external-link"></i></span></p>
<p><strong>今天，我们会探讨以下4个问题：</strong></p>
<ol>
<li>怎样观察“数据增长”</li>
<li>怎样治理“数据过快增长”</li>
<li>怎样清理“无用的冷数据”</li>
<li>怎样管理“数据存活时间”</li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmo7lft0hrj30u00fejs1.jpg" alt="img"></p>
<p>HDFS增长趋势图</p>
<p>先来算一笔账：当下，一台不错的Datanode机器配置，能挂12-16块盘，每块盘挂上比较大的3TB的硬盘。单台机器的存储量大致在50TB。若按每天增长100TB算，就需要2台机器；按每天增长500TB，则是10台机器。这个数字实在是Terrible ！ </p>
<p><strong>数据疯狂增长带来的问题</strong></p>
<p><strong>1、加机器对公司的财务预算要求很高</strong></p>
<p>服务器再便宜，也是钱。以一周买几十台服务器这种速度来看，即便是财务运转再好的IT公司也不愿意看到数据增长失控。</p>
<p><strong>2、对集群负载的压力</strong></p>
<p>Hadoop是一个可以水平扩展的技术栈，且大多数分布式系统也都是把“水平Scalable”作为主要的功能点设计， 但在工程中，是否真的能做到“无限水平扩展”呢？</p>
<p>首先Hadoop中有一些“Master节点”，这些 Master 节点要实时地和所有“ Slave节点 ”保持心跳通信。在集群规模较小时，由于“心跳”只做简单的网络通信，且所有的 Datanode 都互相错峰汇报“心跳”， 所以网络元数据交换并不是 Hadoop 系统水平扩张的瓶颈。</p>
<p>但在Hadoop集群的规模达到了大几千甚至上万台后，网络就是Namenode的瓶颈。这些心跳的RPC请求会和“用户Client”的RPC请求一起抢占Namenode有限的CPU资源。</p>
<p><strong>3、对运维团队的运维压力</strong></p>
<p>运维团队每周／月都要安装新机器到Hadoop集群里。做这些事情是重复又无聊的，即使自动化做得再好，也需要人来处理某些环节。脏活累活对追求“高技术密集度”的精英工程师团队，是有危害的。</p>
<p>那为什么我们会有这么多数据增长问题？直接删掉无用的数据不就行了吗？这个事情在公司内部很难做吗？</p>
<p><strong>为什么这个问题在公司难做？</strong></p>
<p>对于数据的增长，Hadoop Admin应该要对此负责的，但很多公司并没有做好这件事情，原因如下：</p>
<p><strong>1、一些公司在自己的数据量级并不是很大的时候，不愿意重视这个问题。</strong>对他们而言，与其请2个人去做这个事情，花掉半年时间， 不如先把钱拿来买机器，这样的情形大多发生在 B轮／C轮的公司里。</p>
<p>业务增长是主要矛盾。数据每天增长5T，两个程序员半年的成本确实大于买一些机器先解燃眉之急。 等到公司业务越来越大，问题暴露得越来越严重时，公司才开始意识到严重性，这往往已经晚了，毕竟建立整套的HDFS分析系统和报表系统也不是一时半会就能搞定的。</p>
<p><strong>2、受限于管理上的问题。</strong>在公司里，“业务事业部“和 “基础架构部”是平级的，那作为“基础架构部”的普通员工，哪怕是“基础架构部”的领导，都很难推动其它“业务部门”去Clean他们的数据存储。比如：</p>
<ul>
<li>清一下没用的冷数据</li>
<li>给用户行为日志加一些 Data Retention策略</li>
</ul>
<p>“业务部门”总认为自己的核心任务就是业务开发，能为公司产生更大的利益，因此在做数据清理的任务时，总把排期靠后或是设定为低优先级，总有“干不完”的开发任务，所以清理数据在公司内部很难推动。</p>
<p><strong>3、Hadoop Admin 能拿出足够的证据，让“业务部门”删除冷数据吗？实际上，“业务部门”通常会这样搪塞：</strong></p>
<ul>
<li>/path/a 到底最后访问的时间是什么时候，凭什么说没人用了？</li>
<li>/path/b 有100TB，可我都是有用的数据，别人也这么大，为什么不删别人的？</li>
<li>你总让“我们部门”删数据，我们到底用了多少存储空间？别的组如果比我们更多呢？ </li>
</ul>
<p>带着上面这三个问题，继续往下看。 </p>
<ol>
<li>第一个问题似乎是一个很难避免的问题，需要CTO有掌舵的能力，那笔者则希望有志于利用起Hadoop技术栈的中小公司CTO在看了这篇文章后，都能增加这个意识。</li>
<li>第二个问题是管理上的问题。一般牵扯到制度上的变革，最好是要有Involve更高层领导参与的。多和高层提“成本”和“省钱”，少提“技术”，我认为高层会意识到这个问题的价值。</li>
<li>第三个问题是本文的重点，即如何摆事实、拿证据证明我们可以针对Path做数据优化呢？ 哪些Path可以删掉？哪些Path应该加Data Retention 策略？</li>
</ol>
<p><strong>二、行为（Action）</strong></p>
<p>我们需要定期进行一些行为，来保持集群的数据可控。</p>
<p><strong>每日行为</strong> </p>
<p>每天来到公司，做这样几件事：</p>
<ul>
<li>集群增长常规日分析</li>
<li>当集群“日增长有异样”时，分析具体哪个Path增长占主导</li>
<li>发现“异常路径“属于哪个User或Team</li>
<li>发送邮件给对应User／Team，给出Solution</li>
</ul>
<p><strong>季度行为</strong></p>
<p>每个季度结束时 ：</p>
<ul>
<li>哪个Team增长最猛，统计Team日增长平均量</li>
<li>找到“环比”增长最猛的Team，找到本季度“新增数据最猛”的新路径，一般为一些新Hive表</li>
<li>发邮件给对应Team，给出Solution</li>
</ul>
<p>要做到上述行为，我们要对每个Team，每个Path的“数据增长”都有详尽的数据支持。试想一下，在理想情况下，我们需要有哪些数据才能搞定？</p>
<p>针对“每日行为””，我们需要确定：</p>
<ul>
<li>每天增长最大的文件是哪些？</li>
<li>针对确定的“异常日增长路径”，能查到这个路径的历史数据增长，因为要清楚“平均增长值”，才能看出“某日增长量为异常”，然后再查到其下哪个子路径贡献了最大的增长，进一步深入查找问题。</li>
</ul>
<p>针对“季度行为”，我们需要：</p>
<p>1、所有“数据团队”对集群存储的使用情况，按HDFS的使用量做KPI考核；不仅了解每一个“数据团队”都有哪些“重要路径”，还需要知道这些路径的“增长状况怎么样”。 </p>
<ul>
<li>TeamA 一共使用的存储空间，占公司总量有多少？</li>
<li>TeamA 过去一个季度的环比增长速度如何？</li>
<li>TeamA 过去一个季度的绝对增长量如何？</li>
<li>TeamA 下的路径里，是否新建了很多新数据，比如新Hive表？是否有 Data Retention策略？</li>
</ul>
<p>2、针对一个Team新增的“异常增长路径”，我们要能查到这个路径的历史数据增长，要知道“平均增长值”，才能看出“某日增长量为异常”，然后查到其下哪个子路径贡献了最大的增长，进一步深入查找问题。</p>
<p>3、针对“某些”很大的、Size很久没有变化过的Folder，我们要知道这个Folder最后的访问时间是什么时候、它超过半年没访问过的文件占比有多少、超过1年没访问过的文件有多少，然后我们才能和所属的Team联系，优先决定是否能删除它。</p>
<p>在前文《基于FsImage的HDFS数据深度分析》（<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zMjIwMzk1Me+8ieS4rQ==" title="https://zhuanlan.zhihu.com/p/32203951）中">https://zhuanlan.zhihu.com/p/32203951）中<i class="fa fa-external-link"></i></span> ，我们建立了HDFS数据仓库，这相当于我们存下了HDFS每一天的快照，所以每一条Path的元数据历史问题解决了。 </p>
<p>再来说说Team Level，每一个Team的数据，都是由一些文件夹下的数据组成的。比如“推荐系统团队”，在/hive/warehouse/reco.db下，所有的推荐相关的表数据都存在于这个下面。另外/user/reco下也存放了很多这个组的数据，这几个路径，都属于“推荐数据组”的“顶级路径”。 所有“顶级路径”的“增长聚合”，就是整个组的“数据增长”。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmo7ph20x5j30u009a0t4.jpg" alt="img"></p>
<p>数据组的顶级路径</p>
<p>每个Folder聚合其下每一个文件的Last_access_time，作为最终这个Folder的Last_access_time. </p>
<p>这个功能对Hive表非常好用。 有些Hive表很久都没有人访问过，后面我也会详细叙述如何清理Hive表。</p>
<p><strong>三、例子</strong></p>
<p>接下来我将用我司的自动化运维系统中的一些报表来做解决问题的展示。</p>
<p>这些报表都是我们根据解决问题的方法论创建出来的，我们希望贯彻“让一切人的决策基于数据”这一宗旨。让我们判断问题、找到问题，甚至说服“数据团队”，都用Data Driven。</p>
<p> <strong>每日行为例子</strong> </p>
<p>1、查看集群每日增长，发现没什么大问题。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmo7q4efjbj30u00dqdgf.jpg" alt="img"></p>
<p>2、查看增长贡献，发现几个/User下的用户增长过猛。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmo7qnnl70j30u00kcjsx.jpg" alt="img"></p>
<p>3、查看这个路径，与本路径历史增长做比较，发现昨日确实是在不正常地增长。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmo7qzaqu7j30u00d6gmq.jpg" alt="img"></p>
<p>4、分析具体是什么子文件导致了这个目录的异常增长。 </p>
<p>原来是这个用户删除了一些其它路径的大文件，划归到User目录自己的~/.Trash下了。那这就不用太担心，因为HDFS第二天会自动清理掉~/.Trash下的垃圾文件。 </p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmo7r6rqf4j30u00mfq57.jpg" alt="img"></p>
<p><strong>季度行为例子</strong></p>
<p><strong>1、分析“数据团队”季度增长量</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmo7ws6w7xj30u0064dgl.jpg" alt="img"></p>
<p> 可以看到：</p>
<ul>
<li>TeamA的数据总量很大，环比增长也很大，是首要的分析目标。</li>
<li>TeamB 和 TeamC 相比，虽然TeamB绝对值增量比TeamC大了很多，但还是一个数量级，但TeamC环比增速太高，很可能业务上发生了很大的变化，所以 TeamC是第二目标。</li>
</ul>
<p>在运维人员有限的工作时间内，一定要把“精力”花在刀刃上。对一个Team的数据进行深度分析，往往要用去个把小时，一定要在单位时间上产出最大化。</p>
<p><strong>2、深度分析Team数据</strong> </p>
<p>深度分析也是遵循“单位时间产出最大化，抓最主要矛盾”这一思想。接下来还是拿我司的“推荐“团队做例子：</p>
<p>这些所有的顶级路径，都代表了某种业务的“细分”顶级路径。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmo7x660v4j30u0067dfy.jpg" alt="img"></p>
<p>在每个细分“顶级路径”下，我们要观察：</p>
<ul>
<li>哪些路径的“绝对数据量”很大，一头大象体重增长10%比一只老鼠多生一窝产生的体重多得多；</li>
<li>所有“第二档次数据贡献量”的路径，分别调查其“日增长量”和“环比增速”，即“增速”的相对值和绝对值。</li>
</ul>
<p>还是拿Recoteam数据来举例子：</p>
<p>根据数据统计，我们分出第一轮目标和第二轮目标。 </p>
<p><img src="http://dbaplus.cn/uploadfile/2018/0308/20180308115958294.jpg" alt="img"></p>
<p><strong>第一个路径：</strong></p>
<p><strong>hdfs://beaconstore/user/hadoop/reco/report</strong></p>
<p>它的特点是每日增速固定， 但最近访问时间“很新”，且“平均文件大小”偏小。</p>
<p>所以策略可能是 ：</p>
<ul>
<li>“每日数据量优化”；</li>
<li>“减少天分区数”；</li>
<li>未来对“文件平均大小”做优化。因为文件数量很多，可以节省出很多内存。</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmo7xtlvlij30u00nxac4.jpg" alt="img"></p>
<p> <strong>第二个路径：</strong></p>
<p><strong>hdfs://beaconstore/user/hadoop/reco/report</strong> </p>
<p>它的特点是已经许久不新增数据， 但最近访问时间“很新”。</p>
<p>所以策略可能是 ：</p>
<ul>
<li>找到哪些子数据经常访问；</li>
<li>删掉不访问的子数据 ；</li>
<li>是否有生命周期，有的话记得在未来删除。</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmo7y31iadj30u00nr76g.jpg" alt="img"></p>
<p> <strong>第三个路径：</strong></p>
<p><strong>hdfs://beaconstore/user/hadoop/reco/online_log</strong> </p>
<p>它的特点是很久很久不新增数据， 且最近访问时间“很老”。</p>
<p>策略是——建议删除。 </p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmo7ybusovj30u00ortbj.jpg" alt="img"></p>
<p>可以看出，不同的HDFS路径，其存在的问题不尽相同，这真的需要具体问题具体分析。</p>
<p>如果通过分析“第一目标清单”，已经能够达到控制集群存储的目的，大幅降低数据存储，那么可以适当地忽略“第二目标清单”，记住那个目标“单位时间产出比”。这时可以把时间省下来做更多有意义的事情。</p>
<p><strong>3、最后我们会出具一个Report，给相关的组发送Email，指明应该做哪些优化。</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmo7yn6gfaj30u00qi0vd.jpg" alt="img"></p>
<p><strong>四、数据增长之Hive篇</strong></p>
<p>前文在讲述治理HDFSS的数据增长问题时提到了：</p>
<ul>
<li>每日独立“异常路径”数据增长治理</li>
<li>每季度数据增长过快的“异常数据Team”的深度数据治理</li>
</ul>
<p>现在我们就把目标锁定到Hadoop的数据仓库Hive，谈谈数据增长之Hive。</p>
<p><strong>方法论</strong> </p>
<p>笔者认为Hive的“数据增长治理”，也分为两点：</p>
<ul>
<li>每日观察“新增Hive表”，查看“每日增速过快的”以及“总量过快的”。新增的Hive表，被限定在30天（一个月内）新创建的Hive表。Hive表的创建时间，在Hive-metastore的数据里可以得到。</li>
<li>每季度观察“冷Hive表”，重点抓“Size最大的，最冷的Hive表”。</li>
</ul>
<p>找到可优化“目标Hive表后”，按照前文提及的步骤来优化Hive表背后的HDFS路径，一个控制增量，一个优化存量。</p>
<p> <strong>细节</strong> </p>
<p><strong>1、控制增量</strong></p>
<p>Hadoop管理员每天早上花时间扫一眼最近一个月新建的Hive表里有没有很大的表。</p>
<p>这里的“大”指的是：</p>
<ul>
<li><p>30天总量达到10个TB。 这个很好理解,”月总量值”是可配的，可以随着业务增长放大。</p>
</li>
<li><p>“每天平均日增量”达到1个TB。 因为有些表的生命周期可能只有几天，日增量大的表，都要进入“待观察”列表，最好都能强制“被管控”（Data Retention 策略，TTL等） </p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmo7zaia6lj30u009jmyb.jpg" alt="img"></p>
</li>
</ul>
<p><strong>2、优化存量</strong></p>
<p>Hive表的底层数据，是存储在HDFS上的文件夹。我们可以通过使用SQL，从Hive－metastore这个MySQL数据库里，查询到Hive表的HDFS路径，Owner等元信息。</p>
<p>select TBL_NAME, location, owner, db.NAME from TBLS tb left join SDS s on tb.SD_ID=s.SD_ID left join DBS db on tb.DB_ID=db.DB_ID</p>
<p>在查找到Hive表 －》 HDFS路径的对应关系后，我们又可以根据前文 《基于FsImage的HDFS数据深度分析》所建立的HDFS文件系统数据仓库，查询到HDFS路径的“Last_access_time”，以及路径的Size，平均文件大小等元数据，这保证并确认了hive表的“最后访问时间”是可知的。</p>
<p>最后，Hive表的几项元信息，都会被缓存到另一张经过ETL后的的数据表Hive_meta_after_etl。这张表的结构如下： </p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmo7zm7us3j30ty09aq3x.jpg" alt="img"></p>
<p>hive_meta_after_etl</p>
<p>有了Hive_meta_after_etl表元数据的数据库，我们就可以设计查询入口：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmo7zt3ytgj30u00g5abx.jpg" alt="img"></p>
<p>在选出了运维的目标Hive表后，按照前文中分析HDFS“异常路径”的方法，进行进一步分析即可。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmo7zyvbv1j30ty0xaju3.jpg" alt="img"></p>
<p>架构</p>
<p><strong>总结</strong></p>
<p>总之，为了防患“无止境的数据增长”，公司最好每天都观察数据增长5分钟，并在每个季度Review每个数据Team的增长。</p>
<p>这里总结了一些通用的原则，供大家参考：</p>
<ul>
<li>要明确谁占用的“资源多”，谁Cost的成本高，方便给CTO汇报。</li>
<li>要打通数据分析系统，在数据团队有疑问、甚至不配合工作时，给他们摆事实、讲道理。</li>
<li>要把不同数据团队的KPI做排名、做比较，让数据存储上做得差的团队有“羞耻感”。</li>
<li>在推动整体数据治理这件事时，有必要Involve更高级别的领导，甚至CTO。</li>
<li>要梳理清楚Team的顶级路径，严格规定路径的使用。承诺只有放在Team顶级路径下的文件是安全的，否则都可能在系统过载时被管理员删除。</li>
<li>在有限的时间内，让产出最大化，把精力花在最有价值的点上。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 大数据 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hadoop </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Spark-聚类分析-出租车案例]]></title>
      <url>/Spark-%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90-%E5%87%BA%E7%A7%9F%E8%BD%A6%E6%A1%88%E4%BE%8B.html</url>
      <content type="html"><![CDATA[<p>通过分析出租车数据，然后使用KMeans对经纬度进行聚类，然后按照（类别，时间）进行分类，再统计每个类别每个时段的次数。</p>
<a id="more"></a>
<p>数据地址 链接: <span class="exturl" data-url="aHR0cHM6Ly9wYW4uYmFpZHUuY29tL3MvMTY2ZEtSVXByeUhXWjJGOHdMQTNleXc=" title="https://pan.baidu.com/s/166dKRUpryHWZ2F8wLA3eyw">https://pan.baidu.com/s/166dKRUpryHWZ2F8wLA3eyw<i class="fa fa-external-link"></i></span> 密码: g9dz</p>
<p>数据格式以及意义：</p>
<p>111,30.655325,104.072573,173749<br>111,30.655346,104.072363,173828<br>111,30.655377,104.120252,124057<br>111,30.655439,104.088812,142016</p>
<p>列一：出租车ID</p>
<p>列二：经度</p>
<p>列三：纬度</p>
<p>列四：时间（例如：142016表示14点20分16秒）</p>
<p>步骤：</p>
<p>1.整理数据，分割成训练数据和测试数据，且使其符合KMeans模型训练的格式</p>
<p>2.使用训练好的模型对测试数据进行预测，然后对结果以（类别，小时时间 ）进行count统计，结果为每个类别每个小时的总次数。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.spark.ml.clustering.<span class="type">KMeans</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.ml.feature.<span class="type">VectorAssembler</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.<span class="type">SparkSession</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.types.&#123;<span class="type">StructField</span>, <span class="type">StructType</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.types._</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.functions._</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Tax1</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(arg:<span class="type">Array</span>[<span class="type">String</span>]):<span class="type">Unit</span>=&#123;</span><br><span class="line">    <span class="keyword">val</span> spark = <span class="type">SparkSession</span>.builder().appName(<span class="string">"Taxi1"</span>).master(<span class="string">"local[*]"</span>).getOrCreate()</span><br><span class="line"><span class="comment">//为读取的数据创建schema</span></span><br><span class="line">    <span class="keyword">val</span> taxiSchema = <span class="type">StructType</span>(<span class="type">Array</span>(</span><br><span class="line">      <span class="type">StructField</span>(<span class="string">"id"</span>,<span class="type">IntegerType</span>,<span class="literal">true</span>),</span><br><span class="line">      <span class="type">StructField</span>(<span class="string">"tid"</span>,<span class="type">DoubleType</span>,<span class="literal">true</span>),</span><br><span class="line">      <span class="type">StructField</span>(<span class="string">"lat"</span>,<span class="type">DoubleType</span>,<span class="literal">true</span>),</span><br><span class="line">      <span class="type">StructField</span>(<span class="string">"time"</span>,<span class="type">StringType</span>,<span class="literal">true</span>)</span><br><span class="line">    ))</span><br><span class="line">    <span class="keyword">val</span> path = <span class="string">"/home/enche/data/taxi.csv"</span></span><br><span class="line">    <span class="keyword">val</span> data = spark.read.schema(taxiSchema).csv(path)</span><br><span class="line">    <span class="comment">//将tid和lat转换成训练使用的Vector类型</span></span><br><span class="line">    <span class="keyword">val</span> assembler = <span class="keyword">new</span> <span class="type">VectorAssembler</span>()</span><br><span class="line">    <span class="keyword">val</span> tid_lat = <span class="type">Array</span>(<span class="string">"tid"</span>,<span class="string">"lat"</span>)</span><br><span class="line">    assembler.setInputCols(tid_lat).setOutputCol(<span class="string">"feature"</span>).transform(data)</span><br><span class="line">    <span class="comment">//按照8：2的比例随即分割数据，分别用于训练和测试</span></span><br><span class="line">    <span class="keyword">val</span> splitRait = <span class="type">Array</span>(<span class="number">0.8</span>, <span class="number">0.2</span>)</span><br><span class="line">    <span class="keyword">val</span> <span class="type">Array</span>(train, test) = data.randomSplit(splitRait)</span><br><span class="line">    <span class="comment">//建立Kmeans，设置类别数为10 </span></span><br><span class="line">    <span class="keyword">val</span> kmeans = <span class="keyword">new</span> <span class="type">KMeans</span>().setK(<span class="number">10</span>).setFeaturesCol(<span class="string">"feature"</span>).setPredictionCol(<span class="string">"prediction"</span>)</span><br><span class="line">   <span class="comment">//模型训练</span></span><br><span class="line">    <span class="keyword">val</span> model = kmeans.fit(train)</span><br><span class="line">    <span class="comment">//使用模型预测 测试数据</span></span><br><span class="line">    <span class="keyword">val</span> testResult = model.transform(test)</span><br><span class="line">    <span class="comment">//导入隐式转换，不然$"time"会出现错误 $ not e member of StringContext</span></span><br><span class="line">    <span class="keyword">import</span> spark.implicits._</span><br><span class="line">    <span class="keyword">val</span> time_prediction = testResult.select(substring($<span class="string">"time"</span>, <span class="number">0</span>, <span class="number">2</span>).alias(<span class="string">"hour"</span>), $<span class="string">"prediction"</span>)</span><br><span class="line">    time_prediction.groupBy(<span class="string">"hour"</span>,<span class="string">"prediction"</span>).agg((<span class="string">"prediction"</span>,<span class="string">"count"</span>)).orderBy(desc(<span class="string">"count"</span>)).filter(row=&gt;row.getAs(<span class="number">0</span>)==<span class="number">15</span>).take(<span class="number">10</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 大数据 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Flink </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Spark项目智慧城市车流量分析项目之固定卡口下车辆的行车轨迹]]></title>
      <url>/Spark%E9%A1%B9%E7%9B%AE%E6%99%BA%E6%85%A7%E5%9F%8E%E5%B8%82%E8%BD%A6%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E9%A1%B9%E7%9B%AE%E4%B9%8B%E5%9B%BA%E5%AE%9A%E5%8D%A1%E5%8F%A3%E4%B8%8B%E8%BD%A6%E8%BE%86%E7%9A%84%E8%A1%8C%E8%BD%A6%E8%BD%A8%E8%BF%B9.html</url>
      <content type="html"><![CDATA[<p>数据集</p>
<blockquote>
<ul>
<li>日期 卡口ID 摄像头编号 车牌号 拍摄时间</li>
<li>date monitor_id camera_id car action_time<br>车速 道路ID 区域ID<br>speed road_id area_id</li>
</ul>
</blockquote>
<a id="more"></a>
<p>模拟数据</p>
<blockquote>
<p>2018-06-27 0007 00536 京R66884 2018-06-27 11:30:25 30 41 08<br>2018-06-27 0005 01726 闵P89564 2018-06-27 09:34:03 19 7 03<br>2018-06-27 0005 01272 闵P89564 2018-06-27 09:50:39 187 19 05<br>2018-06-27 0002 00082 闵P89564 2018-06-27 09:34:47 1 28 05<br>2018-06-27 0003 08417 闵P89564 2018-06-27 09:23:05 171 42 02<br>2018-06-27 0003 02757 闵P89564 2018-06-27 09:52:35 32 50 04<br>2018-06-27 0000 03759 沪W87972 2018-06-27 20:02:43 243 25 05<br>2018-06-27 0002 08652 沪W87972 2018-06-27 20:05:10 51 11 05</p>
</blockquote>
<p>代码逻辑<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmnbtrp7kqj30nv0bvn0f.jpg" alt="在这里插入图片描述"></p>
<p>本地模拟代码</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.<span class="type">SparkConf</span>;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.api.java.<span class="type">JavaPairRDD</span>;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.api.java.<span class="type">JavaRDD</span>;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.api.java.<span class="type">JavaSparkContext</span>;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.api.java.function.<span class="type">Function</span>;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.api.java.function.<span class="type">PairFunction</span>;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.api.java.function.<span class="type">VoidFunction</span>;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.broadcast.<span class="type">Broadcast</span>;</span><br><span class="line"><span class="keyword">import</span> scala.<span class="type">Tuple2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Carlearn</span> </span>&#123;</span><br><span class="line">    public static void main(<span class="type">String</span>[] args) &#123;</span><br><span class="line">        <span class="type">SparkConf</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>();</span><br><span class="line">        conf.setMaster(<span class="string">"local"</span>).setAppName(<span class="string">"Carlearn"</span>);</span><br><span class="line">        <span class="type">JavaSparkContext</span> sc = <span class="keyword">new</span> <span class="type">JavaSparkContext</span>(conf);</span><br><span class="line">        <span class="type">JavaRDD</span>&lt;<span class="type">String</span>&gt; lineRDD = sc.textFile(<span class="string">"monitor_flow_action"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//mapToPair 形成一个tuple&lt;卡扣id,车牌号&gt;</span></span><br><span class="line">        <span class="type">JavaPairRDD</span>&lt;<span class="type">String</span>, <span class="type">String</span>&gt; rdd2 = lineRDD.mapToPair(<span class="keyword">new</span> <span class="type">PairFunction</span>&lt;<span class="type">String</span>, <span class="type">String</span>, <span class="type">String</span>&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            public <span class="type">Tuple2</span>&lt;<span class="type">String</span>, <span class="type">String</span>&gt; call(<span class="type">String</span> s) <span class="keyword">throws</span> <span class="type">Exception</span> &#123;</span><br><span class="line">                <span class="type">String</span>[] split = s.split(<span class="string">"\t"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">Tuple2</span>&lt;&gt;(split[<span class="number">1</span>], split[<span class="number">3</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//过滤只留下一个卡扣id为001的信息</span></span><br><span class="line">        <span class="type">JavaPairRDD</span>&lt;<span class="type">String</span>, <span class="type">String</span>&gt; rdd3 = rdd2.filter(<span class="keyword">new</span> <span class="type">Function</span>&lt;<span class="type">Tuple2</span>&lt;<span class="type">String</span>, <span class="type">String</span>&gt;, <span class="type">Boolean</span>&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            public <span class="type">Boolean</span> call(<span class="type">Tuple2</span>&lt;<span class="type">String</span>, <span class="type">String</span>&gt; tuple2) <span class="keyword">throws</span> <span class="type">Exception</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> tuple2._1.equals(<span class="string">"0001"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//map 形成一个个的car</span></span><br><span class="line">        <span class="type">JavaRDD</span>&lt;<span class="type">String</span>&gt; rdd4 = rdd3.map(<span class="keyword">new</span> <span class="type">Function</span>&lt;<span class="type">Tuple2</span>&lt;<span class="type">String</span>, <span class="type">String</span>&gt;, <span class="type">String</span>&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            public <span class="type">String</span> call(<span class="type">Tuple2</span>&lt;<span class="type">String</span>, <span class="type">String</span>&gt; tuple2) <span class="keyword">throws</span> <span class="type">Exception</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> tuple2._2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//去重</span></span><br><span class="line">        <span class="type">JavaRDD</span>&lt;<span class="type">String</span>&gt; rdd5 = rdd4.distinct();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//转换成集合</span></span><br><span class="line">        <span class="type">List</span>&lt;<span class="type">String</span>&gt; result = rdd5.collect();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//广播变量</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Broadcast</span>&lt;<span class="type">List</span>&lt;<span class="type">String</span>&gt;&gt; broadcast = sc.broadcast(result);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * mapToPair转换成Tuple&lt;车牌号,一行的值&gt;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">JavaPairRDD</span>&lt;<span class="type">String</span>, <span class="type">String</span>&gt; rddA = lineRDD.mapToPair(<span class="keyword">new</span> <span class="type">PairFunction</span>&lt;<span class="type">String</span>, <span class="type">String</span>, <span class="type">String</span>&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            public <span class="type">Tuple2</span>&lt;<span class="type">String</span>, <span class="type">String</span>&gt; call(<span class="type">String</span> s) <span class="keyword">throws</span> <span class="type">Exception</span> &#123;</span><br><span class="line">                <span class="type">String</span>[] split = s.split(<span class="string">"\t"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">Tuple2</span>&lt;&gt;(split[<span class="number">3</span>], s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//过滤掉只留下卡扣id为001信息的车,</span></span><br><span class="line">        <span class="type">JavaPairRDD</span>&lt;<span class="type">String</span>, <span class="type">Iterable</span>&lt;<span class="type">String</span>&gt;&gt; rddC = rddA.filter(<span class="keyword">new</span> <span class="type">Function</span>&lt;<span class="type">Tuple2</span>&lt;<span class="type">String</span>, <span class="type">String</span>&gt;, <span class="type">Boolean</span>&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            public <span class="type">Boolean</span> call(<span class="type">Tuple2</span>&lt;<span class="type">String</span>, <span class="type">String</span>&gt; tuple2) <span class="keyword">throws</span> <span class="type">Exception</span> &#123;</span><br><span class="line">                <span class="type">List</span>&lt;<span class="type">String</span>&gt; carList = broadcast.value();</span><br><span class="line">                <span class="type">String</span> carId = tuple2._2.split(<span class="string">"\t"</span>)[<span class="number">3</span>];</span><br><span class="line">                <span class="keyword">return</span> carList.contains(carId);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).groupByKey();</span><br><span class="line">        rddC.foreach(<span class="keyword">new</span> <span class="type">VoidFunction</span>&lt;<span class="type">Tuple2</span>&lt;<span class="type">String</span>, <span class="type">Iterable</span>&lt;<span class="type">String</span>&gt;&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            public void call(<span class="type">Tuple2</span>&lt;<span class="type">String</span>, <span class="type">Iterable</span>&lt;<span class="type">String</span>&gt;&gt; tuple2) <span class="keyword">throws</span> <span class="type">Exception</span> &#123;</span><br><span class="line">                <span class="type">Iterator</span>&lt;<span class="type">String</span>&gt; iterator = tuple2._2.iterator();</span><br><span class="line">                <span class="type">List</span>&lt;<span class="type">Tuple2</span>&lt;<span class="type">String</span>, <span class="type">String</span>&gt;&gt; map = <span class="keyword">new</span> <span class="type">ArrayList</span>&lt;&gt;();</span><br><span class="line">                <span class="comment">//将时间和卡扣号封装成一个list</span></span><br><span class="line">                <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                    <span class="type">String</span> next = iterator.next();</span><br><span class="line">                    <span class="type">String</span> time = next.split(<span class="string">"\t"</span>)[<span class="number">4</span>];</span><br><span class="line">                    <span class="type">String</span> kakouId = next.split(<span class="string">"\t"</span>)[<span class="number">1</span>];</span><br><span class="line">                    <span class="type">Tuple2</span>&lt;<span class="type">String</span>, <span class="type">String</span>&gt; time_kakou = <span class="keyword">new</span> <span class="type">Tuple2</span>&lt;&gt;(time, kakouId);</span><br><span class="line">                    map.add(time_kakou);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//通过时间排序,整理出汽车的行车轨迹</span></span><br><span class="line">                <span class="type">Collections</span>.sort(map, <span class="keyword">new</span> <span class="type">Comparator</span>&lt;<span class="type">Tuple2</span>&lt;<span class="type">String</span>, <span class="type">String</span>&gt;&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    public int compare(<span class="type">Tuple2</span>&lt;<span class="type">String</span>, <span class="type">String</span>&gt; o1, <span class="type">Tuple2</span>&lt;<span class="type">String</span>, <span class="type">String</span>&gt; o2) &#123;</span><br><span class="line">                        <span class="keyword">return</span> o1._1.compareTo(o2._1);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="comment">//打印下行车轨迹</span></span><br><span class="line">                <span class="type">String</span> chepai = tuple2._1;</span><br><span class="line">                <span class="type">System</span>.out.println(<span class="string">"汽车号:"</span>+chepai);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">Tuple2</span>&lt;<span class="type">String</span>, <span class="type">String</span>&gt; s : map) &#123;</span><br><span class="line">                    <span class="type">System</span>.out.print(<span class="string">"时间:"</span>+s._1+<span class="string">"卡扣:"</span>+s._2+<span class="string">"===&gt;"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">System</span>.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果</p>
<blockquote>
<p>06-27 22:39:26卡扣:0005===&gt;时间:2018-06-27 22:40:31卡扣:0008===&gt;时间:2018-06-27 22:41:37卡扣:0005===&gt;时间:2018-06-27 22:42:02卡扣:0000===&gt;时间:2018-06-27 22:43:07卡扣:0002===&gt;时间:2018-06-27 22:44:28卡扣:0004===&gt;时间:2018-06-27 22:45:49卡扣:0001===&gt;时间:2018-06-27 22:51:40卡扣:0005===&gt;时间:2018-06-27 22:53:26卡扣:0008===&gt;时间:2018-06-27 22:54:06卡扣:0007===&gt;时间:2018-06-27 22:57:26卡扣:0004===&gt;时间:2018-06-27 22:57:56卡扣:0005===&gt;时间:2018-06-27 22:58:07卡扣:0006===&gt;时间:2018-06-27 23:00:40卡扣:0006===&gt;时间:2018-06-27 23:01:56卡扣:0008===&gt;时间:2018-06-27 23:04:27卡扣:0004===&gt;时间:2018-06-27 23:04:43卡扣:0003===&gt;时间:2018-06-27 23:05:38卡扣:0001===&gt;时间:2018-06-27 23:09:03卡扣:0007===&gt;时间:2018-06-27 23:09:06卡扣:0005===&gt;时间:2018-06-27 23:09:37卡扣:0004===&gt;时间:2018-06-27 23:11:11卡扣:0007===&gt;时间:2018-06-27 23:12:06卡扣:0001===&gt;时间:2018-06-27 23:12:12卡扣:0008===&gt;时间:2018-06-27 23:14:31卡扣:0002===&gt;时间:2018-06-27 23:16:25卡扣:0007===&gt;时间:2018-06-27 23:23:47卡扣:0000===&gt;时间:2018-06-27 23:24:03卡扣:0008===&gt;时间:2018-06-27 23:26:27卡扣:0003===&gt;时间:2018-06-27 23:29:44卡扣:0001===&gt;时间:2018-06-27 23:30:23卡扣:0003===&gt;时间:2018-06-27 23:33:27卡扣:0007===&gt;时间:2018-06-27 23:34:18卡扣:0002===&gt;时间:2018-06-27 23:34:28卡扣:0002===&gt;时间:2018-06-27 23:34:39卡扣:0001===&gt;时间:2018-06-27 23:39:59卡扣:0005===&gt;时间:2018-06-27 23:45:13卡扣:0001===&gt;时间:2018-06-27 23:48:47卡扣:0004===&gt;<br>汽车号:京D44143<br>时间:2018-06-27 02:00:01卡扣:0007===&gt;时间:2018-06-27 02:00:59卡扣:0001===&gt;时间:2018-06-27 02:02:11卡扣:0008===&gt;时间:2018-06-27 02:02:29卡扣:0001===&gt;时间:2018-06-27 02:02:31卡扣:0001===&gt;时间:2018-06-27 02:04:11卡扣:0005===&gt;时间:2018-06-27 02:06:20卡扣:0000===&gt;时间:2018-06-27 02:07:36卡扣:0007===&gt;时间:2018-06-27 02:14:36卡扣:0004===&gt;时间:2018-06-27 02:14:58卡扣:0005===&gt;时间:2018-06-27 02:15:01卡扣:0007===&gt;时间:2018-06-27 02:15:14卡扣:0003===&gt;时间:2018-06-27 02:17:16卡扣:0005===&gt;时间:2018-06-27 02:20:59卡扣:0001===&gt;时间:2018-06-27 02:21:26卡扣:0008===&gt;时间:2018-06-27 02:21:27卡扣:0000===&gt;时间:2018-06-27 02:22:19卡扣:0004===&gt;时间:2018-06-27 02:26:20卡扣:0007===&gt;时间:2018-06-27 02:35:02卡扣:0002===&gt;时间:2018-06-27 02:35:28卡扣:0006===&gt;时间:2018-06-27 02:37:23卡扣:0001===&gt;时间:2018-06-27 02:38:13卡扣:0005===&gt;时间:2018-06-27 02:38:33卡扣:0002===&gt;时间:2018-06-27 02:39:15卡扣:0000===&gt;时间:2018-06-27 02:39:42卡扣:0008===&gt;时间:2018-06-27 02:41:53卡扣:0001===&gt;时间:2018-06-27 02:46:54卡扣:0007===&gt;时间:2018-06-27 02:47:23卡扣:0008===&gt;时间:2018-06-27 02:52:27卡扣:0001===&gt;时间:2018-06-27 02:53:31卡扣:0006===&gt;时间:2018-06-27 03:08:55卡扣:0007===&gt;<br>汽车号:京R34631<br>时间:2018-06-27 14:01:24卡扣:0004===&gt;时间:2018-06-27 14:03:36卡扣:0005===&gt;时间:2018-06-27 14:05:04卡扣:0006===&gt;时间:2018-06-27 14:08:40卡扣:0007===&gt;时间:2018-06-27 14:09:29卡扣:0002===&gt;时间:2018-06-27 14:09:51卡扣:0008===&gt;时间:2018-06-27 14:13:40卡扣:0008===&gt;时间:2018-06-27 14:18:55卡扣:0005===&gt;时间:2018-06-27 14:26:54卡扣:0001===&gt;时间:2018-06-27 14:27:20卡扣:0000===&gt;时间:2018-06-27 14:34:02卡扣:0001===&gt;时间:2018-06-27 14:34:39卡扣:0006===&gt;时间:2018-06-27 14:36:10卡扣:0003===&gt;时间:2018-06-27 14:37:08卡扣:0006===&gt;时间:2018-06-27 14:37:30卡扣:0003===&gt;时间:2018-06-27 14:39:25卡扣:0005===&gt;时间:2018-06-27 14:41:00卡扣:0007===&gt;时间:2018-06-27 14:42:03卡扣:0001===&gt;时间:2018-06-27 14:47:36卡扣:0001===&gt;时间:2018-06-27 14:48:16卡扣:0003===&gt;时间:2018-06-27 14:53:22卡扣:0001===&gt;时间:2018-06-27 14:53:34卡扣:0005===&gt;时间:2018-06-27 14:53:54卡扣:0001===&gt;时间:2018-06-27 14:53:56卡扣:0002===&gt;时间:2018-06-27 14:54:14卡扣:0003===&gt;时间:2018-06-27 14:55:44卡扣:0003===&gt;时间:2018-06-27 14:57:27卡扣:0006===&gt;时间:2018-06-27 14:57:53卡扣:0000===&gt;时间:2018-06-27 14:58:12卡扣:0008===&gt;时间:2018-06-27 14:59:11卡扣:0008===&gt;<br>汽车号:沪V82625</p>
</blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d3d3p5ZGNvbS9hcnRpY2xlL2RldGFpbHMvODQ5NDY5ODY/b3BzX3JlcXVlc3RfbWlzYz0mYW1wO3JlcXVlc3RfaWQ9JmFtcDtiaXpfaWQ9MTAyJmFtcDt1dG1fdGVybT0lRTglQkQlQTYlRTglQkUlODYlRTglQkQlQTglRTglQkYlQjklRTUlODglODYlRTYlOUUlOTAmYW1wO3V0bV9tZWRpdW09ZGlzdHJpYnV0ZS5wY19zZWFyY2hfcmVzdWx0Lm5vbmUtdGFzay1ibG9nLTJ+YWxsfnNvYmFpZHV3ZWJ+ZGVmYXVsdC04LTg0OTQ2OTg2LmZpcnN0X3JhbmtfdjJfcGNfcmFua192MjkmYW1wO3NwbT0xMDE4LjIyMjYuMzAwMS40MTg3" title="https://blog.csdn.net/wwwzydcom/article/details/84946986?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E8%BD%A6%E8%BE%86%E8%BD%A8%E8%BF%B9%E5%88%86%E6%9E%90&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-8-84946986.first_rank_v2_pc_rank_v29&amp;spm=1018.2226.3001.4187">转载至<i class="fa fa-external-link"></i></span></p>
]]></content>
      
        <categories>
            
            <category> 大数据 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> spark </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[基于WIFI探针的商业大数据分析系统（hadoop+spark+hbase+bootstrap+echarts）]]></title>
      <url>/%E5%9F%BA%E4%BA%8EWIFI%E6%8E%A2%E9%92%88%E7%9A%84%E5%95%86%E4%B8%9A%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E7%B3%BB%E7%BB%9F%EF%BC%88hadoop-spark-hbase-bootstrap-echarts%EF%BC%89.html</url>
      <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>服务端主要接收探针每三秒发送一次的数据，于接收端搭建Tomcat纵向集群，有效处理1300台以上的并发请求，将数据保存到数据分析平台待用，文件系统使用HDFS分布式文件系统。数据分析平台搭建于Linux系统，采用Spark&amp;Habse的分布式搭建模式，后台数据分析程序在3秒之内分析完实时数据，传至前台可视化，实现实时数据的展示。<br>作品较好的完成包括客流量、入店量、入店率、来访周期、新老顾客、顾客活跃度、驻店时长、来访周期、跳出率、深访率在内的九大基础指标的分析。并于前端页面上注重直观展示数据的变化趋势，数据分析所涉及的范围根据店铺具体情况支持自定义阕值。<br>对于探针功能的拓展：探针绑定短信模块，后台实现短信接口，从而对探针实现远程控制与状态监控。针对不同店铺大小推出小店铺探针，中性店铺三探针，大型店铺多探针模式，中型以上店铺支持定位，从而进一步分析呈现区域热点。<br>此外作品特色的添加了分析预测的功能，并基于分析预测功能结合历史数据智能的为商家提供商业决策支持，其中包括营销方案的推送，店铺排名波动的提醒功能。</p>
<a id="more"></a>
<h2 id="wifi探针数据分析"><a href="#wifi探针数据分析" class="headerlink" title="wifi探针数据分析"></a>wifi探针数据分析</h2><p>本项目实现的<strong>主要功能</strong>：</p>
<ol>
<li>通过探针设备采集可监测范围内的手机MAC地址、与探针距离、时间、地理位置等信息:</li>
<li>探针采集的数据可以定时发送到服务端保存:</li>
<li>利用大数据技术对数据进行人流量等指标的分析。最终以合理的方式展示数据处理结果。</li>
</ol>
<hr>
<h3 id="1、数据收集"><a href="#1、数据收集" class="headerlink" title="1、数据收集"></a>1、数据收集</h3><p><strong>数据收集</strong>由服务器和探针设备共同完成，探针采集数据并发送到服务器，服务器接收探针设备的数据，处理成定格式保存至分布式文件系统(HDFS)中，供数据处理使用。</p>
<p><strong>1.1 术语介绍:</strong></p>
<ul>
<li>STA: (station) 工作站，指手机或者电脑等连接WiFi的设备。</li>
<li>AP: (AcessPoint)接入点，指无线路由器等产生WiFi热点的设备。</li>
<li>SSID: ( Service Set dentifer)服务集标识，就是WiFi的名字。</li>
</ul>
<p><strong>1.2 探针采集数据的原理：</strong></p>
<p>在无线领域中STA总是不断试图寻找周边存在的AP,所以我们可以利用这种特性来发现一个未连接 AP的STA,而对于一个已经连接到AP的STA,也可以通过截狭它发出的数据帧来获取MAC、与探针之间的距离和它当前连接的SSID等信息。</p>
<hr>
<h3 id="2、数据清洗"><a href="#2、数据清洗" class="headerlink" title="2、数据清洗"></a>2、数据清洗</h3><p>探针上传的数据是一种<strong>半结构化数据</strong>，主要格式参数如下：</p>
<ul>
<li>id：嗅探设备ID</li>
<li>mmac：嗅探器设备自身Wifi MAC</li>
<li>rate：发送频率</li>
<li>wssid：嗅探器设备连接的WiFi的MAC地址</li>
<li>time：时间戳，采集这些MAC的时间</li>
<li>lat：纬度   lon：经度</li>
<li>addr：地址</li>
<li>mac：采集到的手机的MAC地址</li>
<li>rssi：手机的信号强度</li>
<li>range：手机距离嗅探设备的距离</li>
<li>ts：目标ssid，手机连接的WiFi的ssid</li>
<li>tmc：手机连接的WiFi的地址</li>
<li>tc：是否与路由器连接</li>
<li>ds：手机是否睡眠</li>
<li>essidn：曾今连接的WiFi的SSID</li>
</ul>
<p>该数据属于半结构化数据，<strong>其中包含</strong>探针设备ID,设备自身WFIMAC,发送频率，设备连接的WFi的SID设备连接的WFI的MAC地址、时间戳，采集到这些MAC的时间、纬度、经度、地址信息，以及一组被探测到的设备信息， 设备信息包括手机的MAC、信号强度、与探针之间的距离、手机连接WiFi的SID手机连接的WFI的MAC地址、手机曾经连接过的WiFi的SSID。需要在清洗过程中去除所有无用的数据，使之<strong>变成结构化的文件</strong>，到这里数据清洗的<strong>第一步</strong>就完成了。</p>
<p><strong>第二步</strong>使用Spark SQL完成，在这一步中<strong>完成时间点到时间段的转化</strong>，即在处理之前每一条记录表示一个终端在某 一时间点的状态，而在结果中一条记录表示一 个终端在一段时间内的状态。</p>
<p><strong>经过数据清洗，不仅大大减小了数据集的容量，也为后续的数据处理提供了极大的方便。</strong></p>
<hr>
<h3 id="3、数据保存"><a href="#3、数据保存" class="headerlink" title="3、数据保存"></a>3、数据保存</h3><ol>
<li><strong>处理后的数据直接保存为文本文件，保存在HDFS中。</strong></li>
<li><strong>处理后的数据导入关系型数据库，供后续生成图表使用，该展示系统使用PHP做后台，前端使用HTML和JS生成图表。</strong></li>
</ol>
<hr>
<h3 id="4、客流数据分析"><a href="#4、客流数据分析" class="headerlink" title="4、客流数据分析"></a>4、客流数据分析</h3><p><strong>4.1 数据表设计</strong></p>
<p><strong>1、HDFS中是原始数据集</strong>：（<strong>data表</strong>，通过Spark SQL得到）</p>
<p><strong>原始数据data 表主要字段:</strong></p>
<ul>
<li>tanzhen_id：探针设备的id</li>
<li>mac：用户设备的MAC.（不同的mac代表不同客户）</li>
<li>time：探测到当前设备的时间</li>
<li>range：该设备与探什之间的距离</li>
</ul>
<p><strong>2、visit表</strong>（取出同一mac所有数据，按照time遍历，得到每一个用户的每一次访问记录）</p>
<p><strong>visit表主要字段：</strong></p>
<ul>
<li>mac：标识不同用户</li>
<li>start_time：用户入店时间</li>
<li>leave_time：用户离店时间</li>
<li>stay_time：用户停留时间</li>
</ul>
<p><strong>思路</strong>：data表首先抽取每一个用户（MAC）的数据，对每个用户数据进行遍历，得到每个用户每一次的访问记录。通过visit表得到：客流量、入店率，来访周期，新老顾客，顾客活跃度等等。</p>
<p><strong>原始数据表</strong>是数据接收服务器最终存储到HDFS中的数据，<strong>中间结果表</strong>是经过第2次收据清洗后的输出结果。</p>
<p><strong>上传数据到HDFS</strong>（因为是用python等语言处理过的，所以传的数据格式为只提取有用的数据）</p>
<p><strong>timeArray</strong>有四个time是因为时间格式划分为四块。</p>
<p><strong>4.2 指标说明</strong></p>
<p>上面我们完成了数据的初步处理，我们将得到<strong>以下指标</strong>:</p>
<ul>
<li><strong>客流量</strong>:店铺或区域整体客流及趋势。</li>
<li><strong>入店量</strong>:进入店铺或区域的客流及趋势。</li>
<li><strong>入店率</strong>:进入店铺或区域的客流占全部客流的比例及趋势。来访周期:进入店铺或区域的顾客距离上次来店的间隔。</li>
<li><strong>来访周期</strong> : 进入店铺或区域的顾客距离上次来店的问隔。</li>
<li><strong>新老顾客</strong>:一定时间段内首次/两次以上进入店铺的顾客。</li>
<li><strong>顾客活跃度</strong>:按顾客距离上次来访间隔划分为不同活跃度(高活跃度、中活跃度、低活跃度、沉睡活跃度) .</li>
<li><strong>驻店时长</strong>:进店铺的顾客在店内的停留时长，</li>
<li><strong>跳出率</strong>:进店铺后很快离店的顾客及占比(占总体客流) .</li>
<li><strong>深访率</strong>:进店铺深度访问的顾客及占比(占总体客流，可以根据定位轨迹或者停留时长判定).</li>
</ul>
<p><strong>店铺外人流/客流量：</strong>在实时接收探针数据过程中根据range字段(范围)以及数据条数实时得到。</p>
<p><strong>入店量/离店量：</strong>是对visit表分别按start_time、 leave_time字段从小到大遍历统计规定时间段内的记录条数。</p>
<p><strong>跳出率/深访率/驻店时长：</strong>对visit 表按time字段从小到大遍历统计规定时间段内记录条数<strong>stay_time小于三分钟</strong>和<strong>大于20分钟的记录条数</strong>以及<strong>stay_time均值</strong>。</p>
<p><strong>新老顾客数/顺客活跃度：</strong>对visit表按time字段排序，按一定定时间段遍历，新顾客收等于该时间段结束时刻之前所有的顺客数减去该时间段开始时刻之前所有的顾客数，老顾客数等于该时间段内顾客数减去新顾客数。</p>
<p><strong>4.3 spark源码如下：</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.victor.spark.<span class="type">WiFiData</span></span><br><span class="line"><span class="keyword">package</span> com.victor.spark.<span class="type">WifiProject</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.<span class="type">SparkSession</span></span><br><span class="line"><span class="keyword">import</span> scala.util.control.<span class="type">Breaks</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">new_customer_extract</span> </span>&#123;        <span class="comment">// 实例化类</span></span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;        <span class="comment">// 主方法--入口（Unit无返回值）</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">val</span> spark = <span class="type">SparkSession</span>.builder().appName(<span class="string">"customer_extract"</span>).config(</span><br><span class="line">      <span class="string">"spark.some.config.option"</span>,<span class="string">"some-values"</span>).getOrCreate()     <span class="comment">// 变量1（不可改变）</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">import</span> java.io._</span><br><span class="line">    <span class="keyword">val</span> writer = <span class="keyword">new</span> <span class="type">PrintWriter</span>(<span class="keyword">new</span> <span class="type">File</span>(<span class="string">"/spark/data/re.txt"</span>))  <span class="comment">//for the storage of result</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">import</span> spark.implicits._</span><br><span class="line">    <span class="keyword">val</span> df = spark.read.json(<span class="string">"/spark/data/log.json"</span>)    <span class="comment">//read the data</span></span><br><span class="line">    <span class="comment">//create the view data for df</span></span><br><span class="line">    df.createOrReplaceTempView(<span class="string">"data"</span>)</span><br><span class="line">    spark.sql(<span class="string">"cache table data"</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//get all MAC of all users</span></span><br><span class="line">    <span class="keyword">val</span> macArray = spark.sql(<span class="string">"SELECT DISTINCT mac FROM data"</span>).collect()</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">var</span> i =<span class="number">0</span></span><br><span class="line">    <span class="keyword">val</span> inner = <span class="keyword">new</span> <span class="type">Breaks</span></span><br><span class="line">    <span class="keyword">val</span> lenth = macArray.length</span><br><span class="line">    <span class="comment">//loop for each user</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;lenth)&#123;</span><br><span class="line">      <span class="keyword">var</span> resultString = <span class="string">""</span></span><br><span class="line">      <span class="keyword">var</span> mac = macArray(i)(<span class="number">0</span>)</span><br><span class="line">      <span class="keyword">val</span> sql = <span class="string">"SELECT 'time' from data where mac='"</span>+mac+<span class="string">"'order by 'time'"</span></span><br><span class="line">      <span class="keyword">val</span> timeArray = spark.sql(sql).collect()</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//to get timeList from timeArray</span></span><br><span class="line"> </span><br><span class="line">      <span class="keyword">import</span> scala.collection.mutable.<span class="type">ListBuffer</span></span><br><span class="line">      <span class="keyword">var</span> timeList = <span class="keyword">new</span> <span class="type">ListBuffer</span>[<span class="type">Int</span>]</span><br><span class="line">      <span class="keyword">var</span> list_length = timeArray.length</span><br><span class="line">      <span class="keyword">var</span> j = <span class="number">0</span></span><br><span class="line"> </span><br><span class="line">      <span class="keyword">while</span> (j &lt; list_length)&#123;</span><br><span class="line">        timeList += timeArray(i)(<span class="number">0</span>).toString.toInt</span><br><span class="line">        j = j+<span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">var</span> k = <span class="number">0</span></span><br><span class="line">      <span class="keyword">var</span> oldTime = <span class="number">0</span></span><br><span class="line">      <span class="keyword">var</span> newTime = <span class="number">0</span></span><br><span class="line"> </span><br><span class="line">      <span class="keyword">var</span> maxVisitTimeInterval = <span class="number">300</span></span><br><span class="line">      <span class="keyword">var</span> startTime = <span class="number">0</span></span><br><span class="line">      <span class="keyword">var</span> leaveTime = <span class="number">0</span></span><br><span class="line"> </span><br><span class="line">      <span class="keyword">while</span> (k &lt; list_length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>)&#123;</span><br><span class="line">          oldTime = timeList(<span class="number">0</span>)</span><br><span class="line">          newTime = timeList(<span class="number">0</span>)</span><br><span class="line">          startTime = timeList(<span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(k == (list_length - <span class="number">1</span>))&#123;</span><br><span class="line">          leaveTime = timeList(k)</span><br><span class="line">          <span class="keyword">var</span> stayTime = leaveTime - startTime</span><br><span class="line">          resultString += <span class="string">""</span><span class="string">"&#123;"</span><span class="string">mac":"</span><span class="string">""</span><span class="string">" + mac + "</span><span class="string">""</span>,<span class="string">""</span><span class="string">" +"</span><span class="string">""</span><span class="string">"in_time"</span>:<span class="string">""</span><span class="string">"+startTime+"</span>,<span class="string">"+"</span><span class="string">""</span><span class="string">"out_time"</span>:<span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">          +leaveTime+"</span>,<span class="string">"+"</span><span class="string">""</span><span class="string">"stay_Time"</span>:<span class="string">""</span><span class="string">"+stayTime+"</span>&#125;\<span class="string">n"</span></span><br><span class="line"><span class="string">        &#125;else&#123;</span></span><br><span class="line"><span class="string">          newTime = timeList(k)</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">          if ((newTime - oldTime) &gt; maxVisitTimeInterval)&#123;</span></span><br><span class="line"><span class="string">            leaveTime = oldTime</span></span><br><span class="line"><span class="string">            var stayTime = leaveTime-startTime</span></span><br><span class="line"><span class="string">            resultString += "</span><span class="string">""</span>&#123;<span class="string">"mac"</span>:<span class="string">""</span><span class="string">""</span> + mac + <span class="string">""</span><span class="string">","</span><span class="string">""</span> +<span class="string">""</span><span class="string">""</span>in_<span class="string">time":"</span><span class="string">""</span>+startTime+<span class="string">","</span>+<span class="string">""</span><span class="string">""</span>out_<span class="string">time":"</span><span class="string">""</span></span><br><span class="line">            +leaveTime+<span class="string">","</span>+<span class="string">""</span><span class="string">""</span>stay_T<span class="string">ime":"</span><span class="string">""</span>+stayTime+<span class="string">"&#125;\n"</span></span><br><span class="line"> </span><br><span class="line">            startTime = newTime</span><br><span class="line">            oldTime = newTime</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            oldTime = newTime</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        k = k +<span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      writer.write(resultString)</span><br><span class="line"> </span><br><span class="line">      i = i+<span class="number">1</span>      </span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    writer.close()</span><br><span class="line">    spark.sql(<span class="string">"uncache table data"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="———————"><a href="#———————" class="headerlink" title="———————"></a>———————</h3><p><span class="exturl" data-url="Z2l0aHViOmh0dHBzOi8vZ2l0aHViLmNvbS9yYWlubWFwbGUvV0lGSV9CdXNzaW5lc3NCaWdEYXRhQW5hbHlzZVN5c3RlbQ==" title="github:https://github.com/rainmaple/WIFI_BussinessBigDataAnalyseSystem">项目地址<i class="fa fa-external-link"></i></span></p>
<p><strong>原文地址：</strong><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3JhaW5tYXBsZTIwMTg2L2FydGljbGUvZGV0YWlscy84MDM0MDE0MA==" title="https://blog.csdn.net/rainmaple20186/article/details/80340140">https://blog.csdn.net/rainmaple20186/article/details/80340140<i class="fa fa-external-link"></i></span></p>
]]></content>
      
        <categories>
            
            <category> 大数据 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> spark </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[基于云计算和大数据的模拟车辆行车监控系统]]></title>
      <url>/%E5%9F%BA%E4%BA%8E%E4%BA%91%E8%AE%A1%E7%AE%97%E5%92%8C%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9A%84%E6%A8%A1%E6%8B%9F%E8%BD%A6%E8%BE%86%E8%A1%8C%E8%BD%A6%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F.html</url>
      <content type="html"><![CDATA[<h2 id="一、-系统架构"><a href="#一、-系统架构" class="headerlink" title="一、 系统架构"></a>一、 系统架构</h2><p>这是基于云计算和大数据的模拟车辆行车监控系统，可模拟实现在线远程对车辆行车的信息记录以及数据处理。其中，记录信息其中包括车辆的id、经过的地点（经纬度）、时间，数据处理包括对数据的排序、错误数据的排查、通过时间以及地点在地图上获得车辆行驶的轨迹、车辆相遇次数。</p>
<p>系统包括数据产生模块、数据接受与处理模块、数据库模块、客户端模块。其中kafka进行数据的接收,并进行数据过滤，将过滤后的数据传递给Redis，Redis再将数据存入Hbase数据库，Spark从Hbase中获得数据，将处理后的数据再传递回Hbase，客户端从Hbase中获得数据并将其展示在前端。</p>
<a id="more"></a>
<p>逻辑架构如下：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmkxcgq24ij30oe0h6aad.jpg" alt="这里写图片描述"><br>物理架构图如下：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmkxcjdp0aj30q00dkwfl.jpg" alt="img"></p>
<h2 id="二、数据流程分析"><a href="#二、数据流程分析" class="headerlink" title="二、数据流程分析"></a>二、数据流程分析</h2><h4 id="1-数据采集过程分析"><a href="#1-数据采集过程分析" class="headerlink" title="1. 数据采集过程分析"></a>1. 数据采集过程分析</h4><p>数据采集过程包括<strong>Kafka数据采集、Redis数据过滤、Hbase数据入库</strong>三部分，其中包括三个实体：Kafka生产者、Kafka消费者兼Redis发布者、Redis订阅者。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmkxclzrezj30ox0gu0tx.jpg" alt="数据采集"><br><strong>各自的作用如下：</strong><br>Kafka生产者：负责从json文件中以行为单位读取数据源，通过Kafka生产者代码编写生产消息，将json读取的消息发布在topic上。</p>
<p>Kafka消费者兼Redis发布者：负责从topic上消费Kafka生产者生产的消息，将消息通过Redis发布订阅功能发布到一个信道，等待订阅者接受消息。</p>
<p>Redis订阅者：负责订阅发布者相应的信道，接受发布者的消息，将消息存入Hbase数据库。<br>数据过滤过程使用了Kafka streams对原始数据进行过滤，本小组采用HIGH-LEVEL STREAMS DSL进行处理。Kafka创建一个Filter流，流的源绑定filter-before topic，同时Kafka生成者将消息生产在这个topic上；流的出口绑定filter-after topic，Kafka消费者绑定这个topic消费消息。过滤器消息选择条件过滤掉不正确的经纬度数据，并将这部分数据存放在Redis filter 键里，合格的数据传送到filter-after topic上。</p>
<p><strong>Redis的缓冲作用</strong><br>在Redis订阅者上，由于生产者生产消息过快，如果选择一条一条的存入数据库，会出现存取数据过慢，导致生产者的消息经过规定的时间(本小组设置的时间是90秒)没有被消费，报出Timeout错误。为避免这样的问题，选择每1000条数据存入数据库一次，这样的方式优点在于每1000条数据才请求连接数据库一次。请求连接数据库是较耗时的一个步骤，频繁的请求连接数据库会拖慢程序的运行时长。在基础项时，选择将所有数据存入list，然后一次请求数据库连接，将所有数据存入数据库，请求数据库连接的时间占比很小。</p>
<p><strong>出现的问题以及解决方案</strong><br>1000条数据一次存入无法达到实时的记录，这是本小组项目的一个缺点，但同时，这个问题可以通过选择storm 流式框架数据处理来解决，直接在Kafka消费阶段对数据进行流式处理能达到实时效果。</p>
<h4 id="2-数据查询和离线处理分析"><a href="#2-数据查询和离线处理分析" class="headerlink" title="2.数据查询和离线处理分析"></a>2.数据查询和离线处理分析</h4><p>数据查询：数据采集完成，所有数据存入Hbase数据库的‘Record’表中，行键设计为eid、placeid、time组合键，在数据查询时，需要将行键截取，获取对应的数据，与查询条件比较，返回满足条件的数据。</p>
<p>spark处理：spark分析过程包含三个阶段——程序源码发布到master节点、master将map程序分配给map节点进行map操作、master将reduce程序分配给reduce节点进行reduce操作。数据流向是map节点从master节点获取Hbase数据索引，进而获取数据，接着运行map程序将数据分散处理。Map程序处理完的数据流入reduce进行聚合处理，最后将reduce结果存入Hbase数据库中。<br>问题：在进行spark分析时，限于物理机，整个集群仅有一个master节点、一个map worker节点、一个reduce worker节点，在数据分析时出现的情况是map worker节点的工作任务量远远大于reduce worker的工作任务量。在任务启动时，集群中各个节点使用top命令查看当前节点的CPU占比，发现在整个任务中map worker 节点长时间高CPU占比工作，而reduce worker节点在map worker节点处理完成后有10秒左右的高CPU占比工作期，然后整个数据分析完成。鉴于上述的问题，考虑在主机充足的情况下，选择为map任务分配多台主机。使得任务执行量较均匀分布。</p>
<h2 id="三、软件功能分析"><a href="#三、软件功能分析" class="headerlink" title="三、软件功能分析"></a>三、软件功能分析</h2><h4 id="1、完成基本搭建系统，完成过车统计功能"><a href="#1、完成基本搭建系统，完成过车统计功能" class="headerlink" title="1、完成基本搭建系统，完成过车统计功能"></a>1、完成基本搭建系统，完成过车统计功能</h4><p>系统可根据输入的地点ID进行检索，显示通过该地点的车辆ID、时间、地点以及经纬度；或者根据输入的车辆ID，显示出该车辆经过的地点、经过时间以及对应地点的经纬度。<br>结果展示：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmkxcpxot7j311y0lcn0w.jpg" alt="这里写图片描述"></p>
<h4 id="2-系统附加功能分析"><a href="#2-系统附加功能分析" class="headerlink" title="2.系统附加功能分析"></a>2.系统附加功能分析</h4><h5 id="（1）原始信息过滤"><a href="#（1）原始信息过滤" class="headerlink" title="（1）原始信息过滤"></a>（1）原始信息过滤</h5><p>原始数据包含若干条错误记录，如经纬度不合法等，需要实时对kafka中接收到的数据进行过滤处理，将处理后的数据传递给Redis。<br><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmkxd7eqdzj311y0lc0ww.jpg" alt="这里写图片描述"></p>
<h5 id="（2）车辆行驶轨迹重现"><a href="#（2）车辆行驶轨迹重现" class="headerlink" title="（2）车辆行驶轨迹重现"></a>（2）车辆行驶轨迹重现</h5><p><em>实现方式：我们想出了两种方法实现其轨迹重新。</em><br>A、hbase方式<br>建立一张新表，重新编排行键。<br>在hbaseTest类中完成具体操作。首先使用HBaseConf类中的getConnection()方法与HBase数据库进行连接。然后利用HBaseConf类中getTableByName()方法得到对表“Record”表的操作句柄。同时使用相同的方法得到对Trace表的操作句柄。之后，使用Table类中的getScanner（）方法得到Record表中的所有数据，并记录中“result”中。因为重现轨迹的时候只需要车辆的标识信息（Eid）和车辆经过的时间（time）和经过地方的经纬度（latitude，longitude）所以我们只需要在“Trace”表中存入这些数据即可。<br>现在我们已经将得到的所有的“Record”表中的数据都存在了“result”中。然后将result中的所有数据扫描一遍，同时将每条记录中的“Eid,time,latitude,longitude”信息记录下来，同时将每一条记录的这些信息作为新的一条记录，以“Eid”为rowKey且以“time”为列族的第一列放在Put类的对象中，最后通过Table类的put()方法将新的记录存在“Trace”表中。这样得到的“Trace”表中的数据即会以“time”自动排序。<br>当所有数据被读取并被重新放入“Trace”表中后，关闭与数据库的连接，所有的信息即被重新规划好。</p>
<p>B、spark的MapReduce方式<br>展示结果：<br>输入要查询的车辆的ID，显示其行驶轨迹。鼠标点击地点，可显示其经纬度。</p>
<p>轨迹展示结果：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmkxctmtm7j311y0lc109.jpg" alt="这里写图片描述"></p>
<h5 id="（3）车辆相遇次数统计"><a href="#（3）车辆相遇次数统计" class="headerlink" title="（3）车辆相遇次数统计"></a>（3）车辆相遇次数统计</h5><p>我们定义相遇为“两车之间出现在同一地点的时间间隔小于一分钟”。<br>首先，通过Spark从Hbase表中读取数据，自身以地点为键进行join操作，计算除自身外的车辆是否相遇；再以地点为键进行分组，同一组内的数据按照时间进行排序，遍历整个列表，找出满足小于一分钟的数据。</p>
<p><em>结果展示</em>：<br>输入要查询的车辆Id，查询结果显示与之相遇过的车辆的ID以及次数。<br><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmkxcwzwtmj311y0lcqca.jpg" alt="这里写图片描述"></p>
]]></content>
      
        <categories>
            
            <category> 大数据 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> spark </tag>
            
            <tag> hbase </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Spark项目落地实战以及日常大数据开发注意事项]]></title>
      <url>/Spark%E9%A1%B9%E7%9B%AE%E8%90%BD%E5%9C%B0%E5%AE%9E%E6%88%98%E4%BB%A5%E5%8F%8A%E6%97%A5%E5%B8%B8%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9.html</url>
      <content type="html"><![CDATA[<p>Spark简介 </p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmks7g9ip7j30fa0770tg.jpg" alt="img"></p>
<a id="more"></a>
<p>基于内存的分布式集群计算平台</p>
<p>可适配 Python、Java、Scala、SQL</p>
<p>拓展功能：机器学习、流式计算、图计算</p>
<p>Spark特点 </p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmks7iy2qnj30fa08nju4.jpg" alt="img"></p>
<p>高效 </p>
<ul>
<li>内存计算引擎</li>
<li>DAG图</li>
<li>比MapReduce快10～100倍</li>
</ul>
<h4 id="易用"><a href="#易用" class="headerlink" title="易用"></a>易用</h4><ul>
<li>提供丰富的API，支持Java，Scala， Python</li>
<li>代码量小</li>
</ul>
<h4 id="与Hadoop集成"><a href="#与Hadoop集成" class="headerlink" title="与Hadoop集成"></a>与Hadoop集成</h4><ul>
<li>读写HDFS、Hbase、Hive</li>
<li>和Yarn集成</li>
</ul>
<p>与Oracle存过的对比 </p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmks7lcf7aj30fa03sgmk.jpg" alt="img"></p>
<p>Spark应用场景 </p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmks7p5ynzj30fa078glw.jpg" alt="img"></p>
<ul>
<li>数据仓库</li>
<li>机器学习</li>
<li>海量数据离线分析</li>
<li>实时数据流处理</li>
</ul>
<p>基本概念 </p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmks7scd41j30fa07640c.jpg" alt="img"></p>
<p>集群架构 </p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmks7vircej30fa09a750.jpg" alt="img"></p>
<ul>
<li>集群资源管理器（Cluster Manager）</li>
<li>运行作业任务的工作节点（Worker Node）</li>
<li>每个应用的任务控制节点（Driver）</li>
<li>每个工作节点上负责具体任务的执行进程 （Executor）</li>
<li>资源管理器Mesos或YARN</li>
</ul>
<p>任务执行流程 </p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmks7ygkecj30fa09sta6.jpg" alt="img"></p>
<ol>
<li>首先为应用构建起基本的运行环境，即由 Driver创建一个SparkContext，进行资源 的申请、任务的分配和监控</li>
<li>资源管理器为Executor分配资源，并启动 Executor进程</li>
<li>SparkContext根据RDD的依赖关系构建 DAG图，DAG图提交给DAGScheduler解 析成Stage，然后把一个个TaskSet提交给 底层调度器TaskScheduler处理； Executor向SparkContext申请Task，Task Scheduler将Task发放给Executor运行， 并提供应用程序代码</li>
<li>Task在Executor上运行，把执行结果反馈 给TaskScheduler，然后反馈给 DAGScheduler，运行完毕后写入数据并 释放所有资源。</li>
</ol>
<p>数据处理过程 </p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmks81s5qnj30fa05574q.jpg" alt="img"></p>
<ol>
<li>读入外部数据源</li>
<li>转换算子进行数据处理</li>
<li>动作算子进行处理流程触发</li>
<li>处理完成输出结果</li>
</ol>
<p>常用算子-转换 </p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmks842uowj30fa07bq5d.jpg" alt="img"></p>
<p>开发案例–集团电信三码低效资产分析 </p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmks86w7u9j30fa08cac6.jpg" alt="img"></p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmks89mfdaj30fa08k40z.jpg" alt="img"></p>
<p>Spark很香、也很坑</p>
<p>坑1：无法自定义自增序列</p>
<p>坑2：Spark Stage之间的血缘冗长</p>
<p>坑3：直连Oracle读取慢</p>
<p>坑4：时间格式支持不友好</p>
<p>常见问题1-无法自定义自增序列 </p>
<p>问题阐述：</p>
<p>在不同的业务逻辑中，由于会存在多种维度的分析，但是他们的结果是写入到同一张表格中的。在oracle中执行的时候是根据oracle中定义的序列来保证ID的唯一性，但是 我们代码实现的时候采用的数据加载模式时无法加载oracle中的序列，并且读取序列也会收到oracle序列缓冲的影响。所以在业务逻辑处理上我们得自己定义一个属于我们 业务的ID序列，并且需要保证唯一性。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmks8dail0j30fa0csjvb.jpg" alt="img"></p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmks8g81p6j30fa0chq75.jpg" alt="img"></p>
<p>常见问题2-血缘关系冗长 </p>
<p>问题阐述：</p>
<p>由于SparkSQL在解析成ATS树时会向上追溯血缘并重复解析，且随着血缘关系的增长ATS树会变的越来越复杂，导致任务执行效率会严重降低。具体表象为 Spark任务在执行过程中会卡住不动，程序继续卡顿几个小时之后才会开始继续运行。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmks8j994gj30fa07rta1.jpg" alt="img"></p>
<p>方案一：checkpoints方式切割方式</p>
<p>方案二：hdfs落地，使用时二次读取</p>
<p>常见问题3-读Oracle速率慢 </p>
<p>问题阐述：</p>
<p>在读取Oracle时，数据表未做分区，程序无法通过指定分区并行加载数据，且为了减小数据库IO压力，采用限制高频、数据读取限制等策略，导致读取Oracle速 率很慢，影响计算效率。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmks8lykeaj30fa0enwkb.jpg" alt="img"></p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmks8p5bh0j30fa0cc78s.jpg" alt="img"></p>
<p>常见问题4-Oracle时间格式支持不友好 </p>
<p>问题阐述：</p>
<p>park在读写Oracle时date类型数据容易丢失精度，例如： Oracle中 2019-12-20 05:44:30读取后为2019-12-20， Spark中2019-12-20 05:44:30写入后变成2019-12-20 00:00:00</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmks8sw7yuj30fa0bc456.jpg" alt="img"></p>
<p>解决方案：</p>
<p>Oracle方言,即自定义一种数据库解释语言，实际上的实现 为数据的类型转换。OracleDateTypeInit.oracleInit()</p>
]]></content>
      
        <categories>
            
            <category> 大数据 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> spark </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Elasticsearch查询速度为什么这么快？]]></title>
      <url>/Elasticsearch%E6%9F%A5%E8%AF%A2%E9%80%9F%E5%BA%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB%EF%BC%9F.html</url>
      <content type="html"><![CDATA[<p>ES 是基于 Lucene 的全文检索引擎，它会对数据进行分词后保存索引，擅长管理大量的索引数据，相对于 MySQL 来说不擅长经常更新数据及关联查询。</p>
<p>说的不是很透彻，没有解析相关的原理;不过既然反复提到了索引，那我们就从索引的角度来对比下两者的差异。</p>
<a id="more"></a>
<h4 id="MySQL-索引"><a href="#MySQL-索引" class="headerlink" title="MySQL 索引"></a>MySQL 索引</h4><p>先从 MySQL 说起，索引这个词想必大家也是烂熟于心，通常存在于一些查询的场景，是典型的空间换时间的案例。以下内容以 InnoDB 引擎为例。</p>
<h4 id="常见的数据结构"><a href="#常见的数据结构" class="headerlink" title="常见的数据结构"></a>常见的数据结构</h4><p>假设由我们自己来设计 MySQL 的索引，大概会有哪些选择呢?</p>
<h4 id="①散列表"><a href="#①散列表" class="headerlink" title="①散列表"></a>①散列表</h4><p>首先我们应当想到的是散列表，这是一个非常常见且高效的查询、写入的数据结构，对应到 Java 中就是 HashMap。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmkri4j2a9j30fa09udfu.jpg" alt="img"></p>
<p>这个数据结构应该不需要过多介绍了，它的写入效率很高 O(1)，比如我们要查询 id=3 的数据时，需要将 3 进行哈希运算，然后再这个数组中找到对应的位置即可。</p>
<p>但如果我们想查询 1≤id≤6 这样的区间数据时，散列表就不能很好的满足了，由于它是无序的，所以得将所有数据遍历一遍才能知道哪些数据属于这个区间。</p>
<h4 id="②有序数组"><a href="#②有序数组" class="headerlink" title="②有序数组"></a>②有序数组</h4><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmkri9o3ktj30fa03ujr9.jpg" alt="img"></p>
<p>有序数组的查询效率也很高，当我们要查询 id=4 的数据时，只需要通过二分查找也能高效定位到数据 O(logn)。</p>
<p>同时由于数据也是有序的，所以自然也能支持区间查询;这么看来有序数组适合用做索引咯?</p>
<p>自然是不行，它有另一个重大问题;假设我们插入了 id=2.5 的数据，就得同时将后续的所有数据都移动一位，这个写入效率就会变得非常低。</p>
<h4 id="③平衡二叉树"><a href="#③平衡二叉树" class="headerlink" title="③平衡二叉树"></a>③平衡二叉树</h4><p>既然有序数组的写入效率不高，那我们就来看看写入效率高的，很容易就能想到二叉树。</p>
<p>这里我们以平衡二叉树为例：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmkricx1nrj30fa07p74c.jpg" alt="img"></p>
<p>由于平衡二叉树的特性：左节点小于父节点、右节点大于父节点。</p>
<p>所以假设我们要查询 id=11 的数据，只需要查询 10→12→11 便能最终找到数据，时间复杂度为 O(logn)，同理写入数据时也为 O(logn)。</p>
<p>但依然不能很好的支持区间范围查找，假设我们要查询 5≤id≤20 的数据时，需要先查询 10 节点的左子树再查询 10 节点的右子树最终才能查询到所有数据。导致这样的查询效率并不高。</p>
<h4 id="④跳表"><a href="#④跳表" class="headerlink" title="④跳表"></a>④跳表</h4><p>跳表可能不像上边提到的散列表、有序数组、二叉树那样日常见的比较多，但其实 Redis 中的 sort set 就采用了跳表实现。这里我们简单介绍下跳表实现的数据结构有何优势。</p>
<p>我们都知道即便是对一个有序链表进行查询效率也不高，由于它不能使用数组下标进行二分查找，所以时间复杂度是 o(n)。</p>
<p>但我们也可以巧妙的优化链表来变相的实现二分查找，如下图：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmkrig6k32j30fa05jweh.jpg" alt="img"></p>
<p>我们可以为最底层的数据提取出一级索引、二级索引，根据数据量的不同，我们可以提取出 N 级索引。当我们查询时便可以利用这里的索引变相的实现了二分查找。</p>
<p>假设现在要查询 id=13 的数据，只需要遍历 1→7→10→13 四个节点便可以查询到数据，当数越多时，效率提升会更明显。</p>
<p>同时区间查询也是支持，和刚才的查询单个节点类似，只需要查询到起始节点，然后依次往后遍历(链表有序)到目标节点便能将整个范围的数据查询出来。</p>
<p>同时由于我们在索引上不会存储真正的数据，只是存放一个指针，相对于最底层存放数据的链表来说占用的空间便可以忽略不计了。</p>
<h4 id="平衡二叉树的优化"><a href="#平衡二叉树的优化" class="headerlink" title="平衡二叉树的优化"></a>平衡二叉树的优化</h4><p>但其实 MySQL 中的 InnoDB 并没有采用跳表，而是使用的一个叫做 B+ 树的数据结构。</p>
<p>这个数据结构不像是二叉树那样大学老师当做基础数据结构经常讲到，由于这类数据结构都是在实际工程中根据需求场景在基础数据结构中演化而来。</p>
<p>比如这里的 B+ 树就可以认为是由平衡二叉树演化而来。刚才我们提到二叉树的区间查询效率不高，针对这一点便可进行优化：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmkrik0eg4j30fa07mmxd.jpg" alt="img"></p>
<p>在原有二叉树的基础上优化后：所有的非叶子都不存放数据，只是作为叶子节点的索引，数据全部都存放在叶子节点。</p>
<p>这样所有叶子节点的数据都是有序存放的，便能很好的支持区间查询。只需要先通过查询到起始节点的位置，然后在叶子节点中依次往后遍历即可。</p>
<p>当数据量巨大时，很明显索引文件是不能存放于内存中，虽然速度很快但消耗的资源也不小;所以 MySQL 会将索引文件直接存放于磁盘中。</p>
<p>这点和后文提到 Elasticsearch 的索引略有不同。由于索引存放于磁盘中，所以我们要尽可能的减少与磁盘的 IO(磁盘 IO 的效率与内存不在一个数量级)。</p>
<p>通过上图可以看出，我们要查询一条数据至少得进行 4 次IO，很明显这个 IO 次数是与树的高度密切相关的，树的高度越低 IO 次数就会越少，同时性能也会越好。</p>
<p>那怎样才能降低树的高度呢?</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmkrilyjp7j30fa07ymxe.jpg" alt="img"></p>
<p>我们可以尝试把二叉树变为三叉树，这样树的高度就会下降很多，这样查询数据时的 IO 次数自然也会降低，同时查询效率也会提高许多。这其实就是 B+ 树的由来。</p>
<h4 id="使用索引的一些建议"><a href="#使用索引的一些建议" class="headerlink" title="使用索引的一些建议"></a>使用索引的一些建议</h4><p>其实通过上图对 B+树的理解，也能优化日常工作的一些小细节;比如为什么需要最好是有序递增的?</p>
<p>假设我们写入的主键数据是无序的，那么有可能后写入数据的 id 小于之前写入的，这样在维护 B+树索引时便有可能需要移动已经写好数据。</p>
<p>如果是按照递增写入数据时则不会有这个考虑，每次只需要依次写入即可。所以我们才会要求数据库主键尽量是趋势递增的，不考虑分表的情况时最合理的就是自增主键。</p>
<p>整体来看思路和跳表类似，只是针对使用场景做了相关的调整(比如数据全部存储于叶子节点)。</p>
<h4 id="ES-索引"><a href="#ES-索引" class="headerlink" title="ES 索引"></a>ES 索引</h4><p>MySQL 聊完了，现在来看看 Elasticsearch 是如何来使用索引的。</p>
<h4 id="正排索引"><a href="#正排索引" class="headerlink" title="正排索引"></a>正排索引</h4><p>在 ES 中采用的是一种名叫倒排索引的数据结构;在正式讲倒排索引之前先来聊聊和他相反的正排索引。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmkripirinj30fa04igli.jpg" alt="img"></p>
<p>以上图为例，我们可以通过 doc_id 查询到具体对象的方式称为使用正排索引，其实也能理解为一种散列表。</p>
<p>本质是通过 key 来查找 value。比如通过 doc_id=4 便能很快查询到 name=jetty wang，age=20 这条数据。</p>
<h4 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h4><p>那如果反过来我想查询 name 中包含了 li 的数据有哪些?这样如何高效查询呢?</p>
<p>仅仅通过上文提到的正排索引显然起不到什么作用，只能依次将所有数据遍历后判断名称中是否包含 li ;这样效率十分低下。</p>
<p>但如果我们重新构建一个索引结构：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmkrisud0nj30fa05ojrb.jpg" alt="img"></p>
<p>当要查询 name 中包含 li 的数据时，只需要通过这个索引结构查询到 Posting List 中所包含的数据，再通过映射的方式查询到最终的数据。</p>
<p>这个索引结构其实就是倒排索引。</p>
<h4 id="Term-Dictionary"><a href="#Term-Dictionary" class="headerlink" title="Term Dictionary"></a>Term Dictionary</h4><p>但如何高效的在这个索引结构中查询到 li 呢，结合我们之前的经验，只要我们将 Term 有序排列，便可以使用二叉树搜索树的数据结构在 o(logn) 下查询到数据。</p>
<p>将一个文本拆分成一个一个独立Term 的过程其实就是我们常说的分词。</p>
<p>而将所有 Term 合并在一起就是一个 Term Dictionary，也可以叫做单词词典。</p>
<p>英文的分词相对简单，只需要通过空格、标点符号将文本分隔便能拆词，中文则相对复杂，但也有许多开源工具做支持(由于不是本文重点，对分词感兴趣的可以自行搜索)。</p>
<p>当我们的文本量巨大时，分词后的 Term 也会很多，这样一个倒排索引的数据结构如果存放于内存那肯定是不够存的，但如果像 MySQL 那样存放于磁盘，效率也没那么高。</p>
<h4 id="Term-Index"><a href="#Term-Index" class="headerlink" title="Term Index"></a>Term Index</h4><p>所以我们可以选择一个折中的方法，既然无法将整个 Term Dictionary 放入内存中，那我们可以为 Term Dictionary 创建一个索引然后放入内存中。</p>
<p>这样便可以高效的查询 Term Dictionary ，最后再通过 Term Dictionary 查询到 Posting List。</p>
<p>相对于 MySQL 中的 B+树来说也会减少了几次磁盘 IO。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmkriuchigj30fa08l0st.jpg" alt="img"></p>
<p>这个 Term Index 我们可以使用这样的 Trie 树，也就是我们常说的字典树来存放。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmkrix5th2j30fa034wed.jpg" alt="img"></p>
<p>如果我们是以 j 开头的 Term 进行搜索，首先第一步就是通过在内存中的 Term Index 查询出以 j 打头的 Term 在 Term Dictionary 字典文件中的哪个位置(这个位置可以是一个文件指针，可能是一个区间范围)。</p>
<p>紧接着在将这个位置区间中的所有 Term 取出，由于已经排好序，便可通过二分查找快速定位到具体位置;这样便可查询出 Posting List。</p>
<p>最终通过 Posting List 中的位置信息便可在原始文件中将目标数据检索出来。</p>
<h4 id="更多优化"><a href="#更多优化" class="headerlink" title="更多优化"></a>更多优化</h4><p>当然 Elasticsearch 还做了许多针对性的优化，当我们对两个字段进行检索时，就可以利用 Bitmap 进行优化。</p>
<p>比如现在需要查询 name=li and age=18 的数据，这时我们需要通过这两个字段将各自的结果 Posting List 取出。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmkrj0duz8j30fa034a9w.jpg" alt="img"></p>
<p>最简单的方法是分别遍历两个集合，取出重复的数据，但这个明显效率低下。</p>
<p>这时我们便可使用 Bitmap 的方式进行存储(还节省存储空间)，同时利用先天的位与计算便可得出结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[1, 3, 5] ⇒ 10101 </span><br><span class="line"> </span><br><span class="line">[1, 2, 4, 5] ⇒ 11011</span><br></pre></td></tr></table></figure>
<p>这样两个二进制数组求与便可得出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10001 ⇒ [1, 5]</span><br></pre></td></tr></table></figure>
<p>最终反解出 Posting List 为 [1, 5]，这样的效率自然是要高上许多。同样的查询需求在 MySQL 中并没有特殊优化，只是先将数据量小的数据筛选出来之后再筛选第二个字段，效率自然也就没有 ES 高。</p>
<p>当然在最新版的 ES 中也会对 Posting List 进行压缩，具体压缩规则可以查看官方文档，这里就不具体介绍了。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>最后我们来总结一下：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmkrj44yv8j30fa04hjrd.jpg" alt="img"></p>
<p>通过以上内容可以看出再复杂的产品最终都是基础数据结构组成，只是会对不同应用场景针对性的优化，所以打好数据结构与算法的基础后再看某个新的技术或中间件时才能快速上手，甚至自己就能知道优化方向。</p>
]]></content>
      
        <categories>
            
            <category> Elasticsearch </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ES </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[大数据系统的Lambda架构]]></title>
      <url>/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E7%9A%84Lambda%E6%9E%B6%E6%9E%84.html</url>
      <content type="html"><![CDATA[<p>Nathan Marz的大作Big Data: Principles and best practices of scalable real-time data systems介绍了Labmda Architecture的概念，用于在大数据架构中，如何让real-time与batch job更好地结合起来，以达成对大数据的实时处理。</p>
<h3 id="传统系统的问题"><a href="#传统系统的问题" class="headerlink" title="传统系统的问题"></a>传统系统的问题</h3><p>在传统数据库的设计中，无法很好地支持系统的可伸缩性。当用户访问量增加时，数据库无法满足日益增长的用户请求负载，从而导致数据库服务器无法及时响应用户请求，出现超时错误。</p>
<p>解决的办法是在Web服务器与数据库之间增加一个异步处理的队列。如下图所示：</p>
<a id="more"></a>
<p><img src="https:////upload-images.jianshu.io/upload_images/2090836-9390f9c5a7d3d85c.png?imageMogr2/auto-orient/strip|imageView2/2/w/335/format/webp" alt="img"></p>
<p>引入队列</p>
<p>当Web Server收到页面请求时，会将消息添加到队列中。在DB端，创建一个Worker定期从队列中取出消息进行处理，例如每次读取100条消息。这相当于在两者之间建立了一个缓冲。</p>
<p>但是，这一方案并没有从本质上解决数据库overload的问题，且当worker无法跟上writer的请求时，就需要增加多个worker并发执行，数据库又将再次成为响应请求的瓶颈。一个解决办法是对数据库进行分区（horizontal partitioning或者sharding）。分区的方式通常以Hash值作为key。这样就需要应用程序端知道如何去寻找每个key所在的分区。</p>
<p>问题仍然会随着用户请求的增加接踵而来。当之前的分区无法满足负载时，就需要增加更多分区，这时就需要对数据库进行reshard。resharding的工作非常耗时而痛苦，因为需要协调很多工作，例如数据的迁移、更新客户端访问的分区地址，更新应用程序代码。如果系统本身还提供了在线访问服务，对运维的要求就更高。稍有不慎，就可能导致数据写到错误的分区，因此必须要编写脚本来自动完成，且需要充分的测试。</p>
<p>即使分区能够解决数据库负载问题，却还存在容错性（Fault-Tolerance）的问题。解决办法：</p>
<ul>
<li>改变queue/worker的实现。当消息发送给不可用的分区时，将消息放到“pending”队列，然后每隔一段时间对pending队列中的消息进行处理。</li>
<li>使用数据库的replication功能，为每个分区增加slave。</li>
</ul>
<p>问题并没有得到完美地解决。假设系统出现问题，例如在应用系统代码端不小心引入了一个bug，使得对页面的请求重复提交了一次，这就导致了重复的请求数据。糟糕的是，直到24小时之后才发现了该问题，此时对数据的破坏已经造成了。即使每周的数据备份也无法解决此问题，因为它不知道到底是哪些数据受到了破坏（corrupiton）。由于人为错误总是不可避免的，我们在架构时应该如何规避此问题？</p>
<p>现在，架构变得越来越复杂，增加了队列、分区、复制、重分区脚本（resharding scripts）。应用程序还需要了解数据库的schema，并能访问到正确的分区。问题在于：数据库对于分区是不了解的，无法帮助你应对分区、复制与分布式查询。最糟糕的问题是系统并没有为人为错误进行工程设计，仅靠备份是不能治本的。归根结底，系统还需要限制因为人为错误导致的破坏。</p>
<h3 id="数据系统的概念"><a href="#数据系统的概念" class="headerlink" title="数据系统的概念"></a>数据系统的概念</h3><p>大数据处理技术需要解决这种可伸缩性与复杂性。首先要认识到这种分布式的本质，要很好地处理分区与复制，不会导致错误分区引起查询失败，而是要将这些逻辑内化到数据库中。当需要扩展系统时，可以非常方便地增加节点，系统也能够针对新节点进行rebalance。</p>
<p>其次是要让数据成为不可变的。原始数据永远都不能被修改，这样即使犯了错误，写了错误数据，原来好的数据并不会受到破坏。</p>
<p>何谓“数据系统”？Nathan Marz认为：</p>
<blockquote>
<p>如果数据系统通过查找过去的数据去回答问题，则通常需要访问整个数据集。</p>
</blockquote>
<p>因此可以给data system的最通用的定义：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Query = <span class="function"><span class="keyword">function</span>(<span class="params">all data</span>)</span></span><br></pre></td></tr></table></figure>
<p>接下来，本书作者介绍了Big Data System所需具备的属性：</p>
<ul>
<li>健壮性和容错性（Robustness和Fault Tolerance）</li>
<li>低延迟的读与更新（Low Latency reads and updates）</li>
<li>可伸缩性（Scalability）</li>
<li>通用性（Generalization）</li>
<li>可扩展性（Extensibility）</li>
<li>内置查询（Ad hoc queries）</li>
<li>维护最小（Minimal maintenance）</li>
<li>可调试性（Debuggability）</li>
</ul>
<h3 id="Lambda架构"><a href="#Lambda架构" class="headerlink" title="Lambda架构"></a>Lambda架构</h3><p>Lambda架构的主要思想就是将大数据系统构建为多个层次，如下图所示：</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/2090836-1a2d72e650042599.png?imageMogr2/auto-orient/strip|imageView2/2/w/258/format/webp" alt="img"></p>
<p>lambda layer</p>
<p>理想状态下，任何数据访问都可以从表达式<code>Query = function(all data)</code>开始，但是，若数据达到相当大的一个级别（例如PB），且还需要支持实时查询时，就需要耗费非常庞大的资源。</p>
<p>一个解决方式是预运算查询函数（precomputed query funciton）。书中将这种预运算查询函数称之为<strong>Batch View</strong>，这样当需要执行查询时，可以从Batch View中读取结果。这样一个预先运算好的View是可以建立索引的，因而可以支持随机读取。于是系统就变成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">batch view = function(all data)</span><br><span class="line">query = function(batch view)</span><br></pre></td></tr></table></figure>
<h4 id="Batch-Layer"><a href="#Batch-Layer" class="headerlink" title="Batch Layer"></a>Batch Layer</h4><p>在Lambda架构中，实现<code>batch view = function(all data)</code>的部分被称之为<strong>batch layer</strong>。它承担了两个职责：</p>
<ul>
<li>存储Master Dataset，这是一个不变的持续增长的数据集</li>
<li>针对这个Master Dataset进行预运算</li>
</ul>
<p>显然，Batch Layer执行的是批量处理，例如Hadoop或者Spark支持的Map-Reduce方式。  它的执行方式可以用一段伪代码来表示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function runBatchLayer():</span><br><span class="line">  while (true):</span><br><span class="line">    recomputeBatchViews()</span><br></pre></td></tr></table></figure>
<p>例如这样一段代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Api.execute(Api.hfsSeqfile(<span class="string">"/tmp/pageview-counts"</span>),</span><br><span class="line">     <span class="keyword">new</span> Subquery(<span class="string">"?url"</span>, <span class="string">"?count"</span>)</span><br><span class="line">         .predicate(Api.hfsSeqfile(<span class="string">"/data/pageviews"</span>),</span><br><span class="line">             <span class="string">"?url"</span>, <span class="string">"?user"</span>, <span class="string">"?timestamp"</span>)</span><br><span class="line">         .predicate(<span class="keyword">new</span> Count(), <span class="string">"?count"</span>);</span><br></pre></td></tr></table></figure>
<p>代码并行地对hdfs文件夹下的page views进行统计（count），合并结果，并将最终结果保存在pageview-counts文件夹下。</p>
<p>利用Batch Layer进行预运算的作用实际上就是将大数据变小，从而有效地利用资源，改善实时查询的性能。但这里有一个前提，就是我们需要预先知道查询需要的数据，如此才能在Batch Layer中安排执行计划，定期对数据进行批量处理。此外，还要求这些预运算的统计数据是支持合并（merge）的。</p>
<h4 id="Serving-Layer"><a href="#Serving-Layer" class="headerlink" title="Serving Layer"></a>Serving Layer</h4><p>Batch Layer通过对master dataset执行查询获得了batch view，而Serving Layer就要负责对batch view进行操作，从而为最终的实时查询提供支撑。因此Serving Layer的职责包含：</p>
<ul>
<li>对batch view的随机访问</li>
<li>更新batch view</li>
</ul>
<p>Serving Layer应该是一个专用的分布式数据库，例如Elephant DB，以支持对batch view的加载、随机读取以及更新。注意，它并不支持对batch view的随机写，因为随机写会为数据库引来许多复杂性。简单的特性才能使系统变得更健壮、可预测、易配置，也易于运维。</p>
<h4 id="Speed-Layer"><a href="#Speed-Layer" class="headerlink" title="Speed Layer"></a>Speed Layer</h4><p>只要batch layer完成对batch view的预计算，serving layer就会对其进行更新。这意味着在运行预计算时进入的数据不会马上呈现到batch view中。这对于要求完全实时的数据系统而言是不能接受的。要解决这个问题，就要通过speed layer。从对数据的处理来看，speed layer与batch layer非常相似，它们之间最大的区别是前者只处理最近的数据，后者则要处理所有的数据。另一个区别是为了满足最小的延迟，speed layer并不会在同一时间读取所有的新数据，相反，它会在接收到新数据时，更新realtime view，而不会像batch layer那样重新运算整个view。speed layer是一种增量的计算，而非重新运算（recomputation）。</p>
<p>因而，Speed Layer的作用包括：</p>
<ul>
<li>对更新到serving layer带来的高延迟的一种补充</li>
<li>快速、增量的算法</li>
<li>最终Batch Layer会覆盖speed layer</li>
</ul>
<p>Speed Layer的等式表达如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">realtime view = function(realtime view, new data)</span><br></pre></td></tr></table></figure>
<p>注意，realtime view是基于新数据和已有的realtime view。</p>
<p>总结下来，Lambda架构就是如下的三个等式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">batch view = function(all data)</span><br><span class="line">realtime view = function(realtime view, new data)</span><br><span class="line">query = function(batch view . realtime view)</span><br></pre></td></tr></table></figure>
<p>整个Lambda架构如下图所示：</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/2090836-f056e5d98f8b3b2f.png?imageMogr2/auto-orient/strip|imageView2/2/w/557/format/webp" alt="img"></p>
<p>lambda architecture</p>
<p>基于Lambda架构，一旦数据通过batch layer进入到serving layer，在realtime view中的相应结果就不再需要了。</p>
<p>作者：<em>张逸</em><br>链接：<span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9iNmJmMDUzMzJjMTg=" title="https://www.jianshu.com/p/b6bf05332c18">https://www.jianshu.com/p/b6bf05332c18<i class="fa fa-external-link"></i></span><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
]]></content>
      
        <categories>
            
            <category> 大数据 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Lambda </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[kappa架构的层级及其特点]]></title>
      <url>/kappa%E6%9E%B6%E6%9E%84%E7%9A%84%E5%B1%82%E7%BA%A7%E5%8F%8A%E5%85%B6%E7%89%B9%E7%82%B9.html</url>
      <content type="html"><![CDATA[<p>kappa架构的本质可以说是只依赖一套流处理系统来作为大数据处理解决方案。</p>
<p><strong>一、概括起来，kappa架构包括两个层级</strong></p>
<p><strong>1、消息传输层</strong></p>
<p>这一层有如下特点</p>
<ul>
<li>持久性——数据可任意设定存储时间</li>
<li>分布式——数据分布式存储</li>
<li>数据可重放——数据可以被replay，从头重新处理</li>
<li>高性能——能够提供高性能数据读写访问</li>
</ul>
<a id="more"></a>
<p>有了这几点保证之后，数据便可以在某个需要限度内全量存储，这可将生产者和消费者解耦，并进行分布式容错以提高可用性，可重放很重要，这确保了在必要情况下系统可进行重算。</p>
<p>消息传输层的意义在于弹性容纳并提供流计算引擎的输入数据，并在必要时从头开始读取重新计算，从而获得可靠结果。</p>
<p>通常使用消息队列如Kafka来作为消息传输层。</p>
<p><strong>2、流处理层</strong></p>
<p>这一层即是大数据流处理引擎，可用于进行流分布式实时计算。理想情况下，流处理层也应该具备如下特点</p>
<ul>
<li>低延迟——保证快速响应</li>
<li>高吞吐——同时处理庞大数据量</li>
<li>具有容错与恢复能力——保证系统稳定可用</li>
<li>一致性保证——适用任何强一致性需求的应用(如金融级需求)</li>
</ul>
<p>如今比较流行的大数据处理系统要数基于Spark引擎的Spark Streaming、Struct Streaming还有Flink、Storm了。我们看看业界最常用的Spark和Flink在流处理这方面的高下！在延迟方面Flink要更胜于Spark流处理。另一方面，在一致性方面Flink借鉴 Chandy-Lamport 分布式快照算法实现的Asynchronous Barrier Snapshots算法来提供一致性保证而Spark流处理无法保证。</p>
<p>这里我的另一点体会是，Flink是连续运算符长运行的计算模式，所以其在失败时进行状态重放，从断点继续往下执行即可，而批次的处理却不可以，批次的重新处理时其加载的仍然是批。</p>
<p><strong>二、然后我们来看几个概念</strong></p>
<p><strong>1、幂等性</strong></p>
<p>幂等性也就是指相同的操作无论执行多少次，均会产生一样的结果。</p>
<p>这里为什么提到幂等性呢？因为分布式中的一致性通常是难以保证的，因为伴随着分布式的一致性而来的除了耗资源还产生延迟以及网络通信问题。所以如Spark流处理输出时是无法保证Exactly-once（失败时部分已经写出、而还有部分未写出，重启时从上一个检查点开始，造成部分重复），这个时候可以通过幂等输出来解决。</p>
<p>举个例子，在往kafka写出时，可以通过外部存储的唯一键来辅助<br>设置enable.auto.commit为false，在幂等写出时再手动提交，这样便可保证写入到kafka中的数据不会重复。</p>
<p><strong>2、Exactly-once语义</strong></p>
<p>Struct Streaming的微批次处理模式中声称的exactly-once语义并不是说输入数据只被处理一次，因为Spark引擎支持任务重试（根据沿袭图），所以很有可能task失败导致数据重新被加载再次处理。这里的exactly-once实际是指不管执行多少次，其最终的执行结果都是一样的。</p>
<p><strong>三、kappa的优缺点</strong></p>
<p>这个在前边的文章已有描述，但其核心优点即是无需维护离线批计算、实时计算两套系统，对于业务开发也只需一套程序即可，不用担心因两套系统导致的执行结果不一致。另外，其从头开始计算的能力也是主要考虑的其不足的一点。</p>
]]></content>
      
        <categories>
            
            <category> 大数据 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> kappa </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Kappa架构与Lambda架构比较]]></title>
      <url>/Kappa%E6%9E%B6%E6%9E%84%E4%B8%8ELambda%E6%9E%B6%E6%9E%84%E6%AF%94%E8%BE%83.html</url>
      <content type="html"><![CDATA[<h2 id="Lambda架构"><a href="#Lambda架构" class="headerlink" title="Lambda架构"></a><strong>Lambda架构</strong></h2><p>Nathan Marz针对通用的，可扩展的和容错的数据处理架构提出了术语Lambda Architecture。它是一种旨在通过利用批处理和流处理这两者的优势来处理大量数据的数据处理架构。</p>
<p><img src="https://img-blog.csdnimg.cn/2019070215032969.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhaWJ1Y3VvYmE=,size_16,color_FFFFFF,t_70" alt="img"></p>
<a id="more"></a>
<h3 id="图层"><a href="#图层" class="headerlink" title="图层"></a><strong>图层</strong></h3><p>从宏观角度看，它的处理流程如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20190702150246623.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhaWJ1Y3VvYmE=,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>所有进入系统的数据都被分配到批处理层和速度层进行处理。批处理层管理主数据集（一个不可变的，仅可扩展的原始数据集）并预先计算批处理视图。服务层对批处理视图进行索引，以便可以在低延迟的情况下进行点对点查询。速度层只处理最近的数据。任何传入的查询都必须通过合并来自批量视图和实时视图的结果来得到结果。</p>
<h3 id="数据的相关性"><a href="#数据的相关性" class="headerlink" title="数据的相关性"></a><strong>数据的相关性</strong></h3><p>如前所述，任何传入查询都必须通过合并来自批量视图和实时视图的结果来得到答案，因此这些视图需要可合并性。需要注意的一点是，实时视图是以前的实时视图和新数据增量的函数，因此可以使用增量算法。批处理视图是所有数据的函数，因此应该在那里使用重算算法。</p>
<h3 id="权衡"><a href="#权衡" class="headerlink" title="权衡"></a><strong>权衡</strong></h3><p>我们生活中的每一件事都是一种折衷，而Lambda Architecture也不是一个例外。通常，我们需要解决一些主要的折衷：</p>
<ul>
<li>完全重新计算与部分重新计算<ul>
<li>在某些情况下，可以使用Bloom过滤器来避免完全重新计算</li>
</ul>
</li>
<li>重算算法与增量算法<ul>
<li>使用增量算法有很大的诱惑力，但根据指南我们必须使用重新计算算法，即使它使达到相同的结果变得更加困难。</li>
</ul>
</li>
<li>加法算法与近似算法<ul>
<li>Lambda Architecture与加法算法很好地协作。因此，这是我们需要考虑使用近似算法的另一种情况，例如，HyperLogLog用于计数不同的问题等。</li>
</ul>
</li>
</ul>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a><strong>实现</strong></h3><p>有多种实现Lambda体系结构的方法，因为它对于每个层的底层解决方案都是不可知的。每一层都需要底层实现的特定功能，这可能有助于做出更好的选择并避免过度的决定：</p>
<ul>
<li>批处理层：一次写入，批量读取多次</li>
<li>服务层：随机读取，不随机写入; 批量计算和批量写入</li>
<li>速度层：随机读取，随机写入; 增量计算</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmg5ck9vb6j30hc0fut9h.jpg" alt="img"></p>
<h2 id="Kappa架构"><a href="#Kappa架构" class="headerlink" title="Kappa架构"></a>Kappa架构</h2><p>正如前面提到的，Lambda Architecture有其优点和缺点，人们也划分成支持者和反对者两派。Kappa 架构是LinkedIn的Jay Kreps结合实际经验和个人体会，针对Lambda架构进行深度剖析，分析其优缺点并采用的替代方案。Lambda 架构的一个很明显的问题是需要维护两套分别跑在批处理和实时计算系统上面的代码，而且这两套代码得产出一模一样的结果。因此对于设计这类系统的人来讲，要面对的问题是：为什么我们不能改进流计算系统让它能处理这些问题？为什么不能让流系统来解决数据全量处理的问题？流计算天然的分布式特性注定其扩展性比较好，能否加大并发量来处理海量的历史数据？基于种种问题的考虑，Jay提出了Kappa这种替代方案。<span class="exturl" data-url="aHR0cDovL21pbGluZGEucGF0aGlyYWdlLm9yZy9rYXBwYS1hcmNoaXRlY3R1cmUuY29tLw==" title="http://milinda.pathirage.org/kappa-architecture.com/">Kappa架构<i class="fa fa-external-link"></i></span> 简化了<span class="exturl" data-url="aHR0cDovL2xhbWJkYS1hcmNoaXRlY3R1cmUubmV0Lw==" title="http://lambda-architecture.net/">Lambda架构<i class="fa fa-external-link"></i></span>。<span class="exturl" data-url="aHR0cDovL21pbGluZGEucGF0aGlyYWdlLm9yZy9rYXBwYS1hcmNoaXRlY3R1cmUuY29tLw==" title="http://milinda.pathirage.org/kappa-architecture.com/">Kappa架构<i class="fa fa-external-link"></i></span>系统是删除了批处理系统的架构。要取代批处理，数据只需通过流式传输系统快速提供：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmg5crs6i9j30hc07raau.jpg" alt="img"></p>
<p>那如何用流计算系统对全量数据进行重新计算，步骤如下：</p>
<p>1、用Kafka或类似的分布式队列保存数据，需要几天数据量就保存几天。</p>
<p>2、当需要全量计算时，重新起一个流计算实例，从头开始读取数据进行处理，并输出到一个结果存储中。</p>
<p>3、当新的实例完成后，停止老的流计算实例，并把老的一引起结果删除。</p>
<p>一个典型的Kappa架构如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmg5cwf5rnj30hc04q0t0.jpg" alt="img"></p>
<p>和Lambda架构相比，在Kappa架构下，只有在有必要的时候才会对历史数据进行重复计算，并且实时计算和批处理过程使用的是同一份代码。或许有些人会质疑流式处理对于历史数据的高吞吐量会力不从心，但是这可以通过控制新实例的并发数进行改善。</p>
<p> Kappa架构的核心思想包括以下三点：</p>
<p>用Kafka或者类似的分布式队列系统保存数据，你需要几天的数据量就保存几天。</p>
<p>当需要全量重新计算时，重新起一个流计算实例，从头开始读取数据进行处理，并输出到一个新的结果存储中。</p>
<p>当新的实例做完后，停止老的流计算实例，并把老的一些结果删除。</p>
]]></content>
      
        <categories>
            
            <category> 大数据 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Kappa </tag>
            
            <tag> Lambda </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Scala快速入门]]></title>
      <url>/Scala%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8.html</url>
      <content type="html"><![CDATA[<h2 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> hello=<span class="string">"Hello Scala"</span></span><br><span class="line"><span class="keyword">val</span> hello:<span class="type">String</span>=<span class="string">"Hello Scala"</span></span><br><span class="line"><span class="keyword">val</span> hello:java.lang.<span class="type">String</span>=<span class="string">"Hello Scala"</span></span><br><span class="line"><span class="keyword">lazy</span> <span class="keyword">val</span> hello=<span class="string">"Hello Scala"</span></span><br><span class="line"><span class="keyword">val</span> hello=<span class="string">"Hello Scala"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> x=<span class="number">0x29</span>   <span class="comment">//十六进制定义整数</span></span><br><span class="line"><span class="keyword">val</span> x=<span class="number">41</span>      <span class="comment">//十进制定义整数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> doubleNumber = <span class="number">3.14159</span>    <span class="comment">//Double类型定义，直接输入浮点数，编译器会将其自动推断为Double类型</span></span><br><span class="line"><span class="keyword">val</span> floatNumber=<span class="number">3.14159</span>F  <span class="comment">//定义Float类型浮点数，需要在浮点数后面加F或f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> floatNumber=<span class="number">0.1314e1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> letter = '<span class="type">A</span>' <span class="comment">//字符定义，用单引号(')将字符包裹</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> hello = <span class="string">""</span><span class="string">"Hello  \n \t \b \\ Scala"</span><span class="string">""</span></span><br><span class="line"><span class="comment">//如果需要原样输出字符串中的内容，则用三个双引号"""将字符串包裹起来</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bool = <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>注：</p>
<ul>
<li><p>val 相当于Java中的final关键字修饰的变量，一旦赋值便不能更改 </p>
</li>
<li><p>当未指定类型时，Scala会根据实际类型进行类型推断,上面前三种方式结果相同 </p>
</li>
<li><p>lazy关键字修饰的变量，定义时不赋值，真正使用时才赋值 </p>
</li>
<li><p>var关键字修饰的变量，可以被重新赋值<br><em>e也可以是大写E,0.1214e1 = 0.1314</em>10 </p>
</li>
<li><p>e也可以是大写E,0.1214e2 = 0.1314<em>10</em>10 </p>
</li>
</ul>
<h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max</span></span>(x:<span class="type">Int</span>, y:<span class="type">Int</span>):<span class="type">Int</span>=&#123;</span><br><span class="line">	<span class="keyword">if</span>(x &gt; y)</span><br><span class="line">	    x</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	    y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sub</span></span>(a:<span class="type">Int</span>,b:<span class="type">Int</span>)=&#123;</span><br><span class="line">	a-b</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sub</span></span>(a:<span class="type">Int</span>,b:<span class="type">Int</span>):<span class="type">Unit</span>=&#123;</span><br><span class="line">	a-b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>def：关键字，定义一个函数 </p>
</li>
<li><p>max：自定义的方法名 </p>
</li>
<li><p>(x:Int, y:Int)：方法名后小扩号中为参数列表 </p>
</li>
<li><p>Int：参数后的Int为方法返回值类型 </p>
</li>
<li><p>{…}：大扩号中为方法体 </p>
</li>
<li><p>Scala函数返回值可以不加return,默认函数体最后一条语句为返回值 </p>
</li>
<li><p>函数体不指定返回值时，scala会根据实际类型进行类型推断 </p>
</li>
<li><p>Unit关键字表示函数不存在返回值，相当于java中的void关键字 </p>
</li>
<li><p>Scala每行语句结束后的分号可加可不加 </p>
</li>
</ul>
<h2 id="Scala基本类型"><a href="#Scala基本类型" class="headerlink" title="Scala基本类型"></a>Scala基本类型</h2><table>
<thead>
<tr>
<th><strong>Value type</strong></th>
<th><strong>Range</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Byte</td>
<td>8-bit</td>
</tr>
<tr>
<td>Short</td>
<td>16-bit</td>
</tr>
<tr>
<td>Int</td>
<td>32-bit</td>
</tr>
<tr>
<td>Long</td>
<td>64-bit</td>
</tr>
<tr>
<td>Char</td>
<td>16-bit</td>
</tr>
<tr>
<td>Float</td>
<td>32-bit</td>
</tr>
<tr>
<td>Double</td>
<td>64-bit</td>
</tr>
<tr>
<td>Boolean</td>
<td>true or false</td>
</tr>
<tr>
<td>String</td>
</tr>
</tbody>
</table>
<h2 id="算术操作"><a href="#算术操作" class="headerlink" title="算术操作+ - * / %"></a>算术操作+ - * / %</h2><ul>
<li>在Scala中一切操作皆方法，这意味着Scala中的一切毕为对象 </li>
<li><p>1+2整数求和时，编译器会将其转换为(1).+(2)执行,所以下面两种方式是相等的<br>var sum =1+2<br>var sum=(1).+(2) </p>
</li>
<li><p>操作符重载，编译器会将其转换为(1).+(2L)执行结果等于3<br>var longsum = 1 + 2L </p>
</li>
<li><p>Scala中可以用+ -符号来表示正负数，例如：-3+3<br>var y= 1+ -3<br>var y= -3+3 </p>
</li>
</ul>
<h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><p>= &lt; ⇐ ! ==</p>
<h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>! &amp;&amp; ||</p>
<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p>&amp;(按位与) |(按位或) ^(按位异或) ~(按位取反) «(左移) »(带符号右移) »&gt;(无符号右移)</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//00000001</span></span><br><span class="line"><span class="comment">//00000010</span></span><br><span class="line"><span class="comment">//00000000</span></span><br><span class="line">scala&gt; <span class="number">1</span> &amp; <span class="number">2</span></span><br><span class="line">res0: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//00000001</span></span><br><span class="line"><span class="comment">//00000010</span></span><br><span class="line"><span class="comment">//00000011</span></span><br><span class="line">scala&gt; <span class="number">1</span> | <span class="number">2</span></span><br><span class="line">res0: <span class="type">Int</span> = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//00000001</span></span><br><span class="line"><span class="comment">//1111110</span></span><br><span class="line">scala&gt; ~<span class="number">1</span></span><br><span class="line">res1: <span class="type">Int</span> = <span class="number">-2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//00000001</span></span><br><span class="line"><span class="comment">//00000010</span></span><br><span class="line">scala&gt; <span class="number">1</span> &lt;&lt; <span class="number">1</span></span><br><span class="line">res3: <span class="type">Int</span> = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//00000001</span></span><br><span class="line"><span class="comment">//00000000</span></span><br><span class="line">scala&gt; <span class="number">1</span> &gt;&gt; <span class="number">1</span></span><br><span class="line">res5: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//00000001</span></span><br><span class="line"><span class="comment">//00000000</span></span><br><span class="line">scala&gt; <span class="number">1</span> &gt;&gt;&gt; <span class="number">1</span></span><br><span class="line">res7: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//00000001</span></span><br><span class="line"><span class="comment">//00000010</span></span><br><span class="line"><span class="comment">//操作的结果是如果某位不同则该位为1, 否则该位为0.</span></span><br><span class="line">scala&gt; <span class="number">1</span> ^ <span class="number">2</span></span><br><span class="line">res9: <span class="type">Int</span> = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="number">1</span> ^ <span class="number">3</span></span><br><span class="line">res10: <span class="type">Int</span> = <span class="number">2</span></span><br></pre></td></tr></table></figure>
<h2 id="对象比较"><a href="#对象比较" class="headerlink" title="对象比较"></a>对象比较</h2><ul>
<li>Scala中的对象比较不同于Java中的对象比较 </li>
<li>Scala基于内容的比较，而Java中比较的是引用地址 </li>
<li>Scala eq 方法是基于引用地址的比较 </li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="number">1</span>==<span class="number">1</span></span><br><span class="line">res16: <span class="type">Boolean</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="number">1</span>==<span class="number">1.0</span></span><br><span class="line">res17: <span class="type">Boolean</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> x=<span class="string">"hello"</span></span><br><span class="line">x: <span class="type">String</span> = hello</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> y=<span class="string">"hello"</span></span><br><span class="line">y: <span class="type">String</span> = hello</span><br><span class="line"></span><br><span class="line">scala&gt; x==y</span><br><span class="line">res18: <span class="type">Boolean</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> x:<span class="type">String</span> = <span class="keyword">new</span> <span class="type">String</span>(<span class="string">"hello"</span>)</span><br><span class="line">x: <span class="type">String</span> = hello</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> y:<span class="type">String</span> = <span class="keyword">new</span> <span class="type">String</span>(<span class="string">"hello"</span>)</span><br><span class="line">y: <span class="type">String</span> = hello</span><br><span class="line"></span><br><span class="line">scala&gt; x==y</span><br><span class="line">res20: <span class="type">Boolean</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">scala&gt; x.eq(y)</span><br><span class="line">res17: <span class="type">Boolean</span> = <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h2 id="运算符的优先级"><a href="#运算符的优先级" class="headerlink" title="运算符的优先级"></a>运算符的优先级</h2><p>扩号优先级最高<br>* / %<br>+ -<br>:<br>= !<br>&lt; &gt;<br>&amp; </p>
<h2 id="字符串的操作"><a href="#字符串的操作" class="headerlink" title="字符串的操作"></a>字符串的操作</h2><p>var str = “hello” </p>
<ul>
<li>定义的String类型变量可以使用java中String的所有方法 </li>
<li>隐式转换：Scala把String类型转换成StringOps,其中包括了所有的immutable sequence的方法。碰到reverse,map,drop和slice方法时编译器会自动插入这个转换。 </li>
<li>Scala方法的调用可以不加点“.”,直接用空格调用，并且可以省略扩号 </li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">str.indexOf(“o”)</span><br><span class="line">str indexOf 'o'</span><br><span class="line">str.toUpperCase</span><br><span class="line">str.toLowerCase</span><br><span class="line">str.reverse</span><br><span class="line">str.map(_.toUpper)</span><br><span class="line">str.drop(<span class="number">2</span>)</span><br><span class="line">str drop <span class="number">2</span></span><br><span class="line">str drop(<span class="number">2</span>)</span><br><span class="line">str slice(<span class="number">1</span>,<span class="number">4</span>)</span><br><span class="line">str.slice(<span class="number">1</span>,<span class="number">4</span>)</span><br><span class="line">….</span><br></pre></td></tr></table></figure>
<h2 id="if的使用"><a href="#if的使用" class="headerlink" title="if的使用"></a>if的使用</h2><ul>
<li>Scala会自动进行类型推断</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">var</span> x = <span class="keyword">if</span>(<span class="string">"hello"</span>==<span class="string">"hello"</span>)<span class="number">1</span> <span class="keyword">else</span> <span class="number">2</span> </span><br><span class="line">x: <span class="type">Int</span> = <span class="number">1</span></span><br><span class="line">scala&gt; <span class="keyword">var</span> x = <span class="keyword">if</span>(<span class="string">"hello"</span>==<span class="string">"hello"</span>)<span class="string">"1"</span> <span class="keyword">else</span> <span class="string">"2"</span></span><br><span class="line">x: <span class="type">String</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="while的使用"><a href="#while的使用" class="headerlink" title="while的使用"></a>while的使用</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="type">HelloScala</span> loop <span class="number">4</span></span><br><span class="line">    <span class="type">HelloScala</span> loop(<span class="number">4</span>)</span><br><span class="line">    <span class="type">HelloScala</span>.loop(<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">var</span> line=<span class="string">""</span></span><br><span class="line">    <span class="keyword">while</span>((line=readLine())!=<span class="string">""</span>)   <span class="comment">//readLine() 读取控制台的输入</span></span><br><span class="line">      println(<span class="string">"read:"</span>+line)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">loop</span></span>(x:<span class="type">Int</span>)=&#123;</span><br><span class="line">    <span class="keyword">var</span> a=x</span><br><span class="line">    <span class="keyword">while</span>(a!=<span class="number">0</span>)&#123;</span><br><span class="line">      a=a<span class="number">-1</span></span><br><span class="line">      println(a)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="do-while的使用"><a href="#do-while的使用" class="headerlink" title="do while的使用"></a>do while的使用</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="type">HelloScala</span> loop(<span class="number">4</span>,<span class="number">2</span>)</span><br><span class="line">    <span class="type">HelloScala</span>.loop(<span class="number">4</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> line=<span class="string">""</span></span><br><span class="line">    do&#123;</span><br><span class="line">      line=readLine()</span><br><span class="line">      println(<span class="string">"read:"</span>+line)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(line!=<span class="string">""</span>)</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">loop</span></span>(x:<span class="type">Int</span>,y:<span class="type">Int</span>)=&#123;</span><br><span class="line">    <span class="keyword">var</span> a=x</span><br><span class="line">    do&#123;</span><br><span class="line">      a=a-y</span><br><span class="line">      println(a)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(a!=<span class="number">0</span>)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>Scala具有函数式编程语方的特点，在函数式编程语方当中，一般不推荐使用var变量 </p>
</li>
<li><p>利用if替代while控制结构,可以减少var变量的使用,程序结构也更简单，表达能力更强 </p>
</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop</span></span>(x:<span class="type">Int</span>):<span class="type">Unit</span>=&#123;</span><br><span class="line">    <span class="keyword">if</span>(x!=<span class="number">0</span>)&#123;</span><br><span class="line">      println(x)</span><br><span class="line">      loop(x<span class="number">-1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="for循环的使用"><a href="#for循环的使用" class="headerlink" title="for循环的使用"></a>for循环的使用</h2><ol>
<li>打印当前目录所有文件名 </li>
</ol>
<ul>
<li>← 生成器(generator),在执行过程中，集合files中的Array[File]的元素将依次赋值给file,file类型为File,输出时调用其toStirng方法将文件名打印出来 </li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> files = (<span class="keyword">new</span> java.io.<span class="type">File</span>(<span class="string">"."</span>)).listFiles</span><br><span class="line"><span class="keyword">for</span>(file &lt;- files )println(file)</span><br><span class="line"><span class="keyword">val</span> files = (<span class="keyword">new</span> java.io.<span class="type">File</span>(<span class="string">"."</span>)).listFiles</span><br><span class="line"><span class="keyword">for</span>(i &lt;- <span class="number">0</span> to files.length <span class="number">-1</span>)println(files(i))</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span> to <span class="number">2</span></span><br><span class="line"><span class="keyword">for</span>(i &lt;- a)println(<span class="string">"item:"</span>+i)</span><br></pre></td></tr></table></figure>
<ol>
<li>for循环中加入if过滤操作</li>
</ol>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> files = (<span class="keyword">new</span> java.io.<span class="type">File</span>(<span class="string">"."</span>)).listFiles</span><br><span class="line"><span class="keyword">for</span>(file &lt;- files <span class="keyword">if</span> file.getName.endsWith(<span class="string">"iml"</span>))println(file)</span><br></pre></td></tr></table></figure>
<ol>
<li>加入多个过滤条件</li>
</ol>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(file &lt;- files <span class="keyword">if</span> file.isFile; <span class="keyword">if</span> file.getName.endsWith(<span class="string">"iml"</span>)) println(file)</span><br></pre></td></tr></table></figure>
<p>4.多重循环的实现</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    grep(<span class="string">"JAVA"</span>)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">fileLines</span></span>(file: <span class="type">File</span>) = scala.io.<span class="type">Source</span>.fromFile(file).getLines.toList</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">grep</span></span>(pattern:<span class="type">String</span>) =</span><br><span class="line">    <span class="keyword">for</span> (</span><br><span class="line">      file &lt;- (<span class="keyword">new</span> <span class="type">File</span>(<span class="string">"."</span>)).listFiles <span class="keyword">if</span> file.getName.endsWith(<span class="string">"iml"</span>);</span><br><span class="line">      line &lt;- fileLines(file) <span class="keyword">if</span> line.trim.contains(pattern)</span><br><span class="line"> ) println(file + <span class="string">":"</span> + line.trim)</span><br></pre></td></tr></table></figure>
<h2 id="yield-关键字在循环中生成返回结果"><a href="#yield-关键字在循环中生成返回结果" class="headerlink" title="yield 关键字在循环中生成返回结果"></a>yield 关键字在循环中生成返回结果</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(getFile(<span class="number">0</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getFile</span> </span>=</span><br><span class="line">    <span class="keyword">for</span>&#123;</span><br><span class="line">      file &lt;- (<span class="keyword">new</span> <span class="type">File</span>(<span class="string">"."</span>)).listFiles <span class="keyword">if</span> file.getName.endsWith(<span class="string">"iml"</span>)</span><br><span class="line">    &#125;<span class="keyword">yield</span> file</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">for</span>(i &lt;- grep(<span class="string">"orderEntry"</span>))println(i)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">fileLines</span></span>(file: <span class="type">File</span>) =</span><br><span class="line">    scala.io.<span class="type">Source</span>.fromFile(file).getLines.toList</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">grep</span></span>(pattern:<span class="type">String</span>) =</span><br><span class="line">    <span class="keyword">for</span> (</span><br><span class="line">      file &lt;- (<span class="keyword">new</span> <span class="type">File</span>(<span class="string">"."</span>)).listFiles <span class="keyword">if</span> file.getName.endsWith(<span class="string">"iml"</span>);</span><br><span class="line">      line &lt;- fileLines(file) <span class="keyword">if</span> line.trim.contains(pattern)</span><br><span class="line">    ) <span class="keyword">yield</span> line.trim</span><br><span class="line"><span class="comment">//返回Array[String]</span></span><br></pre></td></tr></table></figure>
<h2 id="Array数组操作"><a href="#Array数组操作" class="headerlink" title="Array数组操作"></a>Array数组操作</h2><h3 id="定长数组Array"><a href="#定长数组Array" class="headerlink" title="定长数组Array"></a>定长数组Array</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scala</span>中的<span class="type">Array</span>是以<span class="type">Java</span>中的<span class="type">Array</span>方式实现的 </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = <span class="number">0</span> until <span class="number">5</span> </span><br><span class="line">scala.collection.immutable.<span class="type">Range</span> = <span class="type">Range</span> <span class="number">0</span> until <span class="number">5</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> arr1 = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">Int</span>](<span class="number">10</span>) </span><br><span class="line">复杂对象类型的数组初使化值为<span class="literal">null</span>,数值型被初使化为<span class="number">0</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr2 = <span class="type">Array</span>(“aaa”,“bbb”) </span><br><span class="line">定义一个数组同时赋值，这种调用方式是调用其apply方法进行数组创建操作的 </span><br><span class="line"></span><br><span class="line">arr2(<span class="number">1</span>)=“test” </span><br><span class="line">数组元素赋值,不同于<span class="type">Java</span>,这里index的指定是用小扩号。 </span><br><span class="line"></span><br><span class="line">intArr.update(<span class="number">2</span>,“test2”) </span><br><span class="line">更新值</span><br></pre></td></tr></table></figure>
<h3 id="变长数组ArrayBuffer"><a href="#变长数组ArrayBuffer" class="headerlink" title="变长数组ArrayBuffer"></a>变长数组ArrayBuffer</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">scala.collection.mutable.<span class="type">ArrayBuffer</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr=<span class="type">ArrayBuffer</span>[<span class="type">String</span>]() </span><br><span class="line">arr+=“<span class="type">Hello</span>” </span><br><span class="line">arr+=(“<span class="type">Hello</span>”,“<span class="type">Scala</span>”) </span><br><span class="line">+= 在尾部添加元素 </span><br><span class="line"></span><br><span class="line">arr.insert(<span class="number">1</span>,“test1”,“test2”,“test3”) </span><br><span class="line">arr.insertAll(<span class="number">3</span>,arr) </span><br><span class="line">arr.insertAll(<span class="number">3</span>,arr2) </span><br><span class="line">在指定位置插入数据 </span><br><span class="line"></span><br><span class="line">arr.remove(<span class="number">0</span>,<span class="number">2</span>) </span><br><span class="line">从索引<span class="number">0</span>开始，删除<span class="number">2</span>个元素 </span><br><span class="line"></span><br><span class="line">arr++=<span class="type">Array</span>(“hello”,“test”) </span><br><span class="line">arr++=<span class="type">List</span>(“value1”,“value2”) </span><br><span class="line">++=用于向数组中追加内容，++=右侧可以是任何集合 </span><br><span class="line"></span><br><span class="line">arr.trimStart(<span class="number">2</span>) </span><br><span class="line">删除前面<span class="number">2</span>个元素 </span><br><span class="line"></span><br><span class="line">arr.trimEnd(<span class="number">2</span>) </span><br><span class="line">删除未尾<span class="number">2</span>个元素 </span><br><span class="line"></span><br><span class="line">arr.toArray </span><br><span class="line">转换<span class="type">ArrayBuffer</span> to <span class="type">Array</span> </span><br><span class="line"></span><br><span class="line">arr.toBuffer </span><br><span class="line">转换<span class="type">Array</span> to <span class="type">ArrayBuffer</span> </span><br><span class="line"></span><br><span class="line">遍历数组 </span><br><span class="line">to 方式 </span><br><span class="line"><span class="keyword">for</span>(i ← <span class="number">0</span> to arr.length<span class="number">-1</span>)println(arr(i)) </span><br><span class="line"></span><br><span class="line">until方式 </span><br><span class="line"><span class="keyword">for</span>(i ← <span class="number">0</span> until arr.length)println(arr(i)) </span><br><span class="line"></span><br><span class="line">foreach方式 </span><br><span class="line"><span class="keyword">for</span>(i ← arr)print(“\t”+i) </span><br><span class="line"></span><br><span class="line">指定步长 </span><br><span class="line"><span class="keyword">for</span>(i← <span class="number">0</span> until (arr.length,<span class="number">2</span>)) print(“\t”+arr(i)) </span><br><span class="line"><span class="keyword">for</span>(i← (<span class="number">0</span> to (arr.length<span class="number">-1</span>,<span class="number">2</span>))) print(“\t”+arr(i)) </span><br><span class="line"></span><br><span class="line">倒序输出 </span><br><span class="line"><span class="keyword">for</span>(i ← (<span class="number">0</span> until arr.length).reverse) print(“\t”+arr(i)) </span><br><span class="line"><span class="keyword">for</span>(i ← (<span class="number">0</span> to arr.length <span class="number">-1</span>).reverse) print(“\t”+arr(i)) </span><br><span class="line"><span class="keyword">for</span>(i ← arr.reverse) print(“\t”+i) </span><br><span class="line"></span><br><span class="line"><span class="keyword">yield</span>返回新的数组 </span><br><span class="line"><span class="keyword">var</span> arr2 = <span class="keyword">for</span>(i ← arr) <span class="keyword">yield</span> i+“test” </span><br><span class="line">*原数组不变 </span><br><span class="line">*<span class="type">BufferArray</span>转换后产生的仍然是<span class="type">BufferArray</span> </span><br><span class="line">*<span class="type">Array</span>转换后产生的仍然是<span class="type">Array</span> </span><br><span class="line"></span><br><span class="line">数组求和,最大值,最小值,格式化输出,过滤掉小于<span class="number">3</span>数据 </span><br><span class="line"><span class="keyword">val</span> intArr = <span class="type">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>) </span><br><span class="line">println(intArr.sum) </span><br><span class="line">println(intArr.max) </span><br><span class="line">println(intArr.min) </span><br><span class="line">println(intArr.mkString) </span><br><span class="line">println(intArr mkString “,”) </span><br><span class="line">println(intArr.mkString(“(”,“,”,“)”)) </span><br><span class="line">println(intArr.dropWhile(_&lt;<span class="number">3</span>) mkString “,”) </span><br><span class="line"></span><br><span class="line">多维数组 </span><br><span class="line"><span class="keyword">var</span> multiArr = <span class="type">Array</span>(<span class="type">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),<span class="type">Array</span>(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)) </span><br><span class="line">println(multiArr(<span class="number">1</span>)(<span class="number">2</span>)) </span><br><span class="line"><span class="keyword">for</span> (elem ← multiArr) &#123;println(elem mkString(“,”))&#125;</span><br></pre></td></tr></table></figure>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><h3 id="List的定义"><a href="#List的定义" class="headerlink" title="List的定义"></a>List的定义</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> cars = <span class="type">List</span>(“bmw”,“volvo”) </span><br><span class="line"><span class="keyword">val</span> cars = <span class="type">List</span>.apply(“bmw”,“volvo”) </span><br><span class="line"><span class="keyword">val</span> nums = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">8</span>) </span><br><span class="line"><span class="keyword">var</span> cars:<span class="type">List</span>[<span class="type">Object</span>]=<span class="type">List</span>(“<span class="type">BMW</span>”,“<span class="type">Volvo</span>”) </span><br><span class="line"><span class="keyword">var</span> list= <span class="type">List</span>() </span><br><span class="line"><span class="keyword">var</span> cars:<span class="type">List</span>[<span class="type">String</span>]=<span class="type">List</span>() </span><br><span class="line"></span><br><span class="line">采用 :: 及<span class="type">Nil</span>进行列表构建 </span><br><span class="line"><span class="keyword">val</span> nums = <span class="number">1</span> :: (<span class="number">2</span> :: (<span class="number">3</span>:: (<span class="number">4</span>::<span class="type">Nil</span>))) </span><br><span class="line">相等于 </span><br><span class="line"><span class="keyword">val</span> nums = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>) </span><br><span class="line">相等于 </span><br><span class="line"><span class="keyword">val</span> nums = <span class="number">1</span>::<span class="number">2</span>::<span class="number">3</span>::<span class="number">4</span>::<span class="type">Nil</span> </span><br><span class="line"></span><br><span class="line">多重<span class="type">List</span> </span><br><span class="line"><span class="keyword">val</span> cars=<span class="type">List</span>(<span class="type">List</span>(“<span class="type">BMW</span>”,“<span class="number">200</span>万”,“red”),<span class="type">List</span>(“<span class="type">BYD</span>”,“<span class="number">20</span>万”,“white”)) </span><br><span class="line"></span><br><span class="line">*list一旦被创建，其值不能被改变 </span><br><span class="line">*list具有递归结构(<span class="type">Recursive</span> <span class="type">Structure</span>)，例如链表结构 </span><br><span class="line">*<span class="type">List</span>类型和其它集合类型一样，它具有协变性(<span class="type">Covariant</span>),即对于类型<span class="type">S</span>和<span class="type">T</span>,如果<span class="type">S</span>是<span class="type">T</span>的子类型，则<span class="type">List</span>[<span class="type">S</span>]也是<span class="type">List</span>[<span class="type">T</span>]的子类型 </span><br><span class="line">*空的<span class="type">List</span>,其类型为<span class="type">Nothing</span>,<span class="type">Nothing</span>在<span class="type">Scala</span>的继承层次中的最低层,即<span class="type">Nothing</span>是任何<span class="type">Scala</span>其它类型如<span class="type">String</span>,<span class="type">Object</span>等的子类 </span><br><span class="line">\* :: 操作符的优先级是从右往左的</span><br></pre></td></tr></table></figure>
<h3 id="list常用操作"><a href="#list常用操作" class="headerlink" title="list常用操作"></a>list常用操作</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">判断是否为空 </span><br><span class="line">cars.isEmpty </span><br><span class="line"></span><br><span class="line">取第一个元素 </span><br><span class="line">cars.head </span><br><span class="line"></span><br><span class="line">取第一个元素外的元素列表 </span><br><span class="line">cars.tail </span><br><span class="line">cars.reverse.init </span><br><span class="line"></span><br><span class="line">init取最后一个元素外的元素列表 </span><br><span class="line">cars.init </span><br><span class="line">cars.reverse.tail </span><br><span class="line"></span><br><span class="line">取最后一个 </span><br><span class="line">cars:last </span><br><span class="line"></span><br><span class="line">取第二个元素 </span><br><span class="line">cars.tail.head </span><br><span class="line"></span><br><span class="line">取倒数第二个元素 </span><br><span class="line">cars.init.last </span><br><span class="line"></span><br><span class="line">元素倒置 </span><br><span class="line">cars.reverse </span><br><span class="line"></span><br><span class="line">丢弃前<span class="type">N</span>个元素,返回元素列表 </span><br><span class="line">cars drop <span class="number">1</span> </span><br><span class="line"></span><br><span class="line">获取前几个元素列表 </span><br><span class="line">cars take <span class="number">2</span> </span><br><span class="line">cars.take(<span class="number">2</span>) </span><br><span class="line"></span><br><span class="line">将列表进行分割,从<span class="type">Index</span> <span class="type">N</span>的位置进行分割，返回前后两个元素列表，位置Ｎ算后面的元素列表 </span><br><span class="line">cars.splitAt(<span class="number">1</span>) </span><br><span class="line">(cars.take(<span class="number">1</span>),cars.drop1) </span><br><span class="line"></span><br><span class="line">zip 返回的是<span class="type">List</span>类型的元组(<span class="type">Tuple</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> arr = <span class="type">List</span>(<span class="string">"1"</span>,<span class="string">"6"</span>,<span class="string">"3"</span>,<span class="string">"5"</span>,<span class="string">"9"</span>) </span><br><span class="line">arr: <span class="type">List</span>[<span class="type">String</span>] = <span class="type">List</span>(<span class="number">1</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">9</span>) </span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> num = <span class="type">List</span>(<span class="number">1</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">9</span>) </span><br><span class="line">num: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">1</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">9</span>) </span><br><span class="line"></span><br><span class="line">scala&gt; arr zip num </span><br><span class="line">res99: <span class="type">List</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = <span class="type">List</span>((<span class="number">1</span>,<span class="number">1</span>), (<span class="number">6</span>,<span class="number">6</span>), (<span class="number">3</span>,<span class="number">3</span>), (<span class="number">5</span>,<span class="number">5</span>), (<span class="number">9</span>,<span class="number">9</span>))</span><br></pre></td></tr></table></figure>
<p>插入排序算法</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sort</span></span>(xs:<span class="type">List</span>[<span class="type">Int</span>]) :<span class="type">List</span>[<span class="type">Int</span>] =&#123;</span><br><span class="line">	<span class="keyword">if</span>(xs.isEmpty) <span class="type">Nil</span></span><br><span class="line">	<span class="keyword">else</span> insert(xs.head, sort(xs.tail))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert</span></span>(x:<span class="type">Int</span>, xs:<span class="type">List</span>[<span class="type">Int</span>]) :<span class="type">List</span>[<span class="type">Int</span>] =&#123;</span><br><span class="line">	<span class="keyword">if</span>(xs.isEmpty || x&lt;= xs.head) x:: xs</span><br><span class="line">	<span class="keyword">else</span> xs.head :: insert(x,xs.tail)	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>List连接操作 :::</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>):::<span class="type">List</span>(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">res35: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p>list相等判断</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> arr = <span class="type">List</span>(<span class="number">1</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">9</span>) </span><br><span class="line"><span class="keyword">val</span> arr1 = <span class="type">List</span>(<span class="string">"1"</span>,<span class="string">"6"</span>,<span class="string">"3"</span>,<span class="string">"5"</span>,<span class="string">"9"</span>) </span><br><span class="line">aaa == arr1  <span class="comment">//false </span></span><br><span class="line"><span class="keyword">val</span> arr = <span class="type">List</span>(<span class="string">"1"</span>,<span class="string">"6"</span>,<span class="string">"3"</span>,<span class="string">"5"</span>,<span class="string">"9"</span>)</span><br><span class="line"><span class="keyword">val</span> arr1 = <span class="type">List</span>(<span class="string">"1"</span>,<span class="string">"6"</span>,<span class="string">"3"</span>,<span class="string">"5"</span>,<span class="string">"9"</span>)</span><br><span class="line">arr == arr1  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>range方法，构建某一值范围内的List<br>val nums = List.range(2,9)<br>range主法，指定步长N,范围不存在的返回空List<br>val nums = List.range(2,100, 5)<br>val nums = List.range(100,20, -5) </p>
<p>flatten,将列表平滑成第一个元素</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="type">List</span>(<span class="type">List</span>(<span class="string">"aaa"</span>,<span class="string">"bbb"</span>),<span class="type">List</span>(<span class="string">"111"</span>,<span class="string">"222"</span>)).flatten </span><br><span class="line">res34: <span class="type">List</span>[<span class="type">String</span>] = <span class="type">List</span>(aaa, bbb, <span class="number">111</span>, <span class="number">222</span>)</span><br></pre></td></tr></table></figure>
<p>concat列表链接 </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="type">List</span>.concat(<span class="type">List</span>(<span class="string">"aaa"</span>,<span class="string">"bbb"</span>),<span class="type">List</span>(<span class="string">"111"</span>,<span class="string">"222"</span>)) res32: <span class="type">List</span>[<span class="type">String</span>] = <span class="type">List</span>(aaa, bbb, <span class="number">111</span>, <span class="number">222</span>) \\</span><br></pre></td></tr></table></figure>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>Set 不可重复，无序的集合<br>如果需要按添加顺序排序，可以使用LinkedHashSet实现 </p>
<p>val set = Set(1,2,3)<br>val mutableSet = mutable.Set(1,2,3) </p>
<p>添加元i<br>set+5 </p>
<p>遍历Set<br>for(i ← set+7)print(i) </p>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>val map = Map(1 → “one”,“two” → 2,2.3 → “three”)<br>val mutableMap = mutable.Map(1 → “one”,“two” → 2,2.3 → “three”)<br>println(map) </p>
<p>添加元素<br>println(map.+(4 → “four”)) </p>
<p>删除元素<br>println(map.-(“tow”)) </p>
<p>遍历map </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i&lt;-map)println(i+<span class="string">"\t"</span>+i._1+<span class="string">"\t"</span>+i._2)  </span><br><span class="line">map.foreach(e=&gt;&#123;</span><br><span class="line">      <span class="keyword">val</span> (k,v)=e</span><br><span class="line">      println(k,v) <span class="comment">//通过模式匹配获取元组内容</span></span><br><span class="line">      println(e._1,e._2) <span class="comment">//直接访问元组内容</span></span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>mutable map可以使用put添加元素<br>val mutableMap = mutable.Map(1 → “one”,“two” → 2,2.3 → “three”)<br>mutableMap.put(“four”,4)</p>
<p>判断key是不存在 map.contains(1) map.get(“key”)</p>
<h2 id="Queue队列"><a href="#Queue队列" class="headerlink" title="Queue队列"></a>Queue队列</h2><p>immutable queue<br>scala&gt; var queue=scala.collection.immutable.Queue(1,2,3)<br>queue: scala.collection.immutable.Queue[Int] = Queue(1, 2, 3) </p>
<p>出队<br>scala&gt; queue.dequeue<br>res38: (Int, scala.collection.immutable.Queue[Int]) = (1,Queue(2, 3)) </p>
<p>入队<br>scala&gt; queue.enqueue(4)<br>res40: scala.collection.immutable.Queue[Int] = Queue(1, 2, 3, 4) </p>
<p>mutable queue<br>scala&gt; var queue=scala.collection.mutable.Queue(1,2,3,4,5)<br>queue: scala.collection.mutable.Queue[Int] = Queue(1, 2, 3, 4, 5) </p>
<p>入队操作<br>scala&gt; queue += 5<br>res43: scala.collection.mutable.Queue[Int] = Queue(1, 2, 3, 4, 5, 5) </p>
<p>集合方式<br>scala&gt; queue ++= List(6,7,8)<br>res45: scala.collection.mutable.Queue[Int] = Queue(1, 2, 3, 4, 5, 5, 6, 7, 8) </p>
<h2 id="Scala-collection"><a href="#Scala-collection" class="headerlink" title="Scala.collection"></a>Scala.collection</h2><p>scala会默认导入以几个包：<br>import java.lang<em><br>import scala.</em><br>import Predef._ </p>
<p><em>Predef对象中包含了Set、Map等的定义 
</em>在Scala中，默认使用的immutable集合，如果需要使用mutable集合，需要在在程序中import<br><em>immutable 不可变的集合，一量被创建，便不能被改变，添加、删除、更新操作返回的是新的集合，原集合保持不变 
</em>mutable 可变的集合，可以更新或修改，添加、删除、修改元素将作用于原集合 </p>
<p>scala.collection包中的集合类层次结构如下图: </p>
<p><img src="https://img-blog.csdn.net/20170409120100728" alt="img"></p>
<p>scala.collection.immutable包中的类层次结构: </p>
<p><img src="https://img-blog.csdn.net/20170409120130151" alt="img"></p>
<p>scala.collection.mutable包中的类层次结构:<br><img src="https://img-blog.csdn.net/20170409120205432" alt="img"></p>
<p>可变集合与不可变集合对应关系： </p>
<p><img src="https://img-blog.csdn.net/20170409120636856?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHVhbmdodWl0YW4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<h2 id="函数字面量（值函数）"><a href="#函数字面量（值函数）" class="headerlink" title="函数字面量（值函数）"></a>函数字面量（值函数）</h2><p>函数字面量（function literal），也称值函数（function values），指的是函数可以赋值给变量。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> increase=(x:<span class="type">Int</span>)=&gt;x+<span class="number">1</span></span><br><span class="line"><span class="comment">//=&gt;左侧的表示输入参数，右侧的表示方法体</span></span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">increase</span></span>(x:<span class="type">Int</span>)=x+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法体中多个语句则使用&#123;&#125;</span></span><br><span class="line"><span class="keyword">val</span> increase=(x:<span class="type">Int</span>)=&gt;&#123;</span><br><span class="line">      println(<span class="string">"begin"</span>)</span><br><span class="line">      println(<span class="string">"end"</span>)</span><br><span class="line">      x+<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//数组的map方法中调用（写法1）</span></span><br><span class="line"><span class="comment">//写法1</span></span><br><span class="line">println(<span class="type">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>).map(increase).mkString(“,”))</span><br><span class="line"><span class="comment">//写法2 匿名函数写法</span></span><br><span class="line">println(<span class="type">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>).map((x:<span class="type">Int</span>)=&gt;x+<span class="number">1</span>) mkString “,”)</span><br></pre></td></tr></table></figure>
<h2 id="函数简化"><a href="#函数简化" class="headerlink" title="函数简化"></a>函数简化</h2><p><em>大扩号中只有一行操作时，大扩号可以省掉， 
</em>方法的调用可以省略“.”,用空格代替<br>*参数类型推断写法 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">println(Array(1,2,3) map((x)=&gt;x+1) mkString &quot;,&quot;)</span><br><span class="line">println(Array(1,2,3) map((x)=&gt;x+1) mkString(&quot;,&quot;))</span><br></pre></td></tr></table></figure>
<p>*函数只有一个参数的话，可以省略()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; Array(1,2,3,4) map&#123;x=&gt;x+1&#125; mkString(&quot;,&quot;)</span><br><span class="line">res28: String = 2,3,4,5</span><br></pre></td></tr></table></figure>
<p>*如果参数右边只出现一次，则可以进一步简化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; Array(1,2,3,4) map&#123;_+1&#125; mkString(&quot;,&quot;)</span><br><span class="line">res29: String = 2,3,4,5</span><br></pre></td></tr></table></figure>
<p>*值函数简化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val fun1=1+(_:Int)</span><br><span class="line">val fun2:(Double)=&gt;Double=1+_</span><br></pre></td></tr></table></figure>
<p>*函数参数,即将一个函数做为参数传入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def convertIntToString(f:(Int)=&gt;String)=f(4)</span><br><span class="line"></span><br><span class="line">def multiply(factor:Double)=(x:Double)=&gt;factor*x</span><br><span class="line">    var b = multiply(4)</span><br><span class="line">    println(b(1))</span><br></pre></td></tr></table></figure>
<h2 id="函数闭包-Closure"><a href="#函数闭包-Closure" class="headerlink" title="函数闭包(Closure)"></a>函数闭包(Closure)</h2><p>(x:Int)⇒x+more,这里的more是一个自由变量(Free Variable),more是一个没有指定含义的不定变量<br>而x的类型确定，值在函数调用的时候被赋值，称这种变量为绑定变量(Bound Variable) </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(x:<span class="type">Int</span>)=&gt;x+more </span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> more=<span class="number">3</span> </span><br><span class="line"> <span class="keyword">var</span> fun = (x:<span class="type">Int</span>)=&gt;x+more</span><br><span class="line"></span><br><span class="line"> more =<span class="number">10</span></span><br><span class="line"> println(fun(<span class="number">1</span>))</span><br><span class="line"> println(fun(<span class="number">13</span>))</span><br><span class="line"></span><br><span class="line"> more =<span class="number">10.87</span></span><br><span class="line"> println(fun(<span class="number">1</span>))</span><br><span class="line"> println(fun(<span class="number">13</span>))</span><br><span class="line"><span class="keyword">var</span> sum=<span class="number">0</span></span><br><span class="line"><span class="keyword">val</span> list = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">88</span>,<span class="number">9</span>)</span><br><span class="line">list.foreach(sum+=_)</span><br></pre></td></tr></table></figure>
<p>*像这种运行时确定more类型及值的函数称为闭包，more是个自由变量，在运行时值和类型得以确定，这是一个由开放(free)到封闭的过程。</p>
]]></content>
      
        <categories>
            
            <category> 大数据 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Scala </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[如何开启一个线程，开启大量线程会有什么问题，如何优化？]]></title>
      <url>/%E5%A6%82%E4%BD%95%E5%BC%80%E5%90%AF%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%BC%80%E5%90%AF%E5%A4%A7%E9%87%8F%E7%BA%BF%E7%A8%8B%E4%BC%9A%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%EF%BC%9F.html</url>
      <content type="html"><![CDATA[<p><strong>这道题想考察什么？</strong></p>
<ol>
<li>是否了解线程开启的方式？</li>
<li>开启大量线程会引起什么问题？为什么？怎么优化？</li>
</ol>
<a id="more"></a>
<h3 id="考察的知识点"><a href="#考察的知识点" class="headerlink" title="考察的知识点"></a><strong>考察的知识点</strong></h3><ol>
<li>线程的开启方式</li>
<li>开启大量线程的问题</li>
<li>线程池</li>
</ol>
<h3 id="考生应该如何回答"><a href="#考生应该如何回答" class="headerlink" title="考生应该如何回答"></a><strong>考生应该如何回答</strong></h3><p><strong>1、首先，关于如何开启一个线程，大多数人可能都会说3种，Thread、Runnable、Callback嘛！但事实却不是这样的。</strong>看JDK里怎么说的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> * There are two ways to create a new thread of execution. One is to</span></span><br><span class="line"><span class="comment"> * declare a class to be a subclass of &lt;code&gt;Thread&lt;/code&gt;. </span></span><br><span class="line"><span class="comment"> * The other way to create a thread is to declare a class that</span></span><br><span class="line"><span class="comment"> * implements the &lt;code&gt;Runnable&lt;/code&gt; interface.</span></span><br><span class="line"><span class="comment"> * ....</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Thread源码的类描述中有这样一段，翻译一下，只有两种方法去创建一个执行线程，一种是声明一个Thread的子类，另一种是创建一个类去实现Runnable接口。惊不惊讶，并没有提到Callback。</p>
<ul>
<li>继承Thread类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadUnitTest</span> </span>&#123;</span><br><span class="line">​</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建MyThread实例</span></span><br><span class="line">        MyThread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        <span class="comment">//调用线程start的方法，进入可执行状态</span></span><br><span class="line">        myThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">//继承Thread类，重写内部run方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">​</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"test MyThread run"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>实现Runnable接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadUnitTest</span> </span>&#123;</span><br><span class="line">​</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRunnable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建MyRunnable实例，这其实只是一个任务，并不是线程</span></span><br><span class="line">        MyRunnable myRunnable = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">        <span class="comment">//交给线程去执行</span></span><br><span class="line">        <span class="keyword">new</span> Thread(myRunnable).start();</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">//实现Runnable接口，并实现内部run方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">​</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"test MyRunnable run"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>还是看看Callable是怎么回事吧。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadUnitTest</span> </span>&#123;</span><br><span class="line">​</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCallable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建MyCallable实例，需要与FutureTask结合使用</span></span><br><span class="line">        MyCallable myCallable = <span class="keyword">new</span> MyCallable();</span><br><span class="line">        <span class="comment">//创建FutureTask，与Runnable一样，也只能算是个任务</span></span><br><span class="line">        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(myCallable);</span><br><span class="line">        <span class="comment">//交给线程去执行</span></span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask).start();</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//get方法获取任务返回值，该方法是阻塞的</span></span><br><span class="line">            String result = futureTask.get();</span><br><span class="line">            System.out.println(result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">//实现Callable接口，并实现call方法，不同之处是该方法有返回值</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">​</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"test MyCallable run"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Callable的方式必须与FutureTask结合使用，我们看看FutureTask的继承关系。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//FutureTask实现了RunnableFuture接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">​</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="comment">//RunnableFuture接口继承Runnable和Future接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>真相大白了，其实实现Callback接口创建线程的方式，归根到底就是Runnable方式，只不过它是在Runnable的基础上又增加了一些能力，例如取消任务执行等。</p>
<p><strong>2、开启线程的几种方式算是答上了，那开启大量线程，或者说频繁开启线程到底会引起什么问题呢？</strong>众所周知，在Java中，调用Thread的start方法后，该线程即置为就绪状态，等待CPU的调度。这个流程里有两个关注点需要去理解。</p>
<ul>
<li>start内部怎样开启线程的？看看start方法是怎么实现的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread类的start方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 一系列状态检查</span></span><br><span class="line">        <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">   </span><br><span class="line">        group.add(<span class="keyword">this</span>);</span><br><span class="line">           </span><br><span class="line">        <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="comment">//调用start0方法，真正启动java线程的地方</span></span><br><span class="line">            start0();</span><br><span class="line">            started = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                 group.threadStartFailed(<span class="keyword">this</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line"><span class="comment">//start0方法是一个native方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">start0</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>JVM中，native方法与java方法存在一个映射关系，Java中的start0对应c层的JVM_StartThread方法，我们继续看一下。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">JVM_ENTRY(<span class="keyword">void</span>, JVM_StartThread(JNIEnv* env, jobject jthread))</span><br><span class="line">  JVMWrapper(<span class="string">"JVM_StartThread"</span>);</span><br><span class="line">  JavaThread *native_thread = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">bool</span> throw_illegal_thread_state = <span class="literal">false</span>;</span><br><span class="line">  &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="function">MutexLocker <span class="title">mu</span><span class="params">(Threads_lock)</span></span>;</span><br><span class="line">    <span class="comment">// 判断Java线程是否已经启动，如果已经启动过，则会抛异常。</span></span><br><span class="line">    <span class="keyword">if</span> (java_lang_Thread::thread(JNIHandles::resolve_non_null(jthread)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      throw_illegal_thread_state = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//如果没有启动过，走到这里else分支，去创建线程</span></span><br><span class="line">      <span class="comment">//分配c++线程结构并创建native线程</span></span><br><span class="line">      jlong size =</span><br><span class="line">             java_lang_Thread::stackSize(JNIHandles::resolve_non_null(jthread));</span><br><span class="line">   </span><br><span class="line">      <span class="keyword">size_t</span> sz = size &gt; <span class="number">0</span> ? (<span class="keyword">size_t</span>) size : <span class="number">0</span>;</span><br><span class="line">      <span class="comment">//注意这里new JavaThread</span></span><br><span class="line">      native_thread = <span class="keyword">new</span> JavaThread(&amp;thread_entry, sz);</span><br><span class="line">      <span class="keyword">if</span> (native_thread-&gt;osthread() != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        native_thread-&gt;prepare(jthread);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ......</span><br><span class="line">  Thread::start(native_thread);</span><br></pre></td></tr></table></figure>
<p>走到这里发现，Java层已经过渡到native层，但远远还没结束。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">JavaThread::JavaThread(ThreadFunction entry_point, <span class="keyword">size_t</span> stack_sz) :</span><br><span class="line">                          Thread()</span><br><span class="line">   &#123;</span><br><span class="line">     initialize();</span><br><span class="line">     _jni_attach_state = _not_attaching_via_jni;</span><br><span class="line">     set_entry_point(entry_point);</span><br><span class="line">     os::ThreadType thr_type = os::java_thread;</span><br><span class="line">     thr_type = entry_point == &amp;compiler_thread_entry ? os::compiler_thread :</span><br><span class="line">                                                        os::java_thread;</span><br><span class="line">     <span class="comment">//根据平台，调用create_thread，创建真正的内核线程                       </span></span><br><span class="line">     os::create_thread(<span class="keyword">this</span>, thr_type, stack_sz);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">bool</span> os::create_thread(Thread* thread, ThreadType thr_type,</span><br><span class="line">                          <span class="keyword">size_t</span> req_stack_size) &#123;</span><br><span class="line">       ......</span><br><span class="line">       <span class="keyword">pthread_t</span> tid;</span><br><span class="line">       <span class="comment">//利用pthread_create（）来创建线程</span></span><br><span class="line">       <span class="keyword">int</span> ret = pthread_create(&amp;tid, &amp;attr, (<span class="keyword">void</span>* (*)(<span class="keyword">void</span>*)) thread_native_entry, thread);</span><br><span class="line">       ......</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>pthread_create方法，第三个参数表示启动这个线程后要执行的方法的入口，第四个参数表示要给这个方法传入的参数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thread_native_entry</span><span class="params">(Thread *thread)</span> </span>&#123;</span><br><span class="line">  ......</span><br><span class="line">  <span class="comment">//thread_native_entry方法的最下面的run方法，这个thread就是上面传递下来的参数，也就是JavaThread</span></span><br><span class="line">  thread-&gt;run();</span><br><span class="line">  ......</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>终于开始执行run方法了！！！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//thread.cpp类</span></span><br><span class="line"><span class="keyword">void</span> JavaThread::run() &#123;</span><br><span class="line">  ......</span><br><span class="line">  <span class="comment">//调用内部thread_main_inner  </span></span><br><span class="line">  thread_main_inner();</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">void</span> JavaThread::thread_main_inner() &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>-&gt;has_pending_exception() &amp;&amp;</span><br><span class="line">   !java_lang_Thread::is_stillborn(<span class="keyword">this</span>-&gt;threadObj())) &#123;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function">ResourceMark <span class="title">rm</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">      <span class="keyword">this</span>-&gt;set_native_thread_name(<span class="keyword">this</span>-&gt;get_thread_name());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">HandleMark <span class="title">hm</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    <span class="comment">//注意：内部通过JavaCalls模块，调用了Java线程要执行的run方法</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;entry_point()(<span class="keyword">this</span>, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  DTRACE_THREAD_PROBE(stop, <span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">this</span>-&gt;<span class="built_in">exit</span>(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一条U字型代码调用链总算结束了，高呼一声，原来start之后做了这么多事情呀，稍微总结一下。</p>
<p>1) Java中调用Thread的star方法，通过JNI方式，调用到native层。</p>
<p>2) native层，JVM通过pthread_create方法创建一个系统内核线程，并指定内核线程的初始运行地址，即一个方法指针。</p>
<p>3) 在内核线程的初始运行方法中，利用JavaCalls模块，回调到java线程的run方法，开始java级别的线程执行。</p>
<p><strong>线程开启后CPU调度会发生什么？</strong></p>
<p>计算机的世界里，CPU会分为若干时间片，通过各种算法分配时间片来执行任务，有耳熟能详时间片轮转调度算法、短进程优先算法、优先级算法等。当一个任务的时间片用完，就会切换到另一个任务。在切换之前会保存上一个任务的状态，当下次再切换到该任务，就会加载这个状态， 这就是所谓的线程的上下文切换。很明显，上下文的切换是有开销的，包括很多方面，操作系统保存和恢复上下文的开销、线程调度器调度线程的开销和高速缓存重新加载的开销等。</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl16revnmaj30kz094t92.jpg" alt="img"></p>
<p>经过上面两个理论基础的回顾，开启大量线程引起的问题，总结起来，就两个字——<strong>开销</strong>。</p>
<ul>
<li>消耗时间。线程的创建和销毁都需要时间，当数量太大的时候，会影响效率。</li>
<li>消耗内存。创建更多的线程会消耗更多的内存，这是毋庸置疑的。线程频繁创建与销毁，还有可能引起内存抖动，频繁触发GC，最直接的表现就是卡顿。长而久之，内存资源占用过多或者内存碎片过多，系统甚至会出现OOM。</li>
<li>消耗CPU。在操作系统中，CPU都是遵循时间片轮转机制进行处理任务，线程数过多，必然会引起CPU频繁的进行线程上下文切换。这个代价是昂贵的，某些场景下甚至超过任务本身的消耗。</li>
</ul>
<p><strong>3、针对上面提及到的问题，我们自然需要进行优化。</strong>线程的本质是为了执行任务，在计算机的世界里，任务分大致分为两类，CPU密集型任务和IO密集型任务。</p>
<ul>
<li>CPU密集型任务，比如公式计算、资源解码等。这类任务要进行大量的计算，全都依赖CPU的运算能力，持久消耗CPU资源。所以针对这类任务，其实不应该开启大量线程。因为线程越多，花在线程切换的时间就越多，CPU执行效率就越低，一般CPU密集型任务同时进行的数量等于CPU的核心数，最多再加个1。</li>
<li>IO密集型任务，比如网络读写、文件读写等。这类任务不需要消耗太多的CPU资源，绝大部分时间是在IO操作上。所以针对这类任务，可以开启大量线程去提高CPU的执行效率，一般IO密集型任务同时进行的数量等于CPU的核心数的两倍。</li>
</ul>
<p>另外，在无法避免，必须要开启大量线程的情况下，我们也可以使用线程池代替直接创建线程的做法进行优化。线程池的基本作用就是复用已有的线程，从而减少线程的创建，降低开销。在Java中，线程池的使用还是非常方便的，JDK中提供了现成的ThreadPoolExecutor类，我们只需要按照自己的需求进行相应的参数配置即可，这里提供一个示例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程池使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolService</span> </span>&#123;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程池变量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ThreadPoolExecutor mThreadPoolExecutor;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> ThreadPoolService sInstance = <span class="keyword">null</span>;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程池中的核心线程数，默认情况下，核心线程一直存活在线程池中，即便他们在线程池中处于闲置状态。</span></span><br><span class="line"><span class="comment">     * 除非我们将ThreadPoolExecutor的allowCoreThreadTimeOut属性设为true的时候，这时候处于闲置的核心         * 线程在等待新任务到来时会有超时策略，这个超时时间由keepAliveTime来指定。一旦超过所设置的超时时间，闲     * 置的核心线程就会被终止。</span></span><br><span class="line"><span class="comment">     * CPU密集型任务  N+1   IO密集型任务   2*N</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> CORE_POOL_SIZE = Runtime.getRuntime().availableProcessors() + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程池中所容纳的最大线程数，如果活动的线程达到这个数值以后，后续的新任务将会被阻塞。包含核心线程数+非*      * 核心线程数。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_POOL_SIZE = Math.max(CORE_POOL_SIZE, <span class="number">10</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 非核心线程闲置时的超时时长，对于非核心线程，闲置时间超过这个时间，非核心线程就会被回收。</span></span><br><span class="line"><span class="comment">     * 只有对ThreadPoolExecutor的allowCoreThreadTimeOut属性设为true的时候，这个超时时间才会对核心线       * 程产生效果。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> KEEP_ALIVE_TIME = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于指定keepAliveTime参数的时间单位。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TimeUnit UNIT = TimeUnit.SECONDS;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程池中保存等待执行的任务的阻塞队列</span></span><br><span class="line"><span class="comment">     * ArrayBlockingQueue  基于数组实现的有界的阻塞队列</span></span><br><span class="line"><span class="comment">     * LinkedBlockingQueue  基于链表实现的阻塞队列</span></span><br><span class="line"><span class="comment">     * SynchronousQueue   内部没有任何容量的阻塞队列。在它内部没有任何的缓存空间</span></span><br><span class="line"><span class="comment">     * PriorityBlockingQueue   具有优先级的无限阻塞队列。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; WORK_QUEUE = <span class="keyword">new</span> LinkedBlockingDeque&lt;&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程工厂，为线程池提供新线程的创建。ThreadFactory是一个接口，里面只有一个newThread方法。 默认为DefaultThreadFactory类。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadFactory THREAD_FACTORY = Executors.defaultThreadFactory();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拒绝策略，当任务队列已满并且线程池中的活动线程已经达到所限定的最大值或者是无法成功执行任务，这时候       * ThreadPoolExecutor会调用RejectedExecutionHandler中的rejectedExecution方法。</span></span><br><span class="line"><span class="comment">     * CallerRunsPolicy  只用调用者所在线程来运行任务。</span></span><br><span class="line"><span class="comment">     * AbortPolicy  直接抛出RejectedExecutionException异常。</span></span><br><span class="line"><span class="comment">     * DiscardPolicy  丢弃掉该任务，不进行处理。</span></span><br><span class="line"><span class="comment">     * DiscardOldestPolicy   丢弃队列里最近的一个任务，并执行当前任务。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RejectedExecutionHandler REJECTED_HANDLER = <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy();</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ThreadPoolService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ThreadPoolService <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (ThreadPoolService.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    sInstance = <span class="keyword">new</span> ThreadPoolService();</span><br><span class="line">                    sInstance.initThreadPool();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sInstance;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mThreadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                    CORE_POOL_SIZE,</span><br><span class="line">                    MAXIMUM_POOL_SIZE,</span><br><span class="line">                    KEEP_ALIVE_TIME,</span><br><span class="line">                    UNIT,</span><br><span class="line">                    WORK_QUEUE,</span><br><span class="line">                    THREAD_FACTORY,</span><br><span class="line">                    REJECTED_HANDLER);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            LogUtil.printStackTrace(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向线程池提交任务,无返回值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> runnable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">        mThreadPoolExecutor.execute(runnable);</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向线程池提交任务,有返回值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> callable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">post</span><span class="params">(Callable&lt;T&gt; callable)</span> </span>&#123;</span><br><span class="line">        RunnableFuture&lt;T&gt; task = <span class="keyword">new</span> FutureTask&lt;T&gt;(callable);</span><br><span class="line">        mThreadPoolExecutor.execute(task);</span><br><span class="line">        <span class="keyword">return</span> task;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>备注：<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zMDk3MjQ5MDQ=" title="https://zhuanlan.zhihu.com/p/309724904">转载至知乎<i class="fa fa-external-link"></i></span></p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[事务特性-ACID]]></title>
      <url>/%E4%BA%8B%E5%8A%A1%E7%89%B9%E6%80%A7-ACID.html</url>
      <content type="html"><![CDATA[<p>事务具有4个特征，分别是原子性、一致性、隔离性和持久性，简称事务的ACID特性；</p>
<h2 id="原子性（atomicity"><a href="#原子性（atomicity" class="headerlink" title="原子性（atomicity)"></a>原子性（atomicity)</h2><p>一个事务要么全部提交成功，要么全部失败回滚，不能只执行其中的一部分操作，这就是事务的原子性。</p>
<a id="more"></a>
<h2 id="一致性（consistency"><a href="#一致性（consistency" class="headerlink" title="一致性（consistency)"></a>一致性（consistency)</h2><p>事务的执行不能破坏数据库数据的完整性和一致性，一个事务在执行之前和执行之后，数据库都必须处于一致性状态。</p>
<p>如果数据库系统在运行过程中发生故障，有些事务尚未完成就被迫中断，这些未完成的事务对数据库所作的修改有一部分已写入物理数据库，这是数据库就处于一种不正确的状态，也就是不一致的状态。</p>
<h2 id="隔离性（isolation）"><a href="#隔离性（isolation）" class="headerlink" title="隔离性（isolation）"></a>隔离性（isolation）</h2><p>事务的隔离性是指在并发环境中，并发的事务时相互隔离的，一个事务的执行不能不被其他事务干扰。不同的事务并发操作相同的数据时，每个事务都有各自完成的数据空间，即一个事务内部的操作及使用的数据对其他并发事务时隔离的，并发执行的各个事务之间不能相互干扰。</p>
<p>在标准SQL规范中，定义了4个事务隔离级别，不同的隔离级别对事务的处理不同，分别是：未授权读取，授权读取，可重复读取和串行化</p>
<p>1、读未提交（Read Uncommited），该隔离级别允许脏读取，其隔离级别最低；比如事务A和事务B同时进行，事务A在整个执行阶段，会将某数据的值从1开始一直加到10，然后进行事务提交，此时，事务B能够看到这个数据项在事务A操作过程中的所有中间值（如1变成2，2变成3等），而对这一系列的中间值的读取就是未授权读取</p>
<p>2、授权读取也称为已提交读（Read Commited），授权读取只允许获取已经提交的数据。比如事务A和事务B同时进行，事务A进行+1操作，此时，事务B无法看到这个数据项在事务A操作过程中的所有中间值，只能看到最终的10。另外，如果说有一个事务C，和事务A进行非常类似的操作，只是事务C是将数据项从10加到20，此时事务B也同样可以读取到20，即授权读取允许不可重复读取。</p>
<p>3、可重复读（Repeatable Read)</p>
<p>就是保证在事务处理过程中，多次读取同一个数据时，其值都和事务开始时刻是一致的，因此该事务级别禁止不可重复读取和脏读取，但是有可能出现幻影数据。所谓幻影数据，就是指同样的事务操作，在前后两个时间段内执行对同一个数据项的读取，可能出现不一致的结果。在上面的例子中，可重复读取隔离级别能够保证事务B在第一次事务操作过程中，始终对数据项读取到1，但是在下一次事务操作中，即使事务B（注意，事务名字虽然相同，但是指的是另一个事务操作）采用同样的查询方式，就可能读取到10或20；</p>
<p>4、串行化</p>
<p>是最严格的事务隔离级别，它要求所有事务被串行执行，即事务只能一个接一个的进行处理，不能并发执行。</p>
<h2 id="持久性（durability）"><a href="#持久性（durability）" class="headerlink" title="持久性（durability）"></a>持久性（durability）</h2><p>一旦事务提交，那么它对数据库中的对应数据的状态的变更就会永久保存到数据库中。–即使发生系统崩溃或机器宕机等故障，只要数据库能够重新启动，那么一定能够将其恢复到事务成功结束的状态。</p>
]]></content>
      
        <categories>
            
            <category> 数据库 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ACID </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OLAP和OLTP的区别]]></title>
      <url>/OLAP%E5%92%8COLTP%E7%9A%84%E5%8C%BA%E5%88%AB.html</url>
      <content type="html"><![CDATA[<p>OLAP（On-Line Analytical Processing）联机分析处理，也称为面向交易的处理过程，其基本特征是前台接收的用户数据可以立即传送到计算中心进行处理，并在很短的时间内给出处理结果，是对用户操作快速响应的方式之一。应用在数据仓库，使用对象是决策者。OLAP系统强调的是数据分析，响应速度要求没那么高。</p>
<a id="more"></a>
<p>OLTP（On-Line Transaction Processing）联机事务处理，它使分析人员能够迅速、一致、交互地从各个方面观察信息，以达到深入理解数据的目的。它具有FASMI(Fast Analysis of Shared Multidimensional Information)，即共享多维信息的快速分析的特征。主要应用是传统关系型数据库。OLTP系统强调的是内存效率，实时性比较高。</p>
<p>以下是OLAP和OLTP的比较：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkz929us64j30j7071q4g.jpg" alt="OLAP和OLTP的比较"></p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkz938wdycj30tp0fmwla.jpg" alt="联机业务与批处理业务比较"></p>
]]></content>
      
        <categories>
            
            <category> 数据库 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OLAP,OLTP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MySQL8.0修改密码问题]]></title>
      <url>/MySQL8-0%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81%E9%97%AE%E9%A2%98.html</url>
      <content type="html"><![CDATA[<p>MySQL5.7和之前的用户修改密码方式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -e "<span class="keyword">Set</span> <span class="keyword">password</span>=<span class="keyword">password</span>(‘<span class="number">123</span>’);"</span><br><span class="line">mysql -uroot -p123.com -e "<span class="keyword">use</span> mysql;<span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> authentication_string=<span class="keyword">password</span>(<span class="string">'456'</span>) <span class="keyword">where</span> <span class="keyword">user</span>=<span class="string">'root'</span>;"</span><br><span class="line"><span class="keyword">update</span> mysql.user <span class="keyword">set</span> authentication_string=<span class="keyword">password</span>(<span class="string">"123"</span>) <span class="keyword">where</span> <span class="keyword">user</span>=<span class="string">'root'</span>;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>以上三种方法在MySQL8.0以后版本中将不能使用，如果使用了将会导致在正确修改密码是报如下错误：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '123';</span><br><span class="line">ERROR 1396 (HY000): Operation <span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="keyword">failed</span> <span class="keyword">for</span> <span class="string">'root'</span>@<span class="string">'localhost'</span></span><br></pre></td></tr></table></figure>
<p>如遇上以上问题请使用update语句先清空authentication_string字段，然后再修改密码即可</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> authentication_string=<span class="string">''</span> <span class="keyword">where</span> <span class="keyword">user</span>=<span class="string">'root'</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">'root'</span>@<span class="string">'localhost'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">WITH</span> mysql_native_password <span class="keyword">BY</span> <span class="string">'你的密码'</span>;</span><br></pre></td></tr></table></figure>
<p>所以特别提醒童鞋们：</p>
<p>MySQL8.0后请使用alter修改用户密码，因为在MySQL8.0以后的加密方式为caching_sha2_password，如果使用update修改密码会给user表中root用户的authentication_string字段下设置newpassowrd值，当再使用alter user ‘root’@’localhost’ identified by ‘newpassword’修改密码时会一直报错，必须清空后再修改，因为authentication_string字段下只能是MySQL加密后的43位字符串密码，其他的会报格式错误，所以在MySQL8.0以后能修改密码的方法只能是：ALTER USER ‘root’@’localhost’ IDENTIFIED WITH mysql_native_password BY ‘你的密码’;</p>
]]></content>
      
        <categories>
            
            <category> 数据库 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MySQL8.0 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[centos7.5+Ambari2.7.3部署安装]]></title>
      <url>/centos7-5-Ambari2-7-3%E9%83%A8%E7%BD%B2%E5%AE%89%E8%A3%85.html</url>
      <content type="html"><![CDATA[<p>–环境信息：<br>182.15.240.145 master<br>182.15.240.146 slave1<br>182.15.240.147 slave2</p>
<a id="more"></a>
<p>–安装所需的包：<br><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmhvcnRvbndvcmtzLmNvbS9IRFBEb2N1bWVudHMvQW1iYXJpLTIuNy4zLjAvYmtfYW1iYXJpLWluc3RhbGxhdGlvbi9jb250ZW50L2FtYmFyaV9yZXBvc2l0b3JpZXMuaHRtbA==" title="https://docs.hortonworks.com/HDPDocuments/Ambari-2.7.3.0/bk_ambari-installation/content/ambari_repositories.html">ambari-2.7.3.0-centos7.tar.gz<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmhvcnRvbndvcmtzLmNvbS9IRFBEb2N1bWVudHMvQW1iYXJpLTIuNy4zLjAvYmtfYW1iYXJpLWluc3RhbGxhdGlvbi9jb250ZW50L2hkcF8zMV9yZXBvc2l0b3JpZXMuaHRtbA==" title="https://docs.hortonworks.com/HDPDocuments/Ambari-2.7.3.0/bk_ambari-installation/content/hdp_31_repositories.html">HDP-3.1.0.0-centos7-rpm.tar.gz<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmhvcnRvbndvcmtzLmNvbS9IRFBEb2N1bWVudHMvQW1iYXJpLTIuNy4zLjAvYmtfYW1iYXJpLWluc3RhbGxhdGlvbi9jb250ZW50L2hkcF8zMV9yZXBvc2l0b3JpZXMuaHRtbA==" title="https://docs.hortonworks.com/HDPDocuments/Ambari-2.7.3.0/bk_ambari-installation/content/hdp_31_repositories.html">HDP-UTILS-1.1.0.22-centos7.tar.gz<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cub3JhY2xlLmNvbS90ZWNobmV0d29yay9qYXZhL2phdmFzZS9kb3dubG9hZHMvamRrOC1kb3dubG9hZHMtMjEzMzE1MS5odG1s" title="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">jdk-8u102-linux-x64.tar.gz<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9kZXYubXlzcWwuY29tL2Rvd25sb2Fkcy9teXNxbC8=" title="https://dev.mysql.com/downloads/mysql/">mysql-5.7.27-1.el7.x86_64.rpm-bundle.tar<i class="fa fa-external-link"></i></span></p>
<p>注：以下所有操作都是用root权限！</p>
<p>一、卸载自带jdk - 所有机器</p>
<p>(1)查看自带JDk版本<br>rpm -qa|grep java</p>
<p>(2)卸载自带JDK</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rpm -e --nodeps java-<span class="number">1.8</span>.0-openjdk-headless-<span class="number">1.8</span>.0.161-<span class="number">0</span>.b14.el7_4.x86_64</span><br><span class="line">rpm -e --nodeps java-<span class="number">1.8</span>.0-openjdk-<span class="number">1.8</span>.0.161-<span class="number">0</span>.b14.el7_4.x86_64</span><br></pre></td></tr></table></figure>
<p>(3)上传JDk并解压<br>jdk版本：jdk-8u102-linux-x64.tar.gz<br>上传JDk包至/usr/local/jdk目录下，并切换到该目录（没有jdk目录则手动创建），执行远程拷贝命令如，每个节点的jdk安装路径一样。拷贝完后解压JDK包。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp jdk-8u102-linux-x64.tar.gz root@182.15.240.146:/usr/local/jdk</span><br><span class="line">scp jdk-8u102-linux-x64.tar.gz root@182.15.240.147:/usr/local/jdk</span><br></pre></td></tr></table></figure>
<p>解压后路径：/usr/local/jdk/jdk1.8.0_102</p>
<p>(4)配置JDk<br>每个节点都需要配置，且配置JDK的内容相同。<br>vim /etc/profile<br>末尾加入下配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/local/jdk/jdk1.8.0_102</span><br><span class="line">export CLASSPATH=$:CLASSPATH:$JAVA_HOME/lib/</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin</span><br></pre></td></tr></table></figure>
<p>(5)jdk生效<br>source /etc/profile</p>
<p>二、设置主机名称 - 所有机器<br>vim /etc/hostname<br>若有三个节点，选一个节点作为主节点，修改其hostname中为master，其他节点的主机名称依次修改为slave1、slave2。<br>然后使用命令：reboot重启生效。</p>
<p>三、修改Hosts - 所有机器<br>vim /etc/hosts</p>
<p>每个节点的hosts文件中添加如下配置：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">182.15.240.145 master</span><br><span class="line">182.15.240.146 slave1</span><br><span class="line">182.15.240.147 slave2</span><br></pre></td></tr></table></figure>
<p>四、修改network - 所有机器<br>vim /etc/sysconfig/network</p>
<p>添加如下配置：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> Created by anaconda</span><br><span class="line">NETWORKING=yes</span><br></pre></td></tr></table></figure>
<p>通过ping主机名看是否通讯正常。<br>ping slave1</p>
<p>五、打开安全限制 - 所有机器<br>vim /etc/security/limits.conf</p>
<p>文件末尾新增如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> End of file</span><br><span class="line">* soft nofile 65536</span><br><span class="line">* hard nofile 65536</span><br><span class="line">* soft nproc 131072</span><br><span class="line">* hard nproc 131072</span><br></pre></td></tr></table></figure>
<p>六、关闭防火墙 - 所有机器</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@master~]#systemctl disable firewalld</span><br><span class="line">[root@master~]#systemctl stop firewalld</span><br></pre></td></tr></table></figure>
<p>另外所有机器还需修改：<br>[root@master ~]# vim /etc/selinux/config<br>参数修改如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELINUX=disabled</span><br><span class="line">SELINUXTYPE=targeted</span><br></pre></td></tr></table></figure>
<p>七、同步时钟<br>1、安装chrony服务 - 所有机器<br>yum -y install chrony</p>
<p>2、设置master为主服务器，开启nptd服务（主服务器）</p>
<p>主服务器上该配置文件修改项如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/chrony.conf</span><br><span class="line">----------------------------</span><br><span class="line"><span class="meta">#</span> Use public servers from the pool.ntp.org project.</span><br><span class="line"><span class="meta">#</span> Please consider joining the pool (http://www.pool.ntp.org/join.html).</span><br><span class="line"><span class="meta">#</span> server 0.centos.pool.ntp.org iburst</span><br><span class="line"><span class="meta">#</span> server 1.centos.pool.ntp.org iburst</span><br><span class="line"><span class="meta">#</span> server 2.centos.pool.ntp.org iburst</span><br><span class="line"><span class="meta">#</span>server 3.centos.pool.ntp.org iburst</span><br><span class="line">server 182.15.240.145 iburst</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> Record the rate at which the system clock gains/losses time.</span><br><span class="line">driftfile /var/lib/chrony/drift</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> Allow the system clock to be stepped in the first three updates</span><br><span class="line"><span class="meta">#</span> if its offset is larger than 1 second.</span><br><span class="line">makestep 1.0 3</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> Enable kernel synchronization of the real-time clock (RTC).</span><br><span class="line">rtcsync</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> Enable hardware timestamping on all interfaces that support it.</span><br><span class="line"><span class="meta">#</span>hwtimestamp *</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> Increase the minimum number of selectable sources required to adjust</span><br><span class="line"><span class="meta">#</span> the system clock.</span><br><span class="line"><span class="meta">#</span>minsources 2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> Allow NTP client access from local network.</span><br><span class="line"><span class="meta">#</span>allow 192.168.0.0/16</span><br><span class="line">allow 182.15.240.0/24 </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> Serve time even if not synchronized to a time source.</span><br><span class="line"><span class="meta">#</span>local stratum 10</span><br><span class="line">local stratum 10</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> Specify file containing keys for NTP authentication.</span><br><span class="line"><span class="meta">#</span>keyfile /etc/chrony.keys</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> Specify directory for log files.</span><br><span class="line">logdir /var/log/chrony</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> Select which information is logged.</span><br><span class="line"><span class="meta">#</span>log measurements statistics tracking</span><br></pre></td></tr></table></figure>
<p>修改保存后执行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# systemctl restart chronyd.service #启动服务</span><br><span class="line">[root@master ~]# systemctl status chronyd.service #开机自启动</span><br></pre></td></tr></table></figure>
<p>查看时间同步状态：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chronyc -a makestep</span><br><span class="line">chronyc sourcestats</span><br><span class="line">chronyc sources -v</span><br></pre></td></tr></table></figure>
<p>3、子节点时间同步配置<br>vim /etc/chrony.conf<br>注释原来的server并新增如下配置即可然后重启服务：<br>server 182.15.240.145</p>
<p>[root@master ~]# systemctl restart chronyd.service #启动服务<br>[root@master ~]# systemctl status chronyd.service #开机自启动</p>
<p>每个子节点的chrony.conf里都要配置server 182.15.240.145，并重启服务！</p>
<p>八、SSH无密码登录 - 主节点<br>1、免密钥操作</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# ssh-keygen -t rsa 连接提示选yes ，密码提示填登录密码</span><br><span class="line">[root@master ~]# ssh-copy-id slave1</span><br><span class="line">[root@master ~]# ssh-copy-id slave2</span><br><span class="line">[root@master ~]# ssh-copy-id master</span><br></pre></td></tr></table></figure>
<p>测试是否实现了无密码登录:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# ssh slave1 date ;ssh slave2 date;ssh master date;</span><br><span class="line">2019年 04月 23日 星期一 14:18:13 CST</span><br><span class="line">2019年 04月 23日 星期一 14:18:13 CST</span><br><span class="line">2019年 04月 23日 星期一 14:18:13 CST</span><br></pre></td></tr></table></figure>
<p>2、保存密钥<br>将创建的秘钥拷贝出来，因为后面ambari安装的时候需要上传这个秘钥<br>。创建秘钥是在隐藏文件夹/root/.ssh/下面的，<br>所以需要先把秘钥拷贝到可见区域，然后拷贝到电脑上。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# cd /root/.ssh/</span><br><span class="line">[root@master .ssh]# ls</span><br><span class="line">authorized_keys id_rsa id_rsa.pub known_hosts</span><br><span class="line">[root@master .ssh]# cp id_rsa /root/</span><br><span class="line">[root@master .ssh]# ls /root/</span><br><span class="line">anaconda-ks.cfg id_rsa jdk-8u161-linux-x64.rpm</span><br></pre></td></tr></table></figure>
<p>id_rsa为密钥！</p>
<p>九、其他系统设置 - 所有机器</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@master ~]# sudo sh -c "echo umask 0022 &gt;&gt; /etc/profile"</span><br></pre></td></tr></table></figure>
<p>十、修改yum源，实现离线安装<br>1、安装httpd服务 - 主服务器</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# yum -y install httpd</span><br><span class="line">[root@master ~]# service httpd restart</span><br><span class="line">Redirecting to /bin/systemctl restart httpd.service</span><br><span class="line">[root@master ~]# chkconfig httpd on</span><br></pre></td></tr></table></figure>
<p>2、上传三个包放到/var/www/html目录下 - 主服务器<br>安装完成后，会生成 /var/www/html目录（相当于Tomcat的webapps目录），进入到/var/www/html目录下，<br>创建ambari和hdp目录，用来存放安装文件.</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@yum ~]# mkdir /var/www/html/ambari</span><br><span class="line">[root@yum ~]# mkdir /var/www/html/hdp</span><br><span class="line">[root@yum ~]# mkdir /var/www/html/hdp/HDP-UTILS-1.1.0.22</span><br><span class="line">[root@yum ~]# tar -zxvf ambari-2.7.3.0-centos7.tar.gz -C /var/www/html/ambari/</span><br><span class="line">[root@yum ~]# tar -zxvf HDP-3.1.0.0-centos7-rpm.tar.gz -C /var/www/html/hdp/</span><br><span class="line">[root@yum ~]# tar -zxvf HDP-UTILS-1.1.0.22-centos7.tar.gz -C /var/www/html/hdp/HDP-UTILS-1.1.0.22/</span><br></pre></td></tr></table></figure>
<p>3、启动httpd服务：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@yum ~]# systemctl start httpd    # 启动httpd</span><br><span class="line">[root@yum ~]# systemctl status httpd    # 查看httpd状态</span><br><span class="line">[root@yum ~]# systemctl enable httpd    # 设置httpd开机自启</span><br></pre></td></tr></table></figure>
<p>现在可以通过访问</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://182.15.240.145/ambari/ </span><br><span class="line">http://182.15.240.145/hdp/</span><br></pre></td></tr></table></figure>
<p>十一、制作本地源<br><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmhvcnRvbndvcmtzLmNvbS9IRFBEb2N1bWVudHMvQW1iYXJpLTIuNy4zLjAvYmtfYW1iYXJpLWluc3RhbGxhdGlvbi9jb250ZW50L2FtYmFyaV9yZXBvc2l0b3JpZXMuaHRtbA==" title="https://docs.hortonworks.com/HDPDocuments/Ambari-2.7.3.0/bk_ambari-installation/content/ambari_repositories.html">https://docs.hortonworks.com/HDPDocuments/Ambari-2.7.3.0/bk_ambari-installation/content/ambari_repositories.html<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmhvcnRvbndvcmtzLmNvbS9IRFBEb2N1bWVudHMvQW1iYXJpLTIuNy4zLjAvYmtfYW1iYXJpLWluc3RhbGxhdGlvbi9jb250ZW50L2hkcF8zMV9yZXBvc2l0b3JpZXMuaHRtbA==" title="https://docs.hortonworks.com/HDPDocuments/Ambari-2.7.3.0/bk_ambari-installation/content/hdp_31_repositories.html">https://docs.hortonworks.com/HDPDocuments/Ambari-2.7.3.0/bk_ambari-installation/content/hdp_31_repositories.html<i class="fa fa-external-link"></i></span></p>
<p>1、安装本地源 - 主服务器<br>(1)下载ambari.repo文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master ambari]# wget -O /etc/yum.repos.d/ambari.repo http://public-repo-1.hortonworks.com/ambari/centos7/2.x/updates/2.7.3.0/ambari.repo</span><br></pre></td></tr></table></figure>
<p>注：路径一定要配置正确！！！</p>
<p>修改配置文件：vim /etc/yum.repos.d/ambari.repo</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@master ambari]# vi ambari/centos7/2.7.3.0-139/ambari.repo</span><br><span class="line"><span class="meta">#</span>VERSION_NUMBER=2.7.3.0-139</span><br><span class="line">[ambari-2.7.3.0]</span><br><span class="line"><span class="meta">#</span>json.url = http://public-repo-1.hortonworks.com/HDP/hdp_urlinfo.json</span><br><span class="line">name=ambari Version - ambari-2.7.3.0</span><br><span class="line">baseurl=http://182.15.240.145/ambari/ambari/centos7/2.7.3.0-139</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=http://182.15.240.145/ambari/ambari/centos7/2.7.3.0-139/RPM-GPG-KEY/RPM-GPG-KEY-Jenkins</span><br><span class="line">enabled=1</span><br><span class="line">priority=1</span><br></pre></td></tr></table></figure>
<p>(2)配置HDP和HDP-TILS</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@yum yum.repos.d]# touch /etc/yum.repos.d/HDP.repo</span><br><span class="line">[root@master ambari]# vim HDP/centos7/3.1.0.0-78/hdp.repo</span><br><span class="line"><span class="meta">#</span>VERSION_NUMBER=3.1.0.0-78</span><br><span class="line">[HDP-3.1.0.0]</span><br><span class="line">name=HDP Version - HDP-3.1.0.0</span><br><span class="line">baseurl=http://182.15.240.145/hdp/HDP/centos7</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=http://182.15.240.145/hdp/HDP/centos7/3.1.0.0-78/RPM-GPG-KEY/RPM-GPG-KEY-Jenkins</span><br><span class="line">enabled=1</span><br><span class="line">priority=1</span><br><span class="line"></span><br><span class="line">[HDP-UTILS-1.1.0.22]</span><br><span class="line">name=HDP-UTILS Version - HDP-UTILS-1.1.0.22</span><br><span class="line">baseurl=http://182.15.240.145/hdp/HDP-UTILS-1.1.0.22</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=http://182.15.240.145/hdp/HDP-UTILS-1.1.0.22/HDP-UTILS/centos7/1.1.0.22/RPM-GPG-KEY/RPM-GPG-KEY-Jenkins</span><br><span class="line">enabled=1</span><br><span class="line">priority=1</span><br></pre></td></tr></table></figure>
<p>2、清理一下yum的缓存</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@master ambari]# yum clean all</span><br><span class="line">[root@master ambari]# yum makecache</span><br><span class="line">[root@master ambari]# yum repolist</span><br></pre></td></tr></table></figure>
<p>3、将创建好的文件拷贝到子节点 - 主服务器</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@master ambari]#cd /etc/yum.repos.d</span><br><span class="line">[root@master yum.repos.d]# scp ambari.repo HDP.repo slave1:$PWD</span><br><span class="line">[root@master yum.repos.d]# scp ambari.repo HDP.repo slave2:$PWD</span><br></pre></td></tr></table></figure>
<p>十二、安装ambari-server<br>1、以mysql为数据库安装 - 主服务器<br>mysql包版本：mysql-5.7.27-1.el7.x86_64.rpm-bundle.tar<br>上传到主节点/usr/local/mysql目录下并解压。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa |grep -i mysql</span><br><span class="line">rpm -qa |grep -i mariadb</span><br></pre></td></tr></table></figure>
<p>用rpm -e 删除包<br>强制卸载mariadb</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -e --nodeps mariadb-libs-5.5.44-2.el7.centos.x86_64</span><br></pre></td></tr></table></figure>
<p>这里是为了避免安装mysql时出现依赖错误，提前删除系统已有的mariadb和mysql包！</p>
<p>安装mysql可能用到的工具：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum -y install libaio</span><br><span class="line">yum -y install net-tools</span><br></pre></td></tr></table></figure>
<p>2、安装mysql-server:按照common–&gt;libs–&gt;client–&gt;server的顺序。若不按照此顺序，也会有一定“依赖”关系的提醒。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop mysql]# rpm -ivh mysql-community-common-5.7.18-1.el7.x86_64.rpm </span><br><span class="line">warning: mysql-community-common-5.7.18-1.el7.x86_64.rpm: Header V3 DSA/SHA1 Signature, key ID 5072e1f5: NOKEY</span><br><span class="line">Preparing... ################################# [100%]</span><br><span class="line">Updating / installing...</span><br><span class="line">1:mysql-community-common-5.7.18-1.e################################# [100%]</span><br><span class="line">[root@hadoop mysql]# rpm -ivh mysql-community-libs-5.7.18-1.el7.x86_64.rpm </span><br><span class="line">warning: mysql-community-libs-5.7.18-1.el7.x86_64.rpm: Header V3 DSA/SHA1 Signature, key ID 5072e1f5: NOKEY</span><br><span class="line">Preparing... ################################# [100%]</span><br><span class="line">Updating / installing...</span><br><span class="line">1:mysql-community-libs-5.7.18-1.el7################################# [100%]</span><br><span class="line">[root@hadoop mysql]# rpm -ivh mysql-community-client-5.7.18-1.el7.x86_64.rpm </span><br><span class="line">warning: mysql-community-client-5.7.18-1.el7.x86_64.rpm: Header V3 DSA/SHA1 Signature, key ID 5072e1f5: NOKEY</span><br><span class="line">Preparing... ################################# [100%]</span><br><span class="line">Updating / installing...</span><br><span class="line">1:mysql-community-client-5.7.18-1.e################################# [100%]</span><br><span class="line">[root@hadoop mysql]# rpm -ivh mysql-community-server-5.7.18-1.el7.x86_64.rpm </span><br><span class="line">warning: mysql-community-server-5.7.18-1.el7.x86_64.rpm: Header V3 DSA/SHA1 Signature, key ID 5072e1f5: NOKEY</span><br><span class="line">Preparing... ################################# [100%]</span><br><span class="line">Updating / installing...</span><br><span class="line">1:mysql-community-server-5.7.18-1.e################################# [100%]</span><br></pre></td></tr></table></figure>
<p>3、初始化mysql</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop mysql]# mysqld --initialize</span><br></pre></td></tr></table></figure>
<p>4、更改mysql数据库所属于用户及其所属于组</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop mysql]# chown mysql:mysql /var/lib/mysql -R</span><br></pre></td></tr></table></figure>
<p>5、启动mysql数据库</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop mysql]# cd /var/lib/mysql</span><br><span class="line">[root@hadoop mysql]# systemctl start mysqld.service</span><br><span class="line">[root@hadoop ~]# cd /var/log/</span><br><span class="line">[root@hadoop log]# grep 'password' mysqld.log </span><br><span class="line">2019-02-26T04:33:06.989818Z 1 [Note] A temporary password is generated for root@localhost: mxeV&amp;htW-3VC</span><br></pre></td></tr></table></figure>
<p>更改root用户密码，新版的mysql在第一次登录后更改密码前是不能执行任何命令的</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop log]# mysql -u root -p</span><br><span class="line">Enter password: </span><br><span class="line">Welcome to the MySQL monitor. Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 4</span><br><span class="line">Server version: 5.7.18</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.</span><br><span class="line"></span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"></span><br><span class="line">Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.</span><br><span class="line">更改密码</span><br><span class="line"><span class="meta">mysql&gt;</span> set password=password('oracle');</span><br><span class="line">Query OK, 0 rows affected, 1 warning (0.00 sec)</span><br><span class="line"></span><br><span class="line"><span class="meta">mysql&gt;</span> flush privileges;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"><span class="meta">mysql&gt;</span> grant all privileges on *.* to root@'%' identified by 'oracle' with grant option;</span><br><span class="line">Query OK, 0 rows affected, 1 warning (0.00 sec)</span><br><span class="line"></span><br><span class="line"><span class="meta">mysql&gt;</span> flush privileges;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>安装和配置ambari-server</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install ambari-server</span><br></pre></td></tr></table></figure>
<p>6、登录mysql创建ambari安装所需要的库</p>
<p>设置的账号后面配置ambari-server的时候会用到！！！</p>
<p>执行如下语句：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE ambari; </span><br><span class="line">use ambari; </span><br><span class="line">CREATE USER 'ambari'@'%' IDENTIFIED BY 'ambari123'; </span><br><span class="line">GRANT ALL PRIVILEGES ON *.* TO 'ambari'@'%'; </span><br><span class="line">CREATE USER 'ambari'@'localhost' IDENTIFIED BY 'ambari123'; </span><br><span class="line">GRANT ALL PRIVILEGES ON *.* TO 'ambari'@'localhost'; </span><br><span class="line">CREATE USER 'ambari'@'master' IDENTIFIED BY 'ambari123'; </span><br><span class="line">GRANT ALL PRIVILEGES ON *.* TO 'ambari'@'master'; </span><br><span class="line">FLUSH PRIVILEGES; </span><br><span class="line">source /var/lib/ambari-server/resources/Ambari-DDL-MySQL-CREATE.sql </span><br><span class="line">show tables; </span><br><span class="line">use mysql; </span><br><span class="line">select Host User Password from user where user='ambari'; </span><br><span class="line">CREATE DATABASE hive; </span><br><span class="line">use hive; </span><br><span class="line">CREATE USER 'hive'@'%' IDENTIFIED BY 'hive'; </span><br><span class="line">GRANT ALL PRIVILEGES ON *.* TO 'hive'@'%'; </span><br><span class="line">CREATE USER 'hive'@'localhost' IDENTIFIED BY 'hive'; </span><br><span class="line">GRANT ALL PRIVILEGES ON *.* TO 'hive'@'localhost'; </span><br><span class="line">CREATE USER 'hive'@'master' IDENTIFIED BY 'hive'; </span><br><span class="line">GRANT ALL PRIVILEGES ON *.* TO 'hive'@'master'; </span><br><span class="line">FLUSH PRIVILEGES; </span><br><span class="line">CREATE DATABASE oozie; </span><br><span class="line">use oozie; </span><br><span class="line">CREATE USER 'oozie'@'%' IDENTIFIED BY 'oozie'; </span><br><span class="line">GRANT ALL PRIVILEGES ON *.* TO 'oozie'@'%'; </span><br><span class="line">CREATE USER 'oozie'@'localhost' IDENTIFIED BY 'oozie'; </span><br><span class="line">GRANT ALL PRIVILEGES ON *.* TO 'oozie'@'localhost'; </span><br><span class="line">CREATE USER 'oozie'@'master' IDENTIFIED BY 'oozie'; </span><br><span class="line">GRANT ALL PRIVILEGES ON *.* TO 'oozie'@'master'; </span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>
<p>如果要重新执行以上语句，则需要先删除：<br>\1. delete from mysql.user where user=’sonar’; 删除用户<br>2.CREATE USER ‘sonar’@’%’IDENTIFIED BY ‘sonar’;天假用户<br>\3. flush privileges; 清理缓存<br>\4. select <em> from mysql.user where user=’sonar’;查看该用户是否存在 ，结果是null<br>\5. flush privileges;清理缓存<br>\6. GRANT ALL ON sonar.</em> TO ‘sonar’@’%’ IDENTIFIED BY ‘sonar’;用户操作授权</p>
<p>7、mysql与ambari-server的连接<br>下载mysql-connector-java-5.1.40.jar放到root文件下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir /usr/share/java</span><br><span class="line">cp /root/mysql-connector-java-5.1.40.jar /usr/share/java/mysql-connector-java.jar</span><br><span class="line">cp /usr/share/java/mysql-connector-java.jar /var/lib/ambari-server/resources/mysql-jdbc-driver.jar</span><br><span class="line">vi /etc/ambari-server/conf/ambari.properties</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">添加server.jdbc.driver.path=/usr/share/java/mysql-connector-java.jar</span><br><span class="line"></span><br><span class="line">8、初始化ambari-server</span><br><span class="line"></span><br><span class="line">[root@master ~]# ambari-server setup</span><br><span class="line">下面是配置执行流程，按照提示操作：</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">（1） 提示是否自定义设置。输入：y</span><br><span class="line">Customize user account for ambari-server daemon [y/n] (n)? y</span><br><span class="line">（2）ambari-server 账号。</span><br><span class="line">Enter user account for ambari-server daemon (root):</span><br><span class="line">如果直接回车就是默认选择root用户</span><br><span class="line">如果输入已经创建的用户就会显示：</span><br><span class="line">Enter user account for ambari-server daemon (root):ambari</span><br><span class="line">Adjusting ambari-server permissions and ownership...</span><br><span class="line">（3）检查防火墙是否关闭</span><br><span class="line">Adjusting ambari-server permissions and ownership...</span><br><span class="line">Checking firewall...</span><br><span class="line">WARNING: iptables is running. Confirm the necessary Ambari ports are accessible. Refer to the Ambari documentation for more details on ports.</span><br><span class="line">OK to continue [y/n] (y)?</span><br><span class="line">直接回车</span><br><span class="line">（4）设置JDK。输入：3</span><br><span class="line">Checking JDK...</span><br><span class="line">Do you want to change Oracle JDK [y/n] (n)? y</span><br><span class="line">[1] Oracle JDK 1.8 + Java Cryptography Extension (JCE) Policy Files 8</span><br><span class="line">[2] Oracle JDK 1.7 + Java Cryptography Extension (JCE) Policy Files 7</span><br><span class="line">[3] Custom JDK</span><br><span class="line">==============================================================================</span><br><span class="line">Enter choice (1): 3</span><br><span class="line">如果上面选择3自定义JDK,则需要设置JAVA_HOME。输入：/usr/java/jdk1.8.0_161</span><br><span class="line">WARNING: JDK must be installed on all hosts and JAVA_HOME must be valid on all hosts.</span><br><span class="line">WARNING: JCE Policy files are required for configuring Kerberos security. If you plan to use Kerberos,please make sure JCE Unlimited Strength Jurisdiction Policy Files are valid on all hosts.</span><br><span class="line">Path to JAVA_HOME: /usr/java/jdk1.8.0_131</span><br><span class="line">Validating JDK on Ambari Server...done.</span><br><span class="line">Completing setup...</span><br><span class="line">（5）数据库配置。选择：y</span><br><span class="line">Configuring database...</span><br><span class="line">Enter advanced database configuration [y/n] (n)? y</span><br><span class="line">（6）选择数据库类型。输入：3</span><br><span class="line">Configuring database...</span><br><span class="line">==============================================================================</span><br><span class="line">Choose one of the following options:</span><br><span class="line">[1] - PostgreSQL (Embedded)</span><br><span class="line">[2] - Oracle</span><br><span class="line">[3] - MySQL</span><br><span class="line">[4] - PostgreSQL</span><br><span class="line">[5] - Microsoft SQL Server (Tech Preview)</span><br><span class="line">[6] - SQL Anywhere</span><br><span class="line">==============================================================================</span><br><span class="line">Enter choice (3): 3</span><br><span class="line">（7）设置数据库的具体配置信息，根据实际情况输入，如果和括号内相同，则可以直接回车。如果想重命名，就输入。</span><br><span class="line">Hostname (localhost): master</span><br><span class="line">Port (3306): 3306</span><br><span class="line">Database name (ambari): ambari</span><br><span class="line">Username (ambari): ambari</span><br><span class="line">Enter Database Password (bigdata):ambari123</span><br><span class="line">Re-Enter password: ambari123</span><br><span class="line">（8）将Ambari数据库脚本导入到数据库</span><br><span class="line">WARNING: Before starting Ambari Server, you must run the following DDL against the database to create the schema: /var/lib/ambari-server/resources/Ambari-DDL-MySQL-CREATE.sql </span><br><span class="line">Proceed with configuring remote database connection properties [y/n] (y)? y</span><br><span class="line">[root@master ~]# ambari-server start</span><br></pre></td></tr></table></figure>
<p>错误处理：<br>如果出现错误，请注意查看日志，根据具体的错误内容进行处理，默认ambari-server的日志在/var/log/ambari-server/ambari-server.log里面。如果在处理日志的过程中或者后面安装的过程中出现一些莫名的错误，可以重置的安装。<br>如果上面进行的默认数据库的配置，可以使用下面的代码重置ambari-server。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# ambari-server stop</span><br><span class="line">[root@master ~]# ambari-server reset</span><br><span class="line">[root@master ~]# ambari-server setup</span><br></pre></td></tr></table></figure>
<p>如果选择的是第二种方式，就需要先执行上面的语句，然后手动将mysql里面创建的数据库进行删除。然后再重新执行第二步的操作</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# mysql -uroot -p</span><br><span class="line"><span class="meta">mysql&gt;</span> show databases;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| ambari |</span><br><span class="line">| hive |</span><br><span class="line">| oozie |</span><br><span class="line">| performance_schema |</span><br><span class="line">+--------------------+</span><br><span class="line">rows in set (0.00 sec)</span><br><span class="line"><span class="meta">mysql&gt;</span> drop database ambari;</span><br><span class="line"><span class="meta">mysql&gt;</span> drop database hive;</span><br><span class="line"><span class="meta">mysql&gt;</span> drop database oozie;</span><br></pre></td></tr></table></figure>
<p>先在mysql库的User表中删除ambari、hive和oozie用户，再重复第六小结的用户创建操作，然后执行第八小结<br>的命令：ambari-server setup。</p>
<p>9、启动ambari-server服务</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# ambari-server start</span><br><span class="line">Using python /usr/bin/python</span><br><span class="line">Starting ambari-server</span><br><span class="line">Ambari Server running with administrator privileges.</span><br><span class="line">Organizing resource files at /var/lib/ambari-server/resources...</span><br><span class="line">Ambari database consistency check started...</span><br><span class="line">Server PID at: /var/run/ambari-server/ambari-server.pid</span><br><span class="line">Server out at: /var/log/ambari-server/ambari-server.out</span><br><span class="line">Server log at: /var/log/ambari-server/ambari-server.log</span><br><span class="line">Waiting for server start..................................</span><br><span class="line">Server started listening on 8080</span><br><span class="line"></span><br><span class="line">DB configs consistency check: no errors and warnings were found.</span><br><span class="line">Ambari Server 'start' completed successfully.</span><br></pre></td></tr></table></figure>
<p>十三、安装部署HDP集群</p>
<p>1、登录界面<br>默认管理员账户登录， 账户：admin 密码：admin<br><span class="exturl" data-url="aHR0cDovLzE4Mi4xNS4yNDAuMTQ1OjgwODA=" title="http://182.15.240.145:8080">http://182.15.240.145:8080<i class="fa fa-external-link"></i></span></p>
<p>2、安装向导<br>(1)Launch Install Wizard<br>(2)配置集群名称；<br>(3)选择版本并修改本地源地址；<br>选HDP-3.1.00;<br>选Use Local Repository;<br>选redhat7:<br>HDP-3.1： <span class="exturl" data-url="aHR0cDovLzE4Mi4xNS4yNDAuMTQ1L2hkcC9IRFAvY2VudG9zNy8=" title="http://182.15.240.145/hdp/HDP/centos7/">http://182.15.240.145/hdp/HDP/centos7/<i class="fa fa-external-link"></i></span><br>HDP-3.1-GPL: <span class="exturl" data-url="aHR0cDovL3B1YmxpYy1yZXBvLTEuaG9ydG9ud29ya3MuY29tL0hEUC1HUEwvY2VudG9zNy8zLngvdXBkYXRlcy8zLjEuMC4wLw==" title="http://public-repo-1.hortonworks.com/HDP-GPL/centos7/3.x/updates/3.1.0.0/">http://public-repo-1.hortonworks.com/HDP-GPL/centos7/3.x/updates/3.1.0.0/<i class="fa fa-external-link"></i></span><br>HDP-UTILS-1.1.0.22: <span class="exturl" data-url="aHR0cDovLzE4Mi4xNS4yNDAuMTQ1L2hkcC9IRFAtVVRJTFMtMS4xLjAuMjIv" title="http://182.15.240.145/hdp/HDP-UTILS-1.1.0.22/">http://182.15.240.145/hdp/HDP-UTILS-1.1.0.22/<i class="fa fa-external-link"></i></span></p>
<p>配置节点和密钥<br>Target hosts填<br>master<br>slave1<br>slave2</p>
<p>从主节点的/root目录下下载密钥id_rsa，并上传即可！</p>
<p>使用第三方数据库mysql的时候需要执行：<br>ambari-server setup –jdbc-db=mysql –jdbc-driver=/var/lib/ambari-agent/lib/mysql-connector-java-5.1.24.jar</p>
<p>[root@master lib]# ambari-server setup –jdbc-db=mysql –jdbc-driver=/var/lib/ambari-agent/lib/mysql-connector-java-5.1.24.jarUsing python /usr/bin/python<br>Setup ambari-server<br>Copying /var/lib/ambari-agent/lib/mysql-connector-java-5.1.24.jar to /var/lib/ambari-server/resources/mysql-connector-java-5.1.24.jar<br>Creating symlink /var/lib/ambari-server/resources/mysql-connector-java-5.1.24.jar to /var/lib/ambari-server/resources/mysql-connector-java.jar<br>If you are updating existing jdbc driver jar for mysql with mysql-connector-java-5.1.24.jar. Please remove the old driver jar, from all hosts. Restarting services that need the driver, will automatically copy the new jar to the hosts.<br>JDBC driver was successfully initialized.<br>Ambari Server ‘setup’ completed successfully.</p>
<p>Database URL: jdbc:mysql://master/hive<br>Database Password: hive/hive</p>
<p>—————-最后一步的信息—————————————-<br>Admin Name : admin<br>Cluster Name : leap<br>Total Hosts : 3 (3 new)<br>Repositories:<br>redhat7 (HDP-3.1):<br>redhat7 (HDP-3.1-GPL):<br>redhat7 (HDP-UTILS-1.1.0.22):<br>Services:<br>HDFS DataNode : 3 hosts<br>NameNode : master<br>NFSGateway : 1 host<br>SNameNode : slave1</p>
<p>YARN + MapReduce2 Timeline Service V1.5 : slave1<br>NodeManager : 3 hosts<br>ResourceManager : master<br>Timeline Service V2.0 Reader : master<br>Registry DNS : master</p>
<p>Tez Clients : 3 hosts</p>
<p>Hive Metastore : slave1<br>HiveServer2 : slave1<br>Database : Existing MySQL / MariaDB Database</p>
<p>HBase Master : master<br>RegionServer : 2 hosts<br>Phoenix Query Server : 3 hosts</p>
<p>ZooKeeper Server : 3 hosts</p>
<p>Ambari Metrics Metrics Collector : slave2<br>Grafana : master</p>
<p>Kafka Broker : master</p>
<p>SmartSense Activity Analyzer : master<br>Activity Explorer : master<br>HST Server : master</p>
<p>Spark2 Livy for Spark2 Server : 2 hosts<br>History Server : master<br>Thrift Server : 2 hosts<br>-———————————-</p>
<p>主页： <span class="exturl" data-url="aHR0cDovLzE4Mi4xNS4yNDAuMTQ1OjgwODA=" title="http://182.15.240.145:8080">http://182.15.240.145:8080<i class="fa fa-external-link"></i></span> admin/admin<br>yarn： <span class="exturl" data-url="aHR0cDovL21hc3Rlcjo4MDg4L2NsdXN0ZXI=" title="http://master:8088/cluster">http://master:8088/cluster<i class="fa fa-external-link"></i></span></p>
]]></content>
      
        <categories>
            
            <category> 大数据 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ambari,HDP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CDH5.16.1集群企业真正离线部署]]></title>
      <url>/CDH5-16-1%E9%9B%86%E7%BE%A4%E4%BC%81%E4%B8%9A%E7%9C%9F%E6%AD%A3%E7%A6%BB%E7%BA%BF%E9%83%A8%E7%BD%B2.html</url>
      <content type="html"><![CDATA[<p>视频:<span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL2F2NTIxNjcyMTk=" title="https://www.bilibili.com/video/av52167219">https://www.bilibili.com/video/av52167219<i class="fa fa-external-link"></i></span><br>PS:建议先看课程视频1-2篇，再根据视频或文档部署，<br>如有问题，及时与@若泽数据J哥联系。</p>
<hr>
<h2 id="一-准备工作"><a href="#一-准备工作" class="headerlink" title="一.准备工作"></a>一.准备工作</h2><h4 id="1-离线部署主要分为三块"><a href="#1-离线部署主要分为三块" class="headerlink" title="1.离线部署主要分为三块:"></a>1.离线部署主要分为三块:</h4><p>a.MySQL离线部署<br>b.CM离线部署<br>c.Parcel文件离线源部署</p>
<a id="more"></a>
<h4 id="2-规划"><a href="#2-规划" class="headerlink" title="2.规划:"></a>2.规划:</h4><table>
<thead>
<tr>
<th style="text-align:left">节点</th>
<th style="text-align:left">MySQL部署组件</th>
<th style="text-align:left">Parcel文件离线源</th>
<th style="text-align:left">CM服务进程</th>
<th style="text-align:left">大数据组件</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">hadoop001</td>
<td style="text-align:left">MySQL</td>
<td style="text-align:left">Parcel</td>
<td style="text-align:left">Activity Monitor</td>
<td style="text-align:left">NN RM DN NM</td>
</tr>
<tr>
<td style="text-align:left">hadoop002</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">Alert Publisher Event Server</td>
<td style="text-align:left">DN NM</td>
</tr>
<tr>
<td style="text-align:left">hadoop003</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">Host Monitor Service Monitor</td>
<td style="text-align:left">DN NM</td>
</tr>
</tbody>
</table>
<h3 id="3-下载源"><a href="#3-下载源" class="headerlink" title="3.下载源:"></a>3.下载源:</h3><ul>
<li>CM<br>cloudera-manager-centos7-cm5.16.1_x86_64.tar.gz</li>
<li>Parcel<br>CDH-5.16.1-1.cdh5.16.1.p0.3-el7.parcel<br>CDH-5.16.1-1.cdh5.16.1.p0.3-el7.parcel.sha1<br>manifest.json</li>
<li>JDK<br><span class="exturl" data-url="aHR0cHM6Ly93d3cub3JhY2xlLmNvbS90ZWNobmV0d29yay9qYXZhL2phdmFzZS9kb3dubG9hZHMvamF2YS1hcmNoaXZlLWphdmFzZTgtMjE3NzY0OC5odG1s" title="https://www.oracle.com/technetwork/java/javase/downloads/java-archive-javase8-2177648.html">https://www.oracle.com/technetwork/java/javase/downloads/java-archive-javase8-2177648.html<i class="fa fa-external-link"></i></span><br>下载jdk-8u202-linux-x64.tar.gz</li>
<li>MySQL<br><span class="exturl" data-url="aHR0cHM6Ly9kZXYubXlzcWwuY29tL2Rvd25sb2Fkcy9teXNxbC81LjcuaHRtbCNkb3dubG9hZHM=" title="https://dev.mysql.com/downloads/mysql/5.7.html#downloads">https://dev.mysql.com/downloads/mysql/5.7.html#downloads<i class="fa fa-external-link"></i></span><br>下载mysql-5.7.26-el7-x86_64.tar.gz</li>
<li>MySQL jdbc jar<br>mysql-connector-java-5.1.47.jar<br>下载完成后要重命名去掉版本号，<br>mv mysql-connector-java-5.1.47.jar mysql-connector-java.jar</li>
</ul>
<hr>
<h3 id="准备好百度云-下载安装包"><a href="#准备好百度云-下载安装包" class="headerlink" title="准备好百度云,下载安装包:"></a>准备好百度云,下载安装包:</h3><p>链接:<span class="exturl" data-url="aHR0cHM6Ly9wYW4uYmFpZHUuY29tL3MvMTBzLU5hRkxmenRLdVdJbVpUaUJNakE=" title="https://pan.baidu.com/s/10s-NaFLfztKuWImZTiBMjA">https://pan.baidu.com/s/10s-NaFLfztKuWImZTiBMjA<i class="fa fa-external-link"></i></span>  密码:viqp</p>
<h2 id="二-集群节点初始化"><a href="#二-集群节点初始化" class="headerlink" title="二.集群节点初始化"></a>二.集群节点初始化</h2><h3 id="1-阿里云上海区购买3台，按量付费虚拟机"><a href="#1-阿里云上海区购买3台，按量付费虚拟机" class="headerlink" title="1.阿里云上海区购买3台，按量付费虚拟机"></a>1.阿里云上海区购买3台，按量付费虚拟机</h3><p>CentOS7.2操作系统，2核8G最低配置</p>
<h3 id="2-当前笔记本或台式机配置hosts文件"><a href="#2-当前笔记本或台式机配置hosts文件" class="headerlink" title="2.当前笔记本或台式机配置hosts文件"></a>2.当前笔记本或台式机配置hosts文件</h3><ul>
<li>MAC: /etc/hosts</li>
<li>Window: C:\windows\system32\drivers\etc\hosts</li>
</ul>
<p>公网地址:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1106.15.234.222 hadoop001  </span><br><span class="line">2106.15.235.200 hadoop002  </span><br><span class="line">3106.15.234.239 hadoop003</span><br></pre></td></tr></table></figure>
<h3 id="3-设置所有节点的hosts文件"><a href="#3-设置所有节点的hosts文件" class="headerlink" title="3.设置所有节点的hosts文件"></a>3.设置所有节点的hosts文件</h3><p>私有地址、内网地址:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1echo &quot;172.19.7.96 hadoop001&quot;&gt;&gt; /etc/hosts</span><br><span class="line">2echo &quot;172.19.7.98 hadoop002&quot;&gt;&gt; /etc/hosts</span><br><span class="line">3echo &quot;172.19.7.97 hadoop003&quot;&gt;&gt; /etc/hosts</span><br></pre></td></tr></table></figure>
<h3 id="4-关闭所有节点的防火墙及清空规则"><a href="#4-关闭所有节点的防火墙及清空规则" class="headerlink" title="4.关闭所有节点的防火墙及清空规则"></a>4.关闭所有节点的防火墙及清空规则</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1systemctl stop firewalld </span><br><span class="line">2systemctl disable firewalld</span><br><span class="line">3iptables -F</span><br></pre></td></tr></table></figure>
<h3 id="5-关闭所有节点的selinux"><a href="#5-关闭所有节点的selinux" class="headerlink" title="5.关闭所有节点的selinux"></a>5.关闭所有节点的selinux</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1vi /etc/selinux/config</span><br><span class="line">2将SELINUX=enforcing改为SELINUX=disabled </span><br><span class="line">3设置后需要重启才能生效</span><br></pre></td></tr></table></figure>
<h3 id="6-设置所有节点的时区一致及时钟同步"><a href="#6-设置所有节点的时区一致及时钟同步" class="headerlink" title="6.设置所有节点的时区一致及时钟同步"></a>6.设置所有节点的时区一致及时钟同步</h3><p>6.1.时区</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> 1[root@hadoop001 ~]# date</span><br><span class="line"> 2Sat May 11 10:07:53 CST 2019</span><br><span class="line"> 3[root@hadoop001 ~]# timedatectl</span><br><span class="line"> 4      Local time: Sat 2019-05-11 10:10:31 CST</span><br><span class="line"> 5  Universal time: Sat 2019-05-11 02:10:31 UTC</span><br><span class="line"> 6        RTC time: Sat 2019-05-11 10:10:29</span><br><span class="line"> 7       Time zone: Asia/Shanghai (CST, +0800)</span><br><span class="line"> 8     NTP enabled: yes</span><br><span class="line"> 9NTP synchronized: yes</span><br><span class="line">10 RTC in local TZ: yes</span><br><span class="line">11      DST active: n/a</span><br></pre></td></tr></table></figure>
<h5 id="查看命令帮助，学习至关重要，无需百度，太👎"><a href="#查看命令帮助，学习至关重要，无需百度，太👎" class="headerlink" title="查看命令帮助，学习至关重要，无需百度，太👎"></a>查看命令帮助，学习至关重要，无需百度，太👎</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> 1[root@hadoop001 ~]# timedatectl --help</span><br><span class="line"> 2timedatectl [OPTIONS...] COMMAND ...</span><br><span class="line"> 3Query or change system time and date settings.</span><br><span class="line"> 4  -h --help                Show this help message</span><br><span class="line"> 5     --version             Show package version</span><br><span class="line"> 6     --no-pager            Do not pipe output into a pager</span><br><span class="line"> 7     --no-ask-password     Do not prompt for password</span><br><span class="line"> 8  -H --host=[USER@]HOST    Operate on remote host</span><br><span class="line"> 9  -M --machine=CONTAINER   Operate on local container</span><br><span class="line">10     --adjust-system-clock Adjust system clock when changing local RTC mode</span><br><span class="line">11Commands:</span><br><span class="line">12  status                   Show current time settings</span><br><span class="line">13  set-time TIME            Set system time</span><br><span class="line">14  set-timezone ZONE        Set system time zone</span><br><span class="line">15  list-timezones           Show known time zones</span><br><span class="line">16  set-local-rtc BOOL       Control whether RTC is in local time</span><br><span class="line">17  set-ntp BOOL             Control whether NTP is enabled</span><br></pre></td></tr></table></figure>
<h5 id="查看哪些时区"><a href="#查看哪些时区" class="headerlink" title="查看哪些时区"></a>查看哪些时区</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1[root@hadoop001 ~]# timedatectl list-timezones</span><br><span class="line">2Africa/Abidjan</span><br><span class="line">3Africa/Accra</span><br><span class="line">4Africa/Addis_Ababa</span><br><span class="line">5Africa/Algiers</span><br><span class="line">6Africa/Asmara</span><br><span class="line">7Africa/Bamako</span><br></pre></td></tr></table></figure>
<h5 id="所有节点设置亚洲上海时区"><a href="#所有节点设置亚洲上海时区" class="headerlink" title="所有节点设置亚洲上海时区"></a>所有节点设置亚洲上海时区</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1[root@hadoop001 ~]# timedatectl set-timezone Asia/Shanghai</span><br><span class="line">2[root@hadoop002 ~]# timedatectl set-timezone Asia/Shanghai</span><br><span class="line">3[root@hadoop003 ~]# timedatectl set-timezone Asia/Shanghai</span><br></pre></td></tr></table></figure>
<p>6.2.时间</p>
<h5 id="所有节点安装ntp"><a href="#所有节点安装ntp" class="headerlink" title="所有节点安装ntp"></a>所有节点安装ntp</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1[root@hadoop001 ~]# yum install -y ntp</span><br></pre></td></tr></table></figure>
<h5 id="选取hadoop001为ntp的主节点"><a href="#选取hadoop001为ntp的主节点" class="headerlink" title="选取hadoop001为ntp的主节点"></a>选取hadoop001为ntp的主节点</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1[root@hadoop001 ~]# vi /etc/ntp.conf</span><br></pre></td></tr></table></figure>
<h5 id="time"><a href="#time" class="headerlink" title="time"></a>time</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1server 0.asia.pool.ntp.org</span><br><span class="line">2server 1.asia.pool.ntp.org</span><br><span class="line">3server 2.asia.pool.ntp.org</span><br><span class="line">4server 3.asia.pool.ntp.org</span><br></pre></td></tr></table></figure>
<h5 id="当外部时间不可用时，可使用本地硬件时间"><a href="#当外部时间不可用时，可使用本地硬件时间" class="headerlink" title="当外部时间不可用时，可使用本地硬件时间"></a>当外部时间不可用时，可使用本地硬件时间</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1server 127.127.1.0 iburst local clock</span><br></pre></td></tr></table></figure>
<h5 id="允许哪些网段的机器来同步时间"><a href="#允许哪些网段的机器来同步时间" class="headerlink" title="允许哪些网段的机器来同步时间"></a>允许哪些网段的机器来同步时间</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1restrict 172.19.7.0 mask 255.255.255.0 nomodify notrap</span><br></pre></td></tr></table></figure>
<h5 id="开启ntpd及查看状态"><a href="#开启ntpd及查看状态" class="headerlink" title="开启ntpd及查看状态"></a>开启ntpd及查看状态</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> 1[root@hadoop001 ~]# systemctl start ntpd</span><br><span class="line"> 2[root@hadoop001 ~]# systemctl status ntpd</span><br><span class="line"> 3● ntpd.service - Network Time Service</span><br><span class="line"> 4   Loaded: loaded (/usr/lib/systemd/system/ntpd.service; enabled; vendor preset: disabled)</span><br><span class="line"> 5   Active: active (running) since Sat 2019-05-11 10:15:00 CST; 11min ago</span><br><span class="line"> 6 Main PID: 18518 (ntpd)</span><br><span class="line"> 7   CGroup: /system.slice/ntpd.service</span><br><span class="line"> 8           └─18518 /usr/sbin/ntpd -u ntp:ntp -g</span><br><span class="line"> 9May 11 10:15:00 hadoop001 systemd[1]: Starting Network Time Service...</span><br><span class="line">10May 11 10:15:00 hadoop001 ntpd[18518]: proto: precision = 0.088 usec</span><br><span class="line">11May 11 10:15:00 hadoop001 ntpd[18518]: 0.0.0.0 c01d 0d kern kernel time sync enabled</span><br><span class="line">12May 11 10:15:00 hadoop001 systemd[1]: Started Network Time Service.</span><br></pre></td></tr></table></figure>
<h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1[root@hadoop001 ~]# ntpq -p</span><br><span class="line">2     remote           refid      st t when poll reach   delay   offset  jitter</span><br><span class="line">3==============================================================================</span><br><span class="line">4 LOCAL(0)        .LOCL.          10 l  726   64    0    0.000    0.000   0.000</span><br></pre></td></tr></table></figure>
<h5 id="其他从节点停止禁用ntpd服务"><a href="#其他从节点停止禁用ntpd服务" class="headerlink" title="其他从节点停止禁用ntpd服务"></a>其他从节点停止禁用ntpd服务</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1[root@hadoop002 ~]# systemctl stop ntpd</span><br><span class="line">2[root@hadoop002 ~]# systemctl disable ntpd</span><br><span class="line">3Removed symlink /etc/systemd/system/multi-user.target.wants/ntpd.service.</span><br><span class="line">4[root@hadoop002 ~]# /usr/sbin/ntpdate hadoop001</span><br><span class="line">511 May 10:29:22 ntpdate[9370]: adjust time server 172.19.7.96 offset 0.000867 sec</span><br></pre></td></tr></table></figure>
<h5 id="每天凌晨同步hadoop001节点时间"><a href="#每天凌晨同步hadoop001节点时间" class="headerlink" title="每天凌晨同步hadoop001节点时间"></a>每天凌晨同步hadoop001节点时间</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> 1[root@hadoop002 ~]# crontab -e</span><br><span class="line"> 200 00 * * * /usr/sbin/ntpdate hadoop001  </span><br><span class="line"> 3[root@hadoop003 ~]# systemctl stop ntpd</span><br><span class="line"> 4[root@hadoop004 ~]# systemctl disable ntpd</span><br><span class="line"> 5Removed symlink /etc/systemd/system/multi-user.target.wants/ntpd.service.</span><br><span class="line"> 6[root@hadoop005 ~]# /usr/sbin/ntpdate hadoop001</span><br><span class="line"> 711 May 10:29:22 ntpdate[9370]: adjust time server 172.19.7.96 offset 0.000867 sec</span><br><span class="line"> 8#每天凌晨同步hadoop001节点时间</span><br><span class="line"> 9[root@hadoop003 ~]# crontab -e</span><br><span class="line">1000 00 * * * /usr/sbin/ntpdate hadoop001</span><br></pre></td></tr></table></figure>
<h3 id="7-部署集群的JDK"><a href="#7-部署集群的JDK" class="headerlink" title="7.部署集群的JDK"></a>7.部署集群的JDK</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1mkdir /usr/java</span><br><span class="line">2tar -xzvf jdk-8u45-linux-x64.tar.gz -C /usr/java/</span><br><span class="line">3#切记必须修正所属用户及用户组</span><br><span class="line">4chown -R root:root /usr/java/jdk1.8.0_45</span><br><span class="line">5echo &quot;export JAVA_HOME=/usr/java/jdk1.8.0_45&quot; &gt;&gt; /etc/profile</span><br><span class="line">6echo &quot;export PATH=$&#123;JAVA_HOME&#125;/bin:$&#123;PATH&#125;&quot; &gt;&gt; /etc/profile</span><br><span class="line">7source /etc/profile</span><br><span class="line">8which java</span><br></pre></td></tr></table></figure>
<h3 id="8-hadoop001节点离线部署MySQL5-7-假如觉得困难哟，就自行百度RPM部署，因为该部署文档是我司生产文档"><a href="#8-hadoop001节点离线部署MySQL5-7-假如觉得困难哟，就自行百度RPM部署，因为该部署文档是我司生产文档" class="headerlink" title="8.hadoop001节点离线部署MySQL5.7(假如觉得困难哟，就自行百度RPM部署，因为该部署文档是我司生产文档)"></a>8.hadoop001节点离线部署MySQL5.7(假如觉得困难哟，就自行百度RPM部署，因为该部署文档是我司生产文档)</h3><ul>
<li>文档链接:<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0hhY2tlcnVuY2xlL015U1FM" title="https://github.com/Hackeruncle/MySQL">https://github.com/Hackeruncle/MySQL<i class="fa fa-external-link"></i></span></li>
<li>视频链接:<span class="exturl" data-url="aHR0cHM6Ly9wYW4uYmFpZHUuY29tL3MvMWpkTThXZUlnOHN5VTBldkwxLXRET1E=" title="https://pan.baidu.com/s/1jdM8WeIg8syU0evL1-tDOQ">https://pan.baidu.com/s/1jdM8WeIg8syU0evL1-tDOQ<i class="fa fa-external-link"></i></span>  密码:whic</li>
</ul>
<h3 id="9-创建CDH的元数据库和用户、amon服务的数据库及用户"><a href="#9-创建CDH的元数据库和用户、amon服务的数据库及用户" class="headerlink" title="9.创建CDH的元数据库和用户、amon服务的数据库及用户"></a>9.创建CDH的元数据库和用户、amon服务的数据库及用户</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1create database cmf DEFAULT CHARACTER SET utf8;</span><br><span class="line">2create database amon DEFAULT CHARACTER SET utf8;</span><br><span class="line">3grant all on cmf.* TO &apos;cmf&apos;@&apos;%&apos; IDENTIFIED BY &apos;Ruozedata123456!&apos;;</span><br><span class="line">4grant all on amon.* TO &apos;amon&apos;@&apos;%&apos; IDENTIFIED BY &apos;Ruozedata123456!&apos;;</span><br><span class="line">5flush privileges;</span><br></pre></td></tr></table></figure>
<h3 id="10-hadoop001节点部署mysql-jdbc-jar"><a href="#10-hadoop001节点部署mysql-jdbc-jar" class="headerlink" title="10.hadoop001节点部署mysql jdbc jar"></a>10.hadoop001节点部署mysql jdbc jar</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1mkdir -p /usr/share/java/</span><br><span class="line">2cp mysql-connector-java.jar /usr/share/java/</span><br></pre></td></tr></table></figure>
<h2 id="三-CDH部署"><a href="#三-CDH部署" class="headerlink" title="三.CDH部署"></a>三.CDH部署</h2><h3 id="1-离线部署cm-server及agent"><a href="#1-离线部署cm-server及agent" class="headerlink" title="1.离线部署cm server及agent"></a>1.离线部署cm server及agent</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> 11.1.所有节点创建目录及解压</span><br><span class="line"> 2mkdir /opt/cloudera-manager</span><br><span class="line"> 3tar -zxvf cloudera-manager-centos7-cm5.16.1_x86_64.tar.gz -C /opt/cloudera-manager/</span><br><span class="line"> 41.2.所有节点修改agent的配置，指向server的节点hadoop001</span><br><span class="line"> 5sed -i &quot;s/server_host=localhost/server_host=hadoop001/g&quot; /opt/cloudera-manager/cm-5.16.1/etc/cloudera-scm-agent/config.ini</span><br><span class="line"> 61.3.主节点修改server的配置:</span><br><span class="line"> 7vi /opt/cloudera-manager/cm-5.16.1/etc/cloudera-scm-server/db.properties </span><br><span class="line"> 8com.cloudera.cmf.db.type=mysql</span><br><span class="line"> 9com.cloudera.cmf.db.host=hadoop001</span><br><span class="line">10com.cloudera.cmf.db.name=cmf</span><br><span class="line">11com.cloudera.cmf.db.user=cmf</span><br><span class="line">12com.cloudera.cmf.db.password=Ruozedata123456!</span><br><span class="line">13com.cloudera.cmf.db.setupType=EXTERNAL</span><br><span class="line">141.4.所有节点创建用户</span><br><span class="line">15useradd --system --home=/opt/cloudera-manager/cm-5.16.1/run/cloudera-scm-server/ --no-create-home --shell=/bin/false --comment &quot;Cloudera SCM User&quot; cloudera-scm</span><br><span class="line">161.5.目录修改用户及用户组</span><br><span class="line">17chown -R cloudera-scm:cloudera-scm /opt/cloudera-manager</span><br></pre></td></tr></table></figure>
<h3 id="2-hadoop001节点部署离线parcel源"><a href="#2-hadoop001节点部署离线parcel源" class="headerlink" title="2.hadoop001节点部署离线parcel源"></a>2.hadoop001节点部署离线parcel源</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> 12.1.部署离线parcel源</span><br><span class="line"> 2$ mkdir -p /opt/cloudera/parcel-repo</span><br><span class="line"> 3$ ll</span><br><span class="line"> 4total 3081664</span><br><span class="line"> 5-rw-r--r-- 1 root root 2127506677 May  9 18:04 CDH-5.16.1-1.cdh5.16.1.p0.3-el7.parcel</span><br><span class="line"> 6-rw-r--r-- 1 root root         41 May  9 18:03 CDH-5.16.1-1.cdh5.16.1.p0.3-el7.parcel.sha1</span><br><span class="line"> 7-rw-r--r-- 1 root root  841524318 May  9 18:03 cloudera-manager-centos7-cm5.16.1_x86_64.tar.gz</span><br><span class="line"> 8-rw-r--r-- 1 root root  185515842 Aug 10  2017 jdk-8u144-linux-x64.tar.gz</span><br><span class="line"> 9-rw-r--r-- 1 root root      66538 May  9 18:03 manifest.json</span><br><span class="line">10-rw-r--r-- 1 root root     989495 May 25  2017 mysql-connector-java.jar</span><br><span class="line">11$ cp CDH-5.16.1-1.cdh5.16.1.p0.3-el7.parcel /opt/cloudera/parcel-repo/</span><br><span class="line">12#切记cp时，重命名去掉1，不然在部署过程CM认为如上文件下载未完整，会持续下载</span><br><span class="line">13$ cp CDH-5.16.1-1.cdh5.16.1.p0.3-el7.parcel.sha1 /opt/cloudera/parcel-repo/CDH-5.16.1-1.cdh5.16.1.p0.3-el7.parcel.sha</span><br><span class="line">14$ cp manifest.json /opt/cloudera/parcel-repo/</span><br><span class="line">152.2.目录修改用户及用户组</span><br><span class="line">16$ chown -R cloudera-scm:cloudera-scm /opt/cloudera/</span><br></pre></td></tr></table></figure>
<h3 id="3-所有节点创建软件安装目录、用户及用户组权限"><a href="#3-所有节点创建软件安装目录、用户及用户组权限" class="headerlink" title="3.所有节点创建软件安装目录、用户及用户组权限"></a>3.所有节点创建软件安装目录、用户及用户组权限</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1mkdir -p /opt/cloudera/parcels</span><br><span class="line">2chown -R cloudera-scm:cloudera-scm /opt/cloudera/</span><br></pre></td></tr></table></figure>
<h3 id="4-hadoop001节点启动Server"><a href="#4-hadoop001节点启动Server" class="headerlink" title="4.hadoop001节点启动Server"></a>4.hadoop001节点启动Server</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">14.1.启动server</span><br><span class="line">2/opt/cloudera-manager/cm-5.16.1/etc/init.d/cloudera-scm-server start</span><br><span class="line">34.2.阿里云web界面，设置该hadoop001节点防火墙放开7180端口</span><br><span class="line">44.3.等待1min，打开 http://hadoop001:7180 账号密码:admin/admin</span><br><span class="line">54.4.假如打不开，去看server的log，根据错误仔细排查错误</span><br></pre></td></tr></table></figure>
<h3 id="5-所有节点启动Agent"><a href="#5-所有节点启动Agent" class="headerlink" title="5.所有节点启动Agent"></a>5.所有节点启动Agent</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1/opt/cloudera-manager/cm-5.16.1/etc/init.d/cloudera-scm-agent start</span><br></pre></td></tr></table></figure>
<h3 id="6-接下来，全部Web界面操作"><a href="#6-接下来，全部Web界面操作" class="headerlink" title="6.接下来，全部Web界面操作"></a>6.接下来，全部Web界面操作</h3><p><span class="exturl" data-url="aHR0cDovL2hhZG9vcDAwMTo3MTgwLw==" title="http://hadoop001:7180/">http://hadoop001:7180/<i class="fa fa-external-link"></i></span><br>账号密码:admin/admin</p>
<h3 id="7-欢迎使用Cloudera-Manager–最终用户许可条款与条件。勾选"><a href="#7-欢迎使用Cloudera-Manager–最终用户许可条款与条件。勾选" class="headerlink" title="7.欢迎使用Cloudera Manager–最终用户许可条款与条件。勾选"></a>7.欢迎使用Cloudera Manager–最终用户许可条款与条件。勾选</h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/m7Lx6FicJmUmSZI8m74xFUKB6wzFsFMOTMntgWCB2RNGM6yIaUia6hAywAgazVIRPibSZlCJgp4pTTQhWM0fjRVaQ/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<h3 id="8-欢迎使用Cloudera-Manager–您想要部署哪个版本？选择Cloudera-Express免费版本"><a href="#8-欢迎使用Cloudera-Manager–您想要部署哪个版本？选择Cloudera-Express免费版本" class="headerlink" title="8.欢迎使用Cloudera Manager–您想要部署哪个版本？选择Cloudera Express免费版本"></a>8.欢迎使用Cloudera Manager–您想要部署哪个版本？选择Cloudera Express免费版本</h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/m7Lx6FicJmUmSZI8m74xFUKB6wzFsFMOTNe2xHBYR8ibmF1sFhyLJngtqibTJylSZkCmcmBD3HtJu2Pw9G8o5WVQg/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<h3 id="9-感谢您选择Cloudera-Manager和CDH"><a href="#9-感谢您选择Cloudera-Manager和CDH" class="headerlink" title="9.感谢您选择Cloudera Manager和CDH"></a>9.感谢您选择Cloudera Manager和CDH</h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/m7Lx6FicJmUmSZI8m74xFUKB6wzFsFMOTjcibnIMwV6TJwVHVQZOLHnNsMA45g4hMa43LEgZv0AwdASia0CNibEhug/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<h3 id="10-为CDH集群安装指导主机。选择-当前管理的主机-，全部勾选"><a href="#10-为CDH集群安装指导主机。选择-当前管理的主机-，全部勾选" class="headerlink" title="10.为CDH集群安装指导主机。选择[当前管理的主机]，全部勾选"></a>10.为CDH集群安装指导主机。选择[当前管理的主机]，全部勾选</h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/m7Lx6FicJmUmSZI8m74xFUKB6wzFsFMOTq1NNOhRffwbBvXOezndFvm0kSdWhWH2hBHYLOzVv8fw4rdU2ibFvJcw/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<h3 id="11-选择存储库"><a href="#11-选择存储库" class="headerlink" title="11.选择存储库"></a>11.选择存储库</h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/m7Lx6FicJmUmSZI8m74xFUKB6wzFsFMOTjiceg4wvCaDzZySicaia4ZCwKjcyIBN1tW6L3nmtVkeMdt4TIiawiceia1DQ/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<h3 id="12-集群安装–正在安装选定Parcel假如"><a href="#12-集群安装–正在安装选定Parcel假如" class="headerlink" title="12.集群安装–正在安装选定Parcel假如"></a>12.集群安装–正在安装选定Parcel假如</h3><p>本地parcel离线源配置正确，则”下载”阶段瞬间完成，其余阶段视节点数与内部网络情况决定。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/m7Lx6FicJmUmSZI8m74xFUKB6wzFsFMOT3kX26zl0BFWoNvOqbF1FR6BvYjVoyC9eibOmZd7NE3ufZMVyfyLjBhg/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<h3 id="13-检查主机正确性"><a href="#13-检查主机正确性" class="headerlink" title="13.检查主机正确性"></a>13.检查主机正确性</h3><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> 113.1.建议将/proc/sys/vm/swappiness设置为最大值10。</span><br><span class="line"> 2swappiness值控制操作系统尝试交换内存的积极；</span><br><span class="line"> 3swappiness=0：表示最大限度使用物理内存，之后才是swap空间；</span><br><span class="line"> 4swappiness=100：表示积极使用swap分区，并且把内存上的数据及时搬迁到swap空间；</span><br><span class="line"> 5如果是混合服务器，不建议完全禁用swap，可以尝试降低swappiness。</span><br><span class="line"> 6临时调整：</span><br><span class="line"> 7sysctl vm.swappiness=10</span><br><span class="line"> 8永久调整：</span><br><span class="line"> 9cat &lt;&lt; EOF &gt;&gt; /etc/sysctl.conf</span><br><span class="line">10# Adjust swappiness value</span><br><span class="line">11vm.swappiness=10</span><br><span class="line">12EOF</span><br><span class="line">1313.2.已启用透明大页面压缩，可能会导致重大性能问题，建议禁用此设置。</span><br><span class="line">14临时调整：</span><br><span class="line">15echo never &gt; /sys/kernel/mm/transparent_hugepage/defrag</span><br><span class="line">16echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled</span><br><span class="line">17永久调整：</span><br><span class="line">18cat &lt;&lt; EOF &gt;&gt; /etc/rc.d/rc.local</span><br><span class="line">19# Disable transparent_hugepage</span><br><span class="line">20echo never &gt; /sys/kernel/mm/transparent_hugepage/defrag</span><br><span class="line">21echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled</span><br><span class="line">22EOF</span><br><span class="line">23# centos7.x系统，需要为&quot;/etc/rc.d/rc.local&quot;文件赋予执行权限</span><br><span class="line">24chmod +x /etc/rc.d/rc.local</span><br></pre></td></tr></table></figure>
<h3 id="14-自定义服务，选择部署Zookeeper、HDFS、Yarn服务"><a href="#14-自定义服务，选择部署Zookeeper、HDFS、Yarn服务" class="headerlink" title="14.自定义服务，选择部署Zookeeper、HDFS、Yarn服务"></a>14.自定义服务，选择部署Zookeeper、HDFS、Yarn服务</h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/m7Lx6FicJmUmSZI8m74xFUKB6wzFsFMOTDQOX5gC9KRxIUIY1eL561QticAaz23IX1ogYVRiajwXlbibddeax1a33w/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<h3 id="15-自定义角色分配"><a href="#15-自定义角色分配" class="headerlink" title="15.自定义角色分配"></a>15.自定义角色分配</h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/m7Lx6FicJmUmSZI8m74xFUKB6wzFsFMOTkp6Dw0RMWkoFTd4sbzBnrWiblxVkWLoPZSMziaRgY2DSE03fQRmBgJ4w/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<h3 id="16-数据库设置"><a href="#16-数据库设置" class="headerlink" title="16.数据库设置"></a>16.数据库设置</h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/m7Lx6FicJmUmSZI8m74xFUKB6wzFsFMOT0CQtn7eQbrjkPmTgQA6ye22UNfdZ618RexePfdrupRPtTrZlHLQRPw/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<h3 id="17-审改设置，默认即可"><a href="#17-审改设置，默认即可" class="headerlink" title="17.审改设置，默认即可"></a>17.审改设置，默认即可</h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/m7Lx6FicJmUmSZI8m74xFUKB6wzFsFMOT4qoAXY69p0jSUgGFmlzq5MAQ4xoRyu1B2ftqt3BKwJ8fZ8f7ogWyuw/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<h3 id="18-首次运行"><a href="#18-首次运行" class="headerlink" title="18.首次运行"></a>18.首次运行</h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/m7Lx6FicJmUmSZI8m74xFUKB6wzFsFMOTtF5tKDhqYhmlp4AasDK71tJ6BtAWk10FBibeJziaEPbWcbwFXxiaWtxfQ/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<h3 id="19-恭喜您"><a href="#19-恭喜您" class="headerlink" title="19.恭喜您!"></a>19.恭喜您!</h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/m7Lx6FicJmUmSZI8m74xFUKB6wzFsFMOTkvbFkWcLiawvHnOtSv5VORKXSKS8DurU6DQHnuzNp0JLmstVhNXRnvA/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<h3 id="20-主页"><a href="#20-主页" class="headerlink" title="20.主页"></a>20.主页</h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/m7Lx6FicJmUmSZI8m74xFUKB6wzFsFMOTMJE0wE0Apia0rSYXKVJzoRWIuia2ccrONV9PiaePpv4phgftKiax9PAfPQ/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<hr>
<h3 id="CDH全套课程目录，如有buy，加微信-ruoze-star"><a href="#CDH全套课程目录，如有buy，加微信-ruoze-star" class="headerlink" title="CDH全套课程目录，如有buy，加微信(ruoze_star)"></a>CDH全套课程目录，如有buy，加微信(ruoze_star)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"> 1    0.青云环境介绍和使用 </span><br><span class="line"> 2    1.Preparation        </span><br><span class="line"> 3        谈谈怎样入门大数据 </span><br><span class="line"> 4        谈谈怎样做好一个大数据平台的运营工作 </span><br><span class="line"> 5        Linux机器,各软件版本介绍及安装(录播) </span><br><span class="line"> 6    2.Introduction      </span><br><span class="line"> 7        Cloudera、CM及CDH介绍 </span><br><span class="line"> 8        CDH版本选择 </span><br><span class="line"> 9        CDH安装几种方式解读 </span><br><span class="line">10    3.Install&amp;UnInstall  </span><br><span class="line">11        集群节点规划,环境准备(NTP,Jdk and etc) </span><br><span class="line">12        MySQL编译安装及常用命令 </span><br><span class="line">13        推荐:CDH离线安装(踩坑心得,全面剖析) </span><br><span class="line">14        解读暴力卸载脚本 </span><br><span class="line">15    4.CDH Management      </span><br><span class="line">16        CDH体系架构剖析 </span><br><span class="line">17        CDH配置文件深度解析 </span><br><span class="line">18        CM的常用命令 </span><br><span class="line">19        CDH集群正确启动和停止顺序 </span><br><span class="line">20        CDH Tsquery Language </span><br><span class="line">21        CDH常规管理(监控/预警/配置/资源/日志/安全) </span><br><span class="line">22    5.Maintenance Experiment  </span><br><span class="line">23        HDFS HA 配置 及hadoop/hdfs常规命令 </span><br><span class="line">24        Yarn HA 配置 及yarn常规命令 </span><br><span class="line">25        Other CDH Components HA 配置 </span><br><span class="line">26        CDH动态添加删除服务(hive/spark/hbase) </span><br><span class="line">27        CDH动态添加删除机器 </span><br><span class="line">28        CDH动态添加删除及迁移DataNode进程等 </span><br><span class="line">29        CDH升级(5.10.0--&gt;5.12.0) </span><br><span class="line">30    6.Resource Management    </span><br><span class="line">31        Linux Cgroups </span><br><span class="line">32        静态资源池 </span><br><span class="line">33        动态资源池 </span><br><span class="line">34        多租户案例 </span><br><span class="line">35    7.Performance Tunning    </span><br><span class="line">36        Memory/CPU/Network/Disk及集群规划 </span><br><span class="line">37        Linux参数 </span><br><span class="line">38        HDFS参数 </span><br><span class="line">39        MapReduce及Yarn参数 </span><br><span class="line">40        其他服务参数 </span><br><span class="line">41    8.Cases Share        </span><br><span class="line">42        CDH4&amp;5之Alternatives命令 的研究 </span><br><span class="line">43        CDH5.8.2安装之Hash verification failed </span><br><span class="line">44        记录一次CDH4.8.6 配置HDFS HA 坑 </span><br><span class="line">45        CDH5.0集群IP更改 </span><br><span class="line">46        CDH的active namenode exit(GC)和彩蛋分享 </span><br><span class="line">47    9. Kerberos     </span><br><span class="line">48        Kerberos简介</span><br><span class="line">49        Kerberos体系结构</span><br><span class="line">50        Kerberos工作机制</span><br><span class="line">51        Kerberos安装部署</span><br><span class="line">52        CDH启用kerberos</span><br><span class="line">53        Kerberos开发使用(真实代码)</span><br><span class="line">54    10.Summary         </span><br><span class="line">55        总结</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="Join-us-if-you-have-a-dream"><a href="#Join-us-if-you-have-a-dream" class="headerlink" title="Join us if you have a dream."></a>Join us if you have a dream.</h4><h5 id="若泽数据官网"><a href="#若泽数据官网" class="headerlink" title="若泽数据官网"></a><span class="exturl" data-url="aHR0cDovL3J1b3plZGF0YS5jb20=" title="http://ruozedata.com">若泽数据官网<i class="fa fa-external-link"></i></span></h5><h5 id="腾讯课堂，搜若泽数据"><a href="#腾讯课堂，搜若泽数据" class="headerlink" title="腾讯课堂，搜若泽数据"></a><span class="exturl" data-url="aHR0cDovL3J1b3plLmtlLnFxLmNvbQ==" title="http://ruoze.ke.qq.com">腾讯课堂，搜若泽数据<i class="fa fa-external-link"></i></span></h5><h5 id="Bilibili网站-搜若泽数据"><a href="#Bilibili网站-搜若泽数据" class="headerlink" title="Bilibili网站,搜若泽数据"></a><span class="exturl" data-url="aHR0cHM6Ly9zcGFjZS5iaWxpYmlsaS5jb20vMzU2ODM2MzIz" title="https://space.bilibili.com/356836323">Bilibili网站,搜若泽数据<i class="fa fa-external-link"></i></span></h5><h5 id="若泽大数据–官方博客"><a href="#若泽大数据–官方博客" class="headerlink" title="若泽大数据–官方博客"></a><span class="exturl" data-url="aHR0cHM6Ly9ydW96ZWRhdGEuZ2l0aHViLmlv" title="https://ruozedata.github.io">若泽大数据–官方博客<i class="fa fa-external-link"></i></span></h5><h5 id="若泽大数据–博客一览"><a href="#若泽大数据–博客一览" class="headerlink" title="若泽大数据–博客一览"></a><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3J1b3plZGF0YS9CaWdEYXRhL2Jsb2IvbWFzdGVyL2Jsb2cvQmlnRGF0YUJsb2dPdmVydmlldy5tZA==" title="https://github.com/ruozedata/BigData/blob/master/blog/BigDataBlogOverview.md">若泽大数据–博客一览<i class="fa fa-external-link"></i></span></h5><h5 id="若泽大数据–内部学员面试题"><a href="#若泽大数据–内部学员面试题" class="headerlink" title="若泽大数据–内部学员面试题"></a><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3J1b3plZGF0YS9CaWdEYXRhL2Jsb2IvbWFzdGVyL2ludGVydmlldy8lRTUlQjglQjglRTglQTclODElRTklOUQlQTIlRTglQUYlOTUlRTklQTIlOTgubWQ=" title="https://github.com/ruozedata/BigData/blob/master/interview/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98.md">若泽大数据–内部学员面试题<i class="fa fa-external-link"></i></span></h5>]]></content>
      
        <categories>
            
            <category> 大数据 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CDH5.16.1 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[一次Java线程池误用引发的血案和总结]]></title>
      <url>/%E4%B8%80%E6%AC%A1Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%AF%AF%E7%94%A8%E5%BC%95%E5%8F%91%E7%9A%84%E8%A1%80%E6%A1%88%E5%92%8C%E6%80%BB%E7%BB%93.html</url>
      <content type="html"><![CDATA[<h2 id="这是一个十分严重的问题"><a href="#这是一个十分严重的问题" class="headerlink" title="这是一个十分严重的问题"></a>这是一个十分严重的问题</h2><p>自从最近的某年某月某天起，线上服务开始变得不那么稳定。在高峰期，时常有几台机器的内存持续飙升，并且无法回收，导致服务不可用。</p>
<a id="more"></a>
<p>例如GC时间采样曲线：</p>
<p><img src="https://img-blog.csdn.net/20180204155221776" alt="img"></p>
<p>和内存使用曲线：</p>
<p><img src="https://img-blog.csdn.net/20180204155254374" alt="img"></p>
<p>图中所示，18:50-19:00的阶段，已经处于服务不可用的状态了。上游服务的超时异常会增加，该台机器会触发熔断。熔断触发后，改台机器的流量会打到其他机器，其他机器发生类似的情况的可能性会提高，极端情况会引起所有服务宕机，曲线掉底。</p>
<p>因为线上内存过大，如果采用 jmap dump的方式，这个任务可能需要很久才可以执行完，同时把这么大的文件存放起来导入工具也是一件很难的事情。再看JVM启动参数，也很久没有变更过 Xms, Xmx, -XX:NewRatio, -XX:SurvivorRatio, 虽然没有仔细分析程序使用内存情况，但看起来也无大碍。</p>
<p>于是开始找代码，某年某天某月～ 嗯，注意到一段这样的代码提交：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ExecutorService executor = Executors.newFixedThreadPool(<span class="number">15</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">push2Kafka</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    executor.execute(<span class="keyword">new</span> WriteTask(msg,  <span class="keyword">false</span>));    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相关代码的完整功能是，每次线上调用，都会把计算结果的日志打到 Kafka，Kafka消费方再继续后续的逻辑。内存被耗尽可能有一个原因是，因为使用了 newFixedThreadPool 线程池，而它的工作机制是，固定了N个线程，而提交给线程池的任务队列是不限制大小的，如果Kafka发消息被阻塞或者变慢，那么显然队列里面的内容会越来越多，也就会导致这样的问题。</p>
<p>为了验证这个想法，做了个小实验，把 newFixedThreadPool 线程池的线程个数调小一点，例如 1。果然压测了一下，很快就复现了内存耗尽，服务不可用的悲剧。</p>
<p>最后的修复策略是使用了自定义的线程池参数，而非 Executors 默认实现解决了问题。下面就把线程池相关的原理和参数总结一下，避免未来踩坑。</p>
<h2 id="1-Java线程池"><a href="#1-Java线程池" class="headerlink" title="1. Java线程池"></a>1. Java线程池</h2><p>虽然Java线程池理论，以及构造线程池的各种参数，以及 Executors 提供的默认实现之前研读过，不过线上还没有发生过线程池误用引发的事故，所以有必要把这些参数再仔细琢磨一遍。</p>
<p>优先补充一些线程池的工作理论，有助于展开下面的内容。线程池顾名思义，就是由很多线程构成的池子，来一个任务，就从池子中取一个线程，处理这个任务。这个理解是我在第一次接触到这个概念时候的理解，虽然整体基本切入到核心，但是实际上会比这个复杂。例如线程池肯定不会无限扩大的，否则资源会耗尽；当线程数到达一个阶段，提交的任务会被暂时存储在一个队列中，如果队列内容可以不断扩大，极端下也会耗尽资源，那选择什么类型的队列，当队列满如何处理任务，都有涉及很多内容。线程池总体的工作过程如下图：</p>
<p><img src="https://img-blog.csdn.net/20180204155347335" alt="img"></p>
<p>线程池内的线程数的大小相关的概念有两个，一个是核心池大小，还有最大池大小。如果当前的线程个数比核心池个数小，当任务到来，会优先创建一个新的线程并执行任务。当已经到达核心池大小，则把任务放入队列，为了资源不被耗尽，队列的最大容量可能也是有上限的，如果达到队列上限则考虑继续创建新线程执行任务，如果此刻线程的个数已经到达最大池上限，则考虑把任务丢弃。</p>
<p>在 java.util.concurrent 包中，提供了 ThreadPoolExecutor 的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">                              ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">                              RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>既然有了刚刚对线程池工作原理对概述，这些参数就很容易理解了：</p>
<p>corePoolSize- 核心池大小，既然如前原理部分所述。需要注意的是在初创建线程池时线程不会立即启动，直到有任务提交才开始启动线程并逐渐时线程数目达到corePoolSize。若想一开始就创建所有核心线程需调用prestartAllCoreThreads方法。</p>
<p>maximumPoolSize-池中允许的最大线程数。需要注意的是当核心线程满且阻塞队列也满时才会判断当前线程数是否小于最大线程数，并决定是否创建新线程。</p>
<p>keepAliveTime - 当线程数大于核心时，多于的空闲线程最多存活时间</p>
<p>unit - keepAliveTime 参数的时间单位。</p>
<p>workQueue - 当线程数目超过核心线程数时用于保存任务的队列。主要有3种类型的BlockingQueue可供选择：无界队列，有界队列和同步移交。将在下文中详细阐述。从参数中可以看到，此队列仅保存实现Runnable接口的任务。 别看这个参数位置很靠后，但是真的很重要，因为楼主的坑就因这个参数而起，这些细节有必要仔细了解清楚。</p>
<p>threadFactory - 执行程序创建新线程时使用的工厂。</p>
<p>handler - 阻塞队列已满且线程数达到最大值时所采取的饱和策略。java默认提供了4种饱和策略的实现方式：中止、抛弃、抛弃最旧的、调用者运行。将在下文中详细阐述。</p>
<h2 id="2-可选择的阻塞队列BlockingQueue详解"><a href="#2-可选择的阻塞队列BlockingQueue详解" class="headerlink" title="2. 可选择的阻塞队列BlockingQueue详解"></a>2. 可选择的阻塞队列BlockingQueue详解</h2><p>在重复一下新任务进入时线程池的执行策略：<br>如果运行的线程少于corePoolSize，则 Executor始终首选添加新的线程，而不进行排队。（如果当前运行的线程小于corePoolSize，则任务根本不会存入queue中，而是直接运行）<br>如果运行的线程大于等于 corePoolSize，则 Executor始终首选将请求加入队列，而不添加新的线程。<br>如果无法将请求加入队列，则创建新的线程，除非创建此线程超出 maximumPoolSize，在这种情况下，任务将被拒绝。<br>主要有3种类型的BlockingQueue：</p>
<p>无界队列</p>
<p>队列大小无限制，常用的为无界的LinkedBlockingQueue，使用该队列做为阻塞队列时要尤其当心，当任务耗时较长时可能会导致大量新任务在队列中堆积最终导致OOM。阅读代码发现，Executors.newFixedThreadPool 采用就是 LinkedBlockingQueue，而楼主踩到的就是这个坑，当QPS很高，发送数据很大，大量的任务被添加到这个无界LinkedBlockingQueue 中，导致cpu和内存飙升服务器挂掉。</p>
<p>有界队列</p>
<p>常用的有两类，一类是遵循FIFO原则的队列如ArrayBlockingQueue与有界的LinkedBlockingQueue，另一类是优先级队列如PriorityBlockingQueue。PriorityBlockingQueue中的优先级由任务的Comparator决定。<br>使用有界队列时队列大小需和线程池大小互相配合，线程池较小有界队列较大时可减少内存消耗，降低cpu使用率和上下文切换，但是可能会限制系统吞吐量。</p>
<p>在我们的修复方案中，选择的就是这个类型的队列，虽然会有部分任务被丢失，但是我们线上是排序日志搜集任务，所以对部分对丢失是可以容忍的。</p>
<p>同步移交队列</p>
<p>如果不希望任务在队列中等待而是希望将任务直接移交给工作线程，可使用SynchronousQueue作为等待队列。SynchronousQueue不是一个真正的队列，而是一种线程之间移交的机制。要将一个元素放入SynchronousQueue中，必须有另一个线程正在等待接收这个元素。只有在使用无界线程池或者有饱和策略时才建议使用该队列。</p>
<h2 id="3-可选择的饱和策略RejectedExecutionHandler详解"><a href="#3-可选择的饱和策略RejectedExecutionHandler详解" class="headerlink" title="3. 可选择的饱和策略RejectedExecutionHandler详解"></a>3. 可选择的饱和策略RejectedExecutionHandler详解</h2><p>JDK主要提供了4种饱和策略供选择。4种策略都做为静态内部类在ThreadPoolExcutor中进行实现。</p>
<h2 id="3-1-AbortPolicy中止策略"><a href="#3-1-AbortPolicy中止策略" class="headerlink" title="3.1 AbortPolicy中止策略"></a>3.1 AbortPolicy中止策略</h2><p>该策略是默认饱和策略。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            throw new RejectedExecutionException(&quot;Task &quot; + r.toString() +</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                                                 &quot; rejected from &quot; +</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                                                 e.toString());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>使用该策略时在饱和时会抛出RejectedExecutionException（继承自RuntimeException），调用者可捕获该异常自行处理。</p>
<h2 id="3-2-DiscardPolicy抛弃策略"><a href="#3-2-DiscardPolicy抛弃策略" class="headerlink" title="3.2 DiscardPolicy抛弃策略"></a>3.2 DiscardPolicy抛弃策略</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如代码所示，不做任何处理直接抛弃任务</p>
<h2 id="3-3-DiscardOldestPolicy抛弃旧任务策略"><a href="#3-3-DiscardOldestPolicy抛弃旧任务策略" class="headerlink" title="3.3 DiscardOldestPolicy抛弃旧任务策略"></a>3.3 DiscardOldestPolicy抛弃旧任务策略</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            if (!e.isShutdown()) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                e.getQueue().poll();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                e.execute(r);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如代码，先将阻塞队列中的头元素出队抛弃，再尝试提交任务。如果此时阻塞队列使用PriorityBlockingQueue优先级队列，将会导致优先级最高的任务被抛弃，因此不建议将该种策略配合优先级队列使用。</p>
<h2 id="3-4-CallerRunsPolicy调用者运行"><a href="#3-4-CallerRunsPolicy调用者运行" class="headerlink" title="3.4 CallerRunsPolicy调用者运行"></a>3.4 CallerRunsPolicy调用者运行</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            if (!e.isShutdown()) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                r.run();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>既不抛弃任务也不抛出异常，直接运行任务的run方法，换言之将任务回退给调用者来直接运行。使用该策略时线程池饱和后将由调用线程池的主线程自己来执行任务，因此在执行任务的这段时间里主线程无法再提交新任务，从而使线程池中工作线程有时间将正在处理的任务处理完成。</p>
<h2 id="4-Java提供的四种常用线程池解析"><a href="#4-Java提供的四种常用线程池解析" class="headerlink" title="4. Java提供的四种常用线程池解析"></a>4. Java提供的四种常用线程池解析</h2><p>既然楼主踩坑就是使用了 JDK 的默认实现，那么再来看看这些默认实现到底干了什么，封装了哪些参数。简而言之 Executors 工厂方法Executors.newCachedThreadPool() 提供了无界线程池，可以进行自动线程回收；Executors.newFixedThreadPool(int) 提供了固定大小线程池，内部使用无界队列；Executors.newSingleThreadExecutor() 提供了单个后台线程。</p>
<p>详细介绍一下上述四种线程池。</p>
<h2 id="4-1-newCachedThreadPool"><a href="#4-1-newCachedThreadPool" class="headerlink" title="4.1 newCachedThreadPool"></a>4.1 newCachedThreadPool</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newCachedThreadPool() &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                                      60L, TimeUnit.SECONDS,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                                      new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在newCachedThreadPool中如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。<br>初看该构造函数时我有这样的疑惑：核心线程池为0，那按照前面所讲的线程池策略新任务来临时无法进入核心线程池，只能进入 SynchronousQueue中进行等待，而SynchronousQueue的大小为1，那岂不是第一个任务到达时只能等待在队列中，直到第二个任务到达发现无法进入队列才能创建第一个线程？<br>这个问题的答案在上面讲SynchronousQueue时其实已经给出了，要将一个元素放入SynchronousQueue中，必须有另一个线程正在等待接收这个元素。因此即便SynchronousQueue一开始为空且大小为1，第一个任务也无法放入其中，因为没有线程在等待从SynchronousQueue中取走元素。因此第一个任务到达时便会创建一个新线程执行该任务。</p>
<h2 id="4-2-newFixedThreadPool"><a href="#4-2-newFixedThreadPool" class="headerlink" title="4.2 newFixedThreadPool"></a>4.2 newFixedThreadPool</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                                     0L, TimeUnit.MILLISECONDS,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                                     new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看代码一目了然了，线程数量固定，使用无限大的队列。再次强调，楼主就是踩的这个无限大队列的坑。</p>
<h2 id="4-3-newScheduledThreadPool"><a href="#4-3-newScheduledThreadPool" class="headerlink" title="4.3 newScheduledThreadPool"></a>4.3 newScheduledThreadPool</h2><p>创建一个定长线程池，支持定时及周期性任务执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        return new ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在来看看ScheduledThreadPoolExecutor（）的构造函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public ScheduledThreadPoolExecutor(int corePoolSize) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">             new DelayedWorkQueue());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>ScheduledThreadPoolExecutor的父类即ThreadPoolExecutor，因此这里各参数含义和上面一样。值得关心的是DelayedWorkQueue这个阻塞对列，在上面没有介绍，它作为静态内部类就在ScheduledThreadPoolExecutor中进行了实现。简单的说，DelayedWorkQueue是一个无界队列，它能按一定的顺序对工作队列中的元素进行排列。</p>
<h2 id="4-4-newSingleThreadExecutor"><a href="#4-4-newSingleThreadExecutor" class="headerlink" title="4.4 newSingleThreadExecutor"></a>4.4 newSingleThreadExecutor</h2><p>创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static ScheduledExecutorService newSingleThreadScheduledExecutor() &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        return new DelegatedScheduledExecutorService</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            (new ScheduledThreadPoolExecutor(1));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>首先new了一个线程数目为 1 的ScheduledThreadPoolExecutor，再把该对象传入DelegatedScheduledExecutorService中，看看DelegatedScheduledExecutorService的实现代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DelegatedScheduledExecutorService(ScheduledExecutorService executor) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            super(executor);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            e = executor;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在看看它的父类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DelegatedExecutorService(ExecutorService executor) &#123; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           e = executor; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实就是使用装饰模式增强了ScheduledExecutorService（1）的功能，不仅确保只有一个线程顺序执行任务，也保证线程意外终止后会重新创建一个线程继续执行任务。</p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>虽然之前学习了不少相关知识，但是只有在实践中踩坑才能印象深刻吧</p>
<p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zMjg2NzE4MT91dG1fc291cmNlPXdlY2hhdF9zZXNzaW9uJmFtcDt1dG1fbWVkaXVtPXNvY2lhbA==" title="https://zhuanlan.zhihu.com/p/32867181?utm_source=wechat_session&amp;utm_medium=social">原文地址<i class="fa fa-external-link"></i></span></p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 线程池 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[并发编程和线程池]]></title>
      <url>/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0.html</url>
      <content type="html"><![CDATA[<p>并发编程和线程池</p>
<h2 id="练气期（并发编程基础）"><a href="#练气期（并发编程基础）" class="headerlink" title="练气期（并发编程基础）"></a>练气期（并发编程基础）</h2><h3 id="练气期一层（this）"><a href="#练气期一层（this）" class="headerlink" title="练气期一层（this）"></a>练气期一层（this）</h3><p><em>synchronized(this)和synchronized方法都是锁当前对象。</em></p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_01</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;  <span class="comment">// 存在堆中</span></span><br><span class="line">    <span class="keyword">private</span> Object o = <span class="keyword">new</span> Object();    <span class="comment">// 存在堆中</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 多个线程都能找到的，都能访问的对象叫临界资源对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSync1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (o) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()</span><br><span class="line">                    + <span class="string">" count = "</span> + count++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSync2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()</span><br><span class="line">                    + <span class="string">" count = "</span> + count++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">testSync3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()</span><br><span class="line">                + <span class="string">" count = "</span> + count++);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Test_01 t = <span class="keyword">new</span> Test_01();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                t.testSync3();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                t.testSync3();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="练气期二层（static）"><a href="#练气期二层（static）" class="headerlink" title="练气期二层（static）"></a>练气期二层（static）</h3><p><em>静态同步方法，锁的是当前类型的类对象。</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_02</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> staticCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">testSync4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() </span><br><span class="line">                + <span class="string">" staticCount = "</span> + staticCount++);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testSync5</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(Test_02.class)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() </span><br><span class="line">                    + <span class="string">" staticCount = "</span> + staticCount++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="练气期三层（原子性）"><a href="#练气期三层（原子性）" class="headerlink" title="练气期三层（原子性）"></a>练气期三层（原子性）</h3><p><em>加锁的目的就是为了保证操作的原子性</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_03</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="comment">/*synchronized*/</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()</span><br><span class="line">                + <span class="string">" count = "</span> + count++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test_03 t = <span class="keyword">new</span> Test_03();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(t, <span class="string">"Thread - "</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="练气期四层（同步与非同步方法间调用）"><a href="#练气期四层（同步与非同步方法间调用）" class="headerlink" title="练气期四层（同步与非同步方法间调用）"></a>练气期四层（同步与非同步方法间调用）</h3><p><em>同步方法只影响锁定同一个锁对象的同步方法。不影响其他线程调用非同步方法，或调用其他锁资源的同步方法。</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_04</span> </span>&#123;</span><br><span class="line">    Object o = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123; <span class="comment">// 重量级的访问操作。</span></span><br><span class="line">        System.out.println(<span class="string">"public synchronized void m1() start"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"public synchronized void m1() end"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (o) &#123;</span><br><span class="line">            System.out.println(<span class="string">"public void m3() start"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"public void m3() end"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"public void m2() start"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"public void m2() end"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread01</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyThread01</span><span class="params">(<span class="keyword">int</span> i, Test_04 t)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.i = i;</span><br><span class="line">            <span class="keyword">this</span>.t = t;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        Test_04 t;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                t.m1();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                t.m2();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                t.m3();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test_04 t = <span class="keyword">new</span> Test_04();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Test_04.MyThread01(<span class="number">0</span>, t)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Test_04.MyThread01(<span class="number">1</span>, t)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Test_04.MyThread01(-<span class="number">1</span>, t)).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="练气期五层（存在原子性问题）"><a href="#练气期五层（存在原子性问题）" class="headerlink" title="练气期五层（存在原子性问题）"></a>练气期五层（存在原子性问题）</h3><p><em>同步方法只能保证当前方法的原子性，不能保证多个业务方法之间的互相访问的原子性。一般来说，商业项目中，不考虑业务逻辑上的脏读问题。如你买东西下订单后，提示订单已下，查询时候，可能看不到。一般我们只关注数据脏读。但是在金融领域，保险领域严格要求。</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_05</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> d = <span class="number">0.0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">(<span class="keyword">double</span> d)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 相当于复杂的业务逻辑代码。</span></span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.d = d;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">m2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.d;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Test_05 t = <span class="keyword">new</span> Test_05();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                t.m1(<span class="number">100</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        System.out.println(t.m2());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(t.m2());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="练气期六层（锁可重入）"><a href="#练气期六层（锁可重入）" class="headerlink" title="练气期六层（锁可重入）"></a>练气期六层（锁可重入）</h3><p><em>同一个线程，多次调用同步代码，锁定同一个锁对象，可重入。</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_06</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>&#123; <span class="comment">// 锁this</span></span><br><span class="line">        System.out.println(<span class="string">"m1 start"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        m2();</span><br><span class="line">        System.out.println(<span class="string">"m1 end"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span></span>&#123; <span class="comment">// 锁this</span></span><br><span class="line">        System.out.println(<span class="string">"m2 start"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"m2 end"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Test_06().m1();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="练气期七层（调用父类的同步方法）"><a href="#练气期七层（调用父类的同步方法）" class="headerlink" title="练气期七层（调用父类的同步方法）"></a>练气期七层（调用父类的同步方法）</h3><p><em>子类同步方法覆盖父类同步方法，可以指定调用父类的同步方法， 相当于锁的重入。父类的方法 &lt;&lt;==&gt;&gt; 本类的方法</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_07</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Super Class m start"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Super Class m end"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Sub_Test_07().m();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub_Test_07</span> <span class="keyword">extends</span> <span class="title">Test_07</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Sub Class m start"</span>);</span><br><span class="line">        <span class="keyword">super</span>.m();</span><br><span class="line">        System.out.println(<span class="string">"Sub Class m end"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="练气期八层（锁与异常）"><a href="#练气期八层（锁与异常）" class="headerlink" title="练气期八层（锁与异常）"></a>练气期八层（锁与异常）</h3><p><em>当同步方法中发生异常的时候，自动释放锁资源，不会影响其他线程的执行。我们需要注意的是在同步业务逻辑中，如果发生异常如何处理——— try/catch 。如存钱时，发送网络中断，查询的时候查到多少钱，存的钱要返还</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_08</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" - start"</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" - "</span> + i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*if(i == 5)&#123;</span></span><br><span class="line"><span class="comment">                i = 1/0;</span></span><br><span class="line"><span class="comment">            &#125;*/</span></span><br><span class="line">            <span class="comment">//模拟存钱，中断处理</span></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">5</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    i = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    i = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Test_08 t = <span class="keyword">new</span> Test_08();</span><br><span class="line">        <span class="comment">// 锁的是当前对象</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                t.m();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t1"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                t.m();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="练气期九层（volatile）"><a href="#练气期九层（volatile）" class="headerlink" title="练气期九层（volatile）"></a>练气期九层（volatile）</h3><p><em>cpu默认查询cpu的高速缓存区域，CPU中每一个核都有自己的缓存，当cpu有中断的时候，他可能清空高速缓存区域数据，重新从内存中读取数据。volatile改变内存中的数据，通知底层OS系统，每次使用b的时候，最好看下内存数据是否发生变动。即volatile做的是一个通知OS系统的作。</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_09</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> b = <span class="keyword">true</span>;    <span class="comment">//线程可见性问题</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"start"</span>);</span><br><span class="line">        <span class="keyword">while</span>(b)&#123;&#125;</span><br><span class="line">        System.out.println(<span class="string">"end"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Test_09 t = <span class="keyword">new</span> Test_09();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                t.m();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        t.b = <span class="keyword">false</span>;    <span class="comment">//堆空间的对象，线程共享</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>volatile的非原子性问题，只能保证可见性，不能保证原子性。</em></p>
<p><em>那什么时候使用volatile？棋牌室的人数，新增的人有一个线程去+1。这是可以使用volatile</em></p>
<p><em>join()多个线程在运行结束时，我把多个线程再main线程的位置连在一起，当其他线程都结束，即保证在所有线程循环执行+1后，再执行main线程打印。</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_10</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*synchronized*/</span> <span class="function"><span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;    <span class="comment">//保证原子性的解决方法是使用synchronized或者是Atomic</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Test_10 t = <span class="keyword">new</span> Test_10();</span><br><span class="line">        List&lt;Thread&gt; threads = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            threads.add(<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    t.m();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threads) &#123;</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threads) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                thread.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(t.count);    <span class="comment">//理论上是10w。实际少于这个数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="练气期十层（AtomicXxx）"><a href="#练气期十层（AtomicXxx）" class="headerlink" title="练气期十层（AtomicXxx）"></a>练气期十层（AtomicXxx）</h3><p><em>什么时候有原子性，没有可见性？</em></p>
<p><em>答：所谓原子性是指多个线程访问一个变量时，其结果必须保证正确性。</em>所谓可见性是指多线程间可以看最终结果的变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_11</span> </span>&#123;</span><br><span class="line">    AtomicInteger count = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="comment">/*if(count.get() &lt; 1000)*/</span></span><br><span class="line">            count.incrementAndGet();    <span class="comment">//相当于++count,count.getAndAccumulate()是count++;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Test_11 t = <span class="keyword">new</span> Test_11();</span><br><span class="line">        List&lt;Thread&gt; threads = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            threads.add(<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    t.m();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threads) &#123;</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threads) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                thread.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(t.count.intValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="练气期十一层（锁对象变更）"><a href="#练气期十一层（锁对象变更）" class="headerlink" title="练气期十一层（锁对象变更）"></a>练气期十一层（锁对象变更）</h3><ul>
<li>同步代码一旦加锁后，那么会有一个临时的锁引用指向锁对象，和真实的引用无直接关联。在锁未释放之前，修改锁引用，不会影响同步代码的执行。</li>
<li>我们打印的是Test_13中的o。不是锁引用的_O;下面synchronized锁的是两个对象。打印的是同一个对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_13</span> </span>&#123;</span><br><span class="line">    Object o = <span class="keyword">new</span> Object();    <span class="comment">//变量引用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * return i -&gt;</span></span><br><span class="line"><span class="comment">             * int _returnValue = i; // 0;</span></span><br><span class="line"><span class="comment">             * return _returnValue;</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            i = <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" start"</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (o) &#123;    <span class="comment">//计算变量引用与变量引用不是一回事</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" - "</span> + o);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Test_13 t = <span class="keyword">new</span> Test_13();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                t.m();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"thread1"</span>).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                t.m();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"thread2"</span>);</span><br><span class="line">        t.o = <span class="keyword">new</span> Object();</span><br><span class="line">        thread2.start();    <span class="comment">//更改临界资源对象</span></span><br><span class="line"></span><br><span class="line">        System.out.println(t.i);</span><br><span class="line">        System.out.println(t.a());</span><br><span class="line">        System.out.println(t.i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="练气期十二层（CountDownLatch）"><a href="#练气期十二层（CountDownLatch）" class="headerlink" title="练气期十二层（CountDownLatch）"></a>练气期十二层（CountDownLatch）</h3><ul>
<li>不会进入等待队列，可以和锁混合使用，或替代锁的功能。</li>
<li>一次性在门上挂多个锁。</li>
<li>作用如：init对象的时候有一个前后顺序的问题。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_15</span> </span>&#123;</span><br><span class="line">    CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            latch.await();<span class="comment">// 等待门闩开放。</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"m1() method"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (latch.getCount() != <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"latch count : "</span> + latch.getCount());</span><br><span class="line">                latch.countDown(); <span class="comment">// 减门闩上的锁。</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"m2() method : "</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Test_15 t = <span class="keyword">new</span> Test_15();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                t.m1();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                t.m2();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="练气期大圆满"><a href="#练气期大圆满" class="headerlink" title="练气期大圆满"></a>练气期大圆满</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_14</span> </span>&#123;</span><br><span class="line">    String s1 = <span class="string">"hello"</span>;</span><br><span class="line">    String s2 = <span class="keyword">new</span> String(<span class="string">"hello"</span>); <span class="comment">// new关键字，一定是在堆中创建一个新的对象。</span></span><br><span class="line">    Integer i1 = <span class="number">1</span>;    <span class="comment">// i1与i2是同一个变量，在常量池中，new是放在堆内存</span></span><br><span class="line">    Integer i2 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (i1) &#123;    <span class="comment">//s1与s2</span></span><br><span class="line">            System.out.println(<span class="string">"m1()"</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (i2) &#123;</span><br><span class="line">            System.out.println(<span class="string">"m2()"</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Test_14 t = <span class="keyword">new</span> Test_14();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                t.m1();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                t.m2();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>自定义容器，提供新增元素（add）和获取元素数量（size）方法。启动两个线程。线程1向容器中新增10个数据。线程2监听容器元素数量，当容器元素数量为5时，线程2输出信息并终止。</strong></p>
<ol>
<li>使用volatile</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Test_01_Container t = <span class="keyword">new</span> Test_01_Container();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"add Object to Container "</span> + i);</span><br><span class="line">                    t.add(<span class="keyword">new</span> Object());</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.size() == <span class="number">5</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"size = 5"</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test_01_Container</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> List&lt;Object&gt; container = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.container.add(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.container.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>使用synchronized和wait(), 调用wait()将释放锁，并且进入等待队列中，生产者与消费者模型</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Test_02_Container t = <span class="keyword">new</span> Test_02_Container();</span><br><span class="line">        <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(t.size() != <span class="number">5</span>)&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            lock.wait(); <span class="comment">// 线程进入等待队列。</span></span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">"size = 5"</span>);</span><br><span class="line">                    lock.notifyAll(); <span class="comment">// 唤醒其他等待线程</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">                        System.out.println(<span class="string">"add Object to Container "</span> + i);</span><br><span class="line">                        t.add(<span class="keyword">new</span> Object());</span><br><span class="line">                        <span class="keyword">if</span>(t.size() == <span class="number">5</span>)&#123;</span><br><span class="line">                            lock.notifyAll();</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                lock.wait();</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                                e.printStackTrace();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test_02_Container</span></span>&#123;</span><br><span class="line">    List&lt;Object&gt; container = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object o)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.container.add(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.container.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>使用门闩避免进入等待队列，效率更高。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Test_03_Container t = <span class="keyword">new</span> Test_03_Container();</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(t.size() != <span class="number">5</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        latch.await(); <span class="comment">// 等待门闩的开放。 不是进入等待队列</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"size = 5"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"add Object to Container "</span> + i);</span><br><span class="line">                    t.add(<span class="keyword">new</span> Object());</span><br><span class="line">                    <span class="keyword">if</span>(t.size() == <span class="number">5</span>)&#123;</span><br><span class="line">                        latch.countDown(); <span class="comment">// 门闩-1</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test_03_Container</span></span>&#123;</span><br><span class="line">    List&lt;Object&gt; container = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object o)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.container.add(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.container.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>小编是一枚Java Coder，业余写文章，现主营微信公众号《Java患者》，喜欢的话关注我的公众号或者加我微信我们一起学习Java</em></p>
<p><img src="\111公众号.jpg" alt=""></p>
<h2 id="筑基期（ReentrantLock）"><a href="#筑基期（ReentrantLock）" class="headerlink" title="筑基期（ReentrantLock）"></a>筑基期（ReentrantLock）</h2><h3 id="筑基初期（lock等待锁）"><a href="#筑基初期（lock等待锁）" class="headerlink" title="筑基初期（lock等待锁）"></a>筑基初期（lock等待锁）</h3><ul>
<li>concurrent是jdk1.5后的包，避免synchronized的出现而设计出来的一种锁机制。</li>
<li>ReentrantLock 重入锁，在一个对象上加一个标记信息，这个标记信息代表锁机制。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_01</span> </span>&#123;</span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock(); <span class="comment">// 加锁</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                System.out.println(<span class="string">"m1() method "</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">// 解锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        System.out.println(<span class="string">"m2() method"</span>);</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Test_01 t = <span class="keyword">new</span> Test_01();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                t.m1();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                t.m2();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="筑基中期（tryLock尝试锁）"><a href="#筑基中期（tryLock尝试锁）" class="headerlink" title="筑基中期（tryLock尝试锁）"></a>筑基中期（tryLock尝试锁）</h3><p><em>尝试锁有阻塞和非阻塞两种</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_02</span> </span>&#123;</span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                System.out.println(<span class="string">"m1() method "</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> isLocked = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 尝试锁， 如果有锁，无法获取锁标记，返回false。</span></span><br><span class="line">            <span class="comment">// 非阻塞，如果获取锁标记，返回true</span></span><br><span class="line">            <span class="comment">// isLocked = lock.tryLock();</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 阻塞尝试锁，阻塞参数代表的时长，尝试获取锁标记。</span></span><br><span class="line">            <span class="comment">// 如果超时，不等待。直接返回。</span></span><br><span class="line">            isLocked = lock.tryLock(<span class="number">5</span>, TimeUnit.SECONDS); </span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(isLocked)&#123;</span><br><span class="line">                System.out.println(<span class="string">"m2() method synchronized"</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"m2() method unsynchronized"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(isLocked)&#123;</span><br><span class="line">                <span class="comment">// 尝试锁在解除锁标记的时候，一定要判断是否获取到锁标记。</span></span><br><span class="line">                <span class="comment">// 如果当前线程没有获取到锁标记，会抛出异常。</span></span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Test_02 t = <span class="keyword">new</span> Test_02();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                t.m1();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                t.m2();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="筑基后期（lockInterruptibly可打断锁）"><a href="#筑基后期（lockInterruptibly可打断锁）" class="headerlink" title="筑基后期（lockInterruptibly可打断锁）"></a>筑基后期（lockInterruptibly可打断锁）</h3><ul>
<li>阻塞状态有3种： 包括普通阻塞（不释放锁），等待队列（释放锁），锁池队列。<ul>
<li>普通阻塞： sleep(10000)， 可以被打断。调用thread.interrupt()方法，可以打断阻塞状态，抛出异常。</li>
<li>等待队列： wait()方法被调用，也是一种阻塞状态，只能由notify唤醒。无法打断。</li>
<li>锁池队列： 执行过程中，遇到同步代码，无法获取锁标记。不是所有的锁池队列都可被打断。<ul>
<li>使用ReentrantLock的lock方法，获取锁标记的时候，如果需要阻塞等待锁标记，无法被打断。</li>
<li>使用ReentrantLock的lockInterruptibly方法，获取锁标记的时候，如果需要阻塞等待，可以被打断。</li>
</ul>
</li>
</ul>
</li>
<li>可打断锁意义：软件锁死了，无响应，去去任务管理器结束任务</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_03</span> </span>&#123;</span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                System.out.println(<span class="string">"m1() method "</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 线程执行到这里，本来是不能获得锁标记的，要进入等待队列的。</span></span><br><span class="line">            <span class="comment">// 当通过调用当前线程的interrupt()，通过打断当前线程，抛出异常，使线程被唤醒，阻塞结束</span></span><br><span class="line">            lock.lockInterruptibly(); <span class="comment">// 可尝试打断的，阻塞等待锁。可以被其他的线程打断阻塞状态</span></span><br><span class="line">            System.out.println(<span class="string">"m2() method"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// 被打断的异常，被打断与唤醒、阻塞结束都是不一样的</span></span><br><span class="line">            <span class="comment">// sleep任何一个线程都可以把他打断，强行唤醒</span></span><br><span class="line">            <span class="comment">// 如果是lock不可被打断的</span></span><br><span class="line">            <span class="comment">// 如果是lockInterruptibly，阻塞等待这把锁，类似sleep，可以通过interrupt()打断</span></span><br><span class="line">            System.out.println(<span class="string">"m2() method interrupted"</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Test_03 t = <span class="keyword">new</span> Test_03();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                t.m1();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                t.m2();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不调用interrupt()方法，t2最后可以获得锁，继续执行</span></span><br><span class="line">        t2.interrupt();<span class="comment">// 打断t2线程，锁的位置会抛出异常。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="筑基圆满（公平锁）"><a href="#筑基圆满（公平锁）" class="headerlink" title="筑基圆满（公平锁）"></a>筑基圆满（公平锁）</h3><ul>
<li>在cpu和os中本身线程竞争锁标记是不公平的，不考虑线程的等待时间的。</li>
<li>运用在轮询的场景，如打牌。</li>
<li>需要效果一部分的cpu资源计算等待的时间，性能有所降低。要仅能少用，并发量在10之内。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_04</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestReentrantlock t = <span class="keyword">new</span> TestReentrantlock();</span><br><span class="line">        <span class="comment">//TestSync t = new TestSync();</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(t);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(t);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestReentrantlock</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个公平锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" get lock"</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestSync</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//不公平的</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" get lock in TestSync"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>小编是一枚Java Coder，业余写文章，现主营微信公众号《Java患者》，喜欢的话关注我的公众号或者加我微信我们一起学习Java</em></p>
<p><img src="\111公众号.jpg" alt=""></p>
<h2 id="金丹期"><a href="#金丹期" class="headerlink" title="金丹期"></a>金丹期</h2><h3 id="金丹初期（生产者-amp-消费者）"><a href="#金丹初期（生产者-amp-消费者）" class="headerlink" title="金丹初期（生产者&amp;消费者）"></a>金丹初期（生产者&amp;消费者）</h3><ul>
<li>ReenTrantLock建议应用在同步方式，相对效率比synchronized高，量级较轻。</li>
<li>synchronized在JDK1.5版本尝试优化，到JDK1.7后，优化效率已经非常好了。在绝对效率上不比ReenTrantLock差多少。</li>
<li>使用ReenTrantLock必须释放锁标记。一般在finally代码块释放锁标记的。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">练习（生产者消费者模式）：</span><br><span class="line">自定义同步容器，容器容量上限为10。可以在多线程中应用，并保证数据线程安全。</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestContainer01</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LinkedList&lt;E&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(list.size() == MAX)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">                e1.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        list.add(e);</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        E e = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(list.size() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">                e1.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        e = list.removeFirst();</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> TestContainer01&lt;String&gt; c = <span class="keyword">new</span> TestContainer01&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++)&#123;</span><br><span class="line">                        System.out.println(c.get());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">"consumer"</span>+i).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">25</span>; j++)&#123;</span><br><span class="line">                        c.put(<span class="string">"container value "</span> + j); </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">"producer"</span>+i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用ReentrantLock完成生产者-消费者</p>
<ul>
<li>Condition， 为Lock增加条件。当条件满足时（生成了或者是被消费），做什么事情，如加锁或解锁。如等待或唤醒</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestContainer02</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LinkedList&lt;E&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition producer = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition consumer = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(list.size() == MAX)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" 等待。。。"</span>);</span><br><span class="line">                <span class="comment">// 进入等待队列。释放锁标记。</span></span><br><span class="line">                <span class="comment">// 借助条件，进入的等待队列。</span></span><br><span class="line">                producer.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" put 。。。"</span>);</span><br><span class="line">            list.add(e);</span><br><span class="line">            count++;</span><br><span class="line">            <span class="comment">// 借助条件，唤醒所有的消费者。</span></span><br><span class="line">            consumer.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        E e = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(list.size() == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" 等待。。。"</span>);</span><br><span class="line">                <span class="comment">// 借助条件，消费者进入等待队列</span></span><br><span class="line">                consumer.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" get 。。。"</span>);</span><br><span class="line">            e = list.removeFirst();</span><br><span class="line">            count--;</span><br><span class="line">            <span class="comment">// 借助条件，唤醒所有的生产者</span></span><br><span class="line">            producer.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> TestContainer02&lt;String&gt; c = <span class="keyword">new</span> TestContainer02&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++)&#123;</span><br><span class="line">                        System.out.println(c.get());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">"consumer"</span>+i).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">25</span>; j++)&#123;</span><br><span class="line">                        c.put(<span class="string">"container value "</span> + j); </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">"producer"</span>+i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="金丹中期（锁的底层实现）"><a href="#金丹中期（锁的底层实现）" class="headerlink" title="金丹中期（锁的底层实现）"></a>金丹中期（锁的底层实现）</h3><p>​        <em>Java 虚拟机中的同步(Synchronization)基于进入和退出管程(Monitor)对象实现。同步方法 并不是由 monitor enter 和 monitor exit 指令来实现同步的，而是由方法调用指令读取运行时常量池中方法的ACC_SYNCHRONIZED 标志来隐式实现的。注：monitor enter 和 monitor exit 指令是C语言的内容。</em></p>
<p><strong>对象的内存模型</strong>（一个对象包含3部分，没有方法，方法是在方法区域中的）</p>
<p><img src="\media\对象内存模型.jpg" alt="对象内存模型"></p>
<ul>
<li>对象头：存储对象的 hashCode、锁信息或分代年龄或 GC 标志，类型指针指向对象的类元数据，JVM 通过这个指针确定该对象是哪个类的实例等信息。（关注锁信息）</li>
<li>实例变量：存放类的属性数据信息，包括父类的属性信息</li>
<li>填充数据：由于虚拟机要求对象起始地址必须是 8 字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐</li>
<li>monitor在栈中，但不是在线程栈中。</li>
<li>_Owner指向线程。</li>
</ul>
<p>​        <em>当线程在对象上加锁时，对象头都会指向monitor，记录锁信息。当执行 synchronized 同步方法或同步代码块时，会在对象头中记录锁标记，锁标记指向的是 monitor 对象（也称为管程或监视器锁）的起始地址。每个对象都存在着一个 monitor 与之关联，对象与其 monitor 之间的关系有存在多种实现方式，如 monitor 可以与对象一起创建销毁或当线程试图获取对象锁时自动生成，但当一个 monitor 被某个线程持有后，它便处于锁定状态。</em></p>
<p>​        <em>另外的线程想获取对象头中的锁信息的时候，会发现对象头中已经记录一把锁（monitor），他就获取不到。monitor是互斥的，对象头记录的monitor就不会分配给其他线程了，此时这个线程就会进入阻塞状态。</em>当执行中的线程发生异常，或者是释放锁标记，对象头的锁信息就会释放它记录的monitor。阻塞状态的线程就会弹出来争夺对象中的锁信息，重新在锁信息中记录monitor。</p>
<p>​        <em>ObjectMonitor 中有两个队列，_WaitSet 和 _EntryList，以及_Owner 标记。其中_WaitSet是用于管理等待队列(wait)线程的，_EntryList 是用于管理锁池阻塞线程的，_Owner 标记用于记录当前执行线程。</em></p>
<p><strong>线程状态图</strong></p>
<p><img src="\media\线程状态图.jpg" alt="线程状态图"></p>
<p>​        当多线程并发访问同一个同步代码时，首先会进入_EntryList，当线程获取锁标记后，monitor 中的_Owner 记录此线程，并在 monitor 中的计数器执行递增计算（+1），代表锁定，其他线程在_EntryList 中继续阻塞。若执行线程调用 wait 方法，则 monitor 中的计数器执行赋值为 0 计算，并将_Owner 标记赋值为 null，代表放弃锁，执行线程进如_WaitSet 中阻塞。若执行线程调用 notify/notifyAll 方法，_WaitSet 中的线程被唤醒，进入_EntryList 中阻塞，等待获取锁标记。若执行线程的同步代码执行结束，同样会释放锁标记，monitor 中的_Owner标记赋值为 null，且计数器赋值为 0 计算。</p>
<p>​        interrupt() 方法可以任何打断阻塞状态的线程，以抛异常的代价。</p>
<p>​        InterruptedException异常是阻塞异常。阻塞中的线程抛出的。</p>
<p><strong>锁的重入</strong></p>
<p>​        在 Java 中，同步锁是可以重入的。只有同一线程调用同步方法或执行同步代码块，对同一个对象加锁时才可重入。<br>​        当线程持有锁时，会在 monitor 的计数器中执行递增计算，若当前线程调用其他同步代码，且同步代码的锁对象相同时，monitor 中的计数器继续递增。每个同步代码执行结束，monitor 中的计数器都会递减，直至所有同步代码执行结束，monitor 中的计数器为 0 时，释放锁标记，_Owner 标记赋值为 null。</p>
<h3 id="金丹后期（锁的种类）"><a href="#金丹后期（锁的种类）" class="headerlink" title="金丹后期（锁的种类）"></a>金丹后期（锁的种类）</h3><ul>
<li>Java 中锁的种类包括偏向锁，自旋锁，轻量级锁，重量级锁。</li>
<li>锁的使用方式先提供偏向锁，如果不满足的时候，升级为轻量级锁，再不满足，升级为重量级锁。自旋锁是一个过渡的锁状态，不是一种实际的锁类型。锁只能升级，不能降级。</li>
<li>在<strong>金丹初期</strong>提到的就是重量级锁。</li>
</ul>
<p><strong>偏向锁：</strong></p>
<p>​        是一种编译解释锁。如果代码中不可能出现多线程并发争抢同一个锁的时候，JVM 编译代码，解释执行的时候，会自动的放弃同步信息。消除 synchronized 的同步代码结果。使用锁标记的形式记录锁状态。在 Monitor 中有变量 ACC_SYNCHRONIZED。当变量值使用的时候，代表偏向锁锁定。可以避免锁的争抢和锁池状态的维护。提高JVM解释效率。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Object o = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    o = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">synchronized</span> (o) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>轻量级锁：</strong></p>
<p>​        是一个过渡锁。当偏向锁不满足，也就是有多线程并发访问，锁定同一个对象的时候，先提升为轻量级锁。也是使用标记 ACC_SYNCHRONIZED 标记记录的。ACC_UNSYNCHRONIZED 标记记录未获取到锁信息的线程。就是只有两个线程争抢锁标记的时候，优先使用轻量级锁。A线程和monitor有直接关联的。B线程不记录monitor，是monitor记录B线程，线程A结束后，B两个线程才找到monitor。也可能出现重量级锁。</p>
<p><strong>自旋锁</strong>：</p>
<p>​        是一个过渡锁，是偏向锁和轻量级锁的过渡。当获取锁的过程中，未获取到。为了提高效率，JVM 自动执行若干次空循环，再次申请锁，而不是进入阻塞状态的情况。称为自旋锁。自旋锁提高效率就是避免线程状态的变更。</p>
<h3 id="金丹圆满（ThreadLocal）"><a href="#金丹圆满（ThreadLocal）" class="headerlink" title="金丹圆满（ThreadLocal）"></a>金丹圆满（ThreadLocal）</h3><ul>
<li>就是一个Map。key 是Thread.getCurrentThread()，value 是线程需要保存的变量。</li>
<li>ThreadLocal.set(value)相当map.put(Thread.getCurrentThread(), value)。</li>
<li>ThreadLocal.get() 相当map.get(Thread.getCurrentThread())。</li>
<li>内存问题 ： 在并发量高的时候，可能有内存溢出。</li>
<li>使用ThreadLocal的时候，一定注意回收资源问题，每个线程结束之前，将当前线程保存的线程变量一定要删除 ，调用ThreadLocal.remove()，要不会发生泄露。run方法的finally代码块。</li>
</ul>
<p>​        <em>在一个操作系统中，线程和进程是有数量上限的。在操作系统中，确定线程和进程唯一性的唯一条件就是线程或进程 ID。操作系统在回收线程或进程的时候，不是一定杀死线程或进程，在繁忙的时候，只会做情况线程或进程栈数据的操作，重复使用线程或进程。</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">static</span> String name = <span class="string">"zhangsan"</span>;</span><br><span class="line">    <span class="keyword">static</span> ThreadLocal&lt;String&gt; tl = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(name);    <span class="comment">// lisi</span></span><br><span class="line">                System.out.println(tl.get());    <span class="comment">// null</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                name = <span class="string">"lisi"</span>;</span><br><span class="line">                tl.set(<span class="string">"wangwu"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>小编是一枚Java Coder，业余写文章，现主营微信公众号《Java患者》，喜欢的话关注我的公众号或者加我微信我们一起学习Java</em></p>
<p><img src="\111公众号.jpg" alt=""></p>
<h2 id="元婴期（并发容器）"><a href="#元婴期（并发容器）" class="headerlink" title="元婴期（并发容器）"></a>元婴期（并发容器）</h2><p>​        <em>解决并发情况下的容器线程安全问题的。给多线程环境准备一个线程安全的容器对象。线程安全的容器对象： Vector, Hashtable。线程安全容器对象，都是使用 synchronized方法实现的。</em><br>​        <em>concurrent 包中的同步容器，大多数是使用系统底层技术实现的线程安全。类似 native。Java8 中使用 CAS。</em></p>
<h3 id="元婴前期（Map-Set）"><a href="#元婴前期（Map-Set）" class="headerlink" title="元婴前期（Map/Set）"></a>元婴前期（Map/Set）</h3><ul>
<li>ConcurrentHashMap/ConcurrentHashSet底层哈希实现的同步 Map(Set)。效率高，线程安全。使用系统底层技术实现线程安全。量级较 synchronized 低。key 和 value 不能为 null。</li>
<li>ConcurrentSkipListMap/ConcurrentSkipListSet底层跳表（SkipList）实现的同步 Map(Set)。有序，效率比 ConcurrentHashMap 稍低。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_01_ConcurrentMap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Map&lt;String, String&gt; map = <span class="keyword">new</span> Hashtable&lt;&gt;();    <span class="comment">// Collections.syncxxxxxx</span></span><br><span class="line">        <span class="comment">// final Map&lt;String, String&gt; map = new ConcurrentHashMap&lt;&gt;();</span></span><br><span class="line">        <span class="comment">// final Map&lt;String, String&gt; map = new ConcurrentSkipListMap&lt;&gt;();    数据结构跳表</span></span><br><span class="line">        <span class="keyword">final</span> Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        Thread[] array = <span class="keyword">new</span> Thread[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(array.length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            array[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) &#123;</span><br><span class="line">                        map.put(<span class="string">"key"</span> + r.nextInt(<span class="number">100000</span>), <span class="string">"value"</span> + r.nextInt(<span class="number">100000</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                    latch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Thread t : array) &#123;</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            latch.await();    <span class="comment">//等待门闩开放</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"执行时间为 ： "</span> + (end - begin) + <span class="string">"毫秒！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>调表机构：</strong>存10、18、15、20、19。</p>
<p><img src="\media\跳表.jpg" alt="跳表"></p>
<h3 id="元婴中期（List）"><a href="#元婴中期（List）" class="headerlink" title="元婴中期（List）"></a>元婴中期（List）</h3><ul>
<li>CopyOnWriteArrayList：写时复制集合，效率低，读取效率高。每次写入数据，都会创建一个新的底层数组。</li>
<li>浪费空间保证数据的安全。</li>
<li>初始容量1，每次新增的内容，创建容量+1。</li>
<li>取得时候，取最新的数组。remove最后一个数据，直接用上一个数组。</li>
<li>set和remove其他数据，重新创建数组。</li>
<li>存在幻读（写的时候，有读操作，不是最新添加的数据）</li>
<li>存在脏读（写的时候，有读操作，不是最新添加的数据）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_02_CopyOnWriteList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// final List&lt;String&gt; list = new ArrayList&lt;&gt;(); 线程不安全</span></span><br><span class="line">        <span class="comment">// final List&lt;String&gt; list = new Vector&lt;&gt;();    线程安全 更快</span></span><br><span class="line">        <span class="keyword">final</span> List&lt;String&gt; list = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">final</span> Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        Thread[] array = <span class="keyword">new</span> Thread[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(array.length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">            array[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++)&#123;</span><br><span class="line">                        list.add(<span class="string">"value"</span> + r.nextInt(<span class="number">100000</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                    latch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(Thread t : array)&#123;</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            latch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"执行时间为 ： "</span> + (end-begin) + <span class="string">"毫秒！"</span>);</span><br><span class="line">        System.out.println(<span class="string">"List.size() : "</span> + list.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="元婴后期（Queue）"><a href="#元婴后期（Queue）" class="headerlink" title="元婴后期（Queue）"></a>元婴后期（Queue）</h3><p><strong>ConcurrentLinkedQueue：</strong>基础链表同步队列。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_03_ConcurrentLinkedQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            queue.offer(<span class="string">"value"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(queue);</span><br><span class="line">        System.out.println(queue.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// peek() -&gt; 查看queue中的首数据</span></span><br><span class="line">        System.out.println(queue.peek());</span><br><span class="line">        System.out.println(queue.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// poll() -&gt; 获取queue中的首数据</span></span><br><span class="line">        System.out.println(queue.poll());</span><br><span class="line">        System.out.println(queue.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>LinkedBlockingQueue：</strong>阻塞队列，队列容量不足自动阻塞，队列容量为 0 自动阻塞。</p>
<ul>
<li>put自动阻塞， 队列容量满后，自动阻塞。</li>
<li>take自动阻塞方法， 队列容量为0后，自动阻塞。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_04_LinkedBlockingQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> BlockingQueue&lt;String&gt; queue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</span><br><span class="line">    <span class="keyword">final</span> Random r = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Test_04_LinkedBlockingQueue t = <span class="keyword">new</span> Test_04_LinkedBlockingQueue();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        t.queue.put(<span class="string">"value"</span>+t.r.nextInt(<span class="number">1000</span>));</span><br><span class="line">                        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"producer"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            System.out.println(Thread.currentThread().getName() + </span><br><span class="line">                                    <span class="string">" - "</span> + t.queue.take());</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">"consumer"</span>+i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>ArrayBlockingQueue：</strong>底层数组实现的有界队列。自动阻塞。根据调用 API（add/put/offer）不同，有不同特性。当容量不足的时候，有阻塞能力。</p>
<ul>
<li>add 方法在容量不足的时候，抛出异常。</li>
<li>put 方法在容量不足的时候，阻塞等待。</li>
<li>offer 方法，<ul>
<li>单参数 offer 方法，不阻塞。容量不足的时候，返回 false。当前新增数据操作放弃。</li>
<li>三参数 offer 方法（offer(value,times,timeunit)），容量不足的时候，阻塞 times 时长（单<br>位为 timeunit），如果在阻塞时长内，有容量空闲，新增数据返回 true。如果阻塞时长范围<br>内，无容量空闲，放弃新增数据，返回 false。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_05_ArrayBlockingQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> BlockingQueue&lt;String&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Test_05_ArrayBlockingQueue t = <span class="keyword">new</span> Test_05_ArrayBlockingQueue();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// System.out.println("add method : " + t.queue.add("value"+i));</span></span><br><span class="line">            ---------------------------------------------------------------------</span><br><span class="line">            <span class="comment">/*try &#123;</span></span><br><span class="line"><span class="comment">                t.queue.put("put"+i);</span></span><br><span class="line"><span class="comment">            &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">                e.printStackTrace();</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            System.out.println("put method : " + i);*/</span></span><br><span class="line">            ---------------------------------------------------------------------</span><br><span class="line">            <span class="comment">// System.out.println("offer method : " + t.queue.offer("value"+i));</span></span><br><span class="line">            ---------------------------------------------------------------------</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"offer method : "</span> + </span><br><span class="line">                            t.queue.offer(<span class="string">"value"</span>+i, <span class="number">1</span>, TimeUnit.SECONDS));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(t.queue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>DelayQueue：</strong>延时队列。根据比较机制，实现自定义处理顺序的队列。常用于定时任务。</p>
<ul>
<li>通过比较方法，比较排列，获取。</li>
<li>可以保存的对象一定要实现Delayed接口。Delayed接口继承Comparable接口。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_06_DelayQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> BlockingQueue&lt;MyTask_06&gt; queue = <span class="keyword">new</span> DelayQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> value = System.currentTimeMillis();</span><br><span class="line">        MyTask_06 task1 = <span class="keyword">new</span> MyTask_06(value + <span class="number">2000</span>);</span><br><span class="line">        MyTask_06 task2 = <span class="keyword">new</span> MyTask_06(value + <span class="number">1000</span>);</span><br><span class="line">        MyTask_06 task3 = <span class="keyword">new</span> MyTask_06(value + <span class="number">3000</span>);</span><br><span class="line">        MyTask_06 task4 = <span class="keyword">new</span> MyTask_06(value + <span class="number">2500</span>);</span><br><span class="line">        MyTask_06 task5 = <span class="keyword">new</span> MyTask_06(value + <span class="number">1500</span>);</span><br><span class="line"></span><br><span class="line">        queue.put(task1);</span><br><span class="line">        queue.put(task2);</span><br><span class="line">        queue.put(task3);</span><br><span class="line">        queue.put(task4);</span><br><span class="line">        queue.put(task5);</span><br><span class="line"></span><br><span class="line">        System.out.println(queue);</span><br><span class="line">        System.out.println(value);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">            System.out.println(queue.take());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTask_06</span> <span class="keyword">implements</span> <span class="title">Delayed</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> compareValue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyTask_06</span><span class="params">(<span class="keyword">long</span> compareValue)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.compareValue = compareValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 比较大小。自动实现升序</span></span><br><span class="line"><span class="comment">     * 建议和getDelay方法配合完成。</span></span><br><span class="line"><span class="comment">     * 如果在DelayQueue是需要按时间完成的计划任务，必须配合getDelay方法完成。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)(<span class="keyword">this</span>.getDelay(TimeUnit.MILLISECONDS) - o.getDelay(TimeUnit.MILLISECONDS));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取计划时长的方法。</span></span><br><span class="line"><span class="comment">     * 根据参数TimeUnit来决定，如何返回结果值。秒，毫秒</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unit.convert(compareValue - System.currentTimeMillis(), TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Task compare value is : "</span> + <span class="keyword">this</span>.compareValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>LinkedTransferQueue：</strong>转移队列，</p>
<ul>
<li>使用 transfer 方法，没有消费者，就阻塞。必须有消费者（take()方法的调用者），实现数据的即时处理（电话）。</li>
<li>无容量的，放数组，容量为零，这时候要阻塞。等另一个线程来拿，不经过容器的存储来转移数组。</li>
<li>使用 add方法，直接存在容器中。队列会保存数据，不做阻塞等待（短信）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_07_TransferQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    TransferQueue&lt;String&gt; queue = <span class="keyword">new</span> LinkedTransferQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Test_07_TransferQueue t = <span class="keyword">new</span> Test_07_TransferQueue();<span class="comment">//为了匿名内部累方法中获得queue引用。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*new Thread(new Runnable() &#123;</span></span><br><span class="line"><span class="comment">            @Override</span></span><br><span class="line"><span class="comment">            public void run() &#123;</span></span><br><span class="line"><span class="comment">                try &#123;</span></span><br><span class="line"><span class="comment">                    System.out.println(Thread.currentThread().getName() + " thread begin " );</span></span><br><span class="line"><span class="comment">                    System.out.println(Thread.currentThread().getName() + " - " + t.queue.take());</span></span><br><span class="line"><span class="comment">                &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">                    e.printStackTrace();</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;, "output thread").start();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        try &#123;</span></span><br><span class="line"><span class="comment">            TimeUnit.SECONDS.sleep(2);</span></span><br><span class="line"><span class="comment">        &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">            e.printStackTrace();</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        try &#123;</span></span><br><span class="line"><span class="comment">            t.queue.transfer("test string");</span></span><br><span class="line"><span class="comment">        &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">            e.printStackTrace();</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    t.queue.transfer(<span class="string">"test string"</span>);</span><br><span class="line">                    <span class="comment">// t.queue.add("test string");</span></span><br><span class="line">                    System.out.println(<span class="string">"add ok"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" thread begin "</span> );</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" - "</span> + t.queue.take());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"output thread"</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>SynchronusQueue：</strong>同步队列，是一个容量为 0 的队列。是一个特殊的 TransferQueue。</p>
<ul>
<li>必须现有消费线程等待，才能使用的队列。</li>
<li>add 方法，无阻塞。若没有消费线程阻塞等待数据，则抛出非阻塞异常。</li>
<li>put 方法，有阻塞。若没有消费线程阻塞等待数据，则阻塞。</li>
<li>场景：玩家与玩家之间的匹配。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_08_SynchronusQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    BlockingQueue&lt;String&gt; queue = <span class="keyword">new</span> SynchronousQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Test_08_SynchronusQueue t = <span class="keyword">new</span> Test_08_SynchronusQueue();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" thread begin "</span> );</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" - "</span> + t.queue.take());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"output thread"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*try &#123;</span></span><br><span class="line"><span class="comment">            TimeUnit.SECONDS.sleep(3);</span></span><br><span class="line"><span class="comment">        &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">            e.printStackTrace();</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        <span class="comment">// t.queue.add("test add");</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t.queue.put(<span class="string">"test put"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" queue size : "</span> + t.queue.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="元婴圆满（线程池）"><a href="#元婴圆满（线程池）" class="headerlink" title="元婴圆满（线程池）"></a>元婴圆满（线程池）</h3><p>​        <strong>Executor：</strong>线程池顶级接口。定义方法，void execute(Runnable)。方法是用于处理任务的一个服务方法。调用者提供 Runnable 接口的实现，线程池通过线程执行这个 Runnable。服务方法无返回值的。是 Runnable 接口中的 run 方法无返回值。常用方法 - void execute(Runnable)，作用是启动线程任务的。</p>
<p>​        他不是线程池，他是线程池线程池底层处理机制。在使用线程池的时候，底层如何处理本线程的逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_01_MyExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Test_01_MyExecutor().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" - test executor"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(command).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>ExecutorService：</strong>Executor 接口的子接口。提供了一个新的服务方法，submit。有返回值（Future 类型）。submit 方法提供了 overload 方法。其中有参数类型为 Runnable 的，不需要提供返回值的；有参数类型为 Callable，可以提供线程执行后的返回值。</p>
<ul>
<li><p>他是线程池服务类型。所有的线程池类型都实现这个接口，实现这个接口，代表可以提供线程池能力。</p>
</li>
<li><p>Future是 submit 方法的返回值。代表未来，也就是线程执行结束后的一种结果。如返回值。</p>
</li>
<li><p>常见方法</p>
<ul>
<li>void execute(Runnable)</li>
<li>Future submit(Callable)</li>
<li>Future submit(Runnable)</li>
<li>shutdown()：优雅关闭。 不是强行关闭线程池，回收线程池中的资源。而是不再处理新的任务，将已接收的任务处理完毕后再关闭。</li>
</ul>
</li>
<li><p>线程池状态</p>
<ul>
<li>Running - 线程池正在执行中。活动状态。</li>
<li>ShuttingDown - 线程池正在关闭过程中。优雅关闭。一旦进入这个状态，线程池不再接收新的任务，处理所有已接收的任务，处理完毕后，关闭线程池。不能执行submit方法和execute方法。</li>
<li>Terminated - 线程池已经关闭。不能执行submit方法和execute方法。</li>
</ul>
</li>
</ul>
<hr>
<p><strong>Future：</strong>未来结果，代表线程任务执行结束后的结果。获取线程执行结果的方式是通过 get 方法获取的。</p>
<ul>
<li>get 无参，阻塞等待线程执行结束，并得到结果。</li>
<li>get 有参，阻塞固定时长，等待线程执行结束后的结果，如果在阻塞时长范围内，线程未执行结束，抛出异常。</li>
<li>常用方法：<ul>
<li>T get() </li>
<li>T get(long, TimeUnit)</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_03_Future</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">        <span class="comment">/*FutureTask&lt;String&gt; task = new FutureTask&lt;&gt;(new Callable&lt;String&gt;() &#123;</span></span><br><span class="line"><span class="comment">            @Override</span></span><br><span class="line"><span class="comment">            public String call() throws Exception &#123;</span></span><br><span class="line"><span class="comment">                return "first future task";</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        new Thread(task).start();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        System.out.println(task.get());*/</span></span><br><span class="line">        <span class="comment">// 上面代码和下面一模一样的</span></span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        Future&lt;String&gt; future = service.submit(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"aaa"</span>);</span><br><span class="line">                <span class="keyword">return</span> Thread.currentThread().getName() + <span class="string">" - test executor"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(future);</span><br><span class="line">        System.out.println(future.isDone()); <span class="comment">// 查看线程是否结束， 任务是否完成。 call方法是否执行结束</span></span><br><span class="line"></span><br><span class="line">        System.out.println(future.get()); <span class="comment">// 获取call方法的返回值。</span></span><br><span class="line">        System.out.println(future.isDone());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>Callable：</strong>可执行接口， 类似 Runnable 接口，也是可以启动一个线程的接口。其中定义的方法是<br>call，call 方法的作用和 Runnable 中的 run 方法完全一致，call 方法有返回值。</p>
<ul>
<li>接口方法 ： Object call();相当于 Runnable 接口中的 run 方法。区别为此方法有返回值。<br>不能抛出已检查异常。</li>
<li>和 Runnable 接口的选择 - 需要返回值或需要抛出异常时，使用 Callable，其他情况可<br>任意选择。</li>
</ul>
<hr>
<p><strong>Executors：</strong>工具类型，为 Executor 线程池提供工具方法。</p>
<ul>
<li>可以快速的提供若干种线程池。如：固定容量的，无限容量的，容量为 1 等各种线程池。</li>
<li>线程池是一个进程级的重量级资源。默认的生命周期和 JVM 一致。当开启线程池后，直到 JVM 关闭为止，是线程池的默认生命周期。如果手工调用 shutdown 方法，那么线程池执行所有的任务后，自动关闭。不调用shutdown方法，程序一直不关闭的。</li>
<li>开始 - 创建线程池。</li>
<li>结束 - JVM 关闭或调用 shutdown 并处理完所有的任务。</li>
<li>类似 Arrays，Collections 等工具类型的功用。</li>
</ul>
<hr>
<p><strong>FixedThreadPool：</strong>容量固定的线程池。活动状态和线程池容量是有上限的线程池。</p>
<ul>
<li><p>所有的线程池中，都有一个任务队列。使用的是 BlockingQueue<runnable>作为任务的载体。当任务数量大于线程池容量的时候，没有运行的任务保存在任务队列中，当线程有空闲的，自动从队列中取出任务执行。</runnable></p>
</li>
<li><p>使用场景： 大多数情况下，使用的线程池，首选推荐 FixedThreadPool。OS 系统和硬件是有线程支持上限。不能随意的无限制提供线程池。</p>
</li>
<li><p>线程池默认的容量上限是 Integer.MAX_VALUE。</p>
</li>
<li><p>常见的线程池容量： PC - 200。 服务器 - 1000~10000</p>
</li>
<li><p>queued tasks - 任务队列，completed tasks - 结束任务队列</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_02_FixedThreadPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService service =</span><br><span class="line">                Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            service.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" - test executor"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//[Running, pool size = 5, active threads = 5, queued tasks = 1, completed tasks             = 0]</span></span><br><span class="line">        System.out.println(service);</span><br><span class="line"></span><br><span class="line">        service.shutdown();</span><br><span class="line">        <span class="comment">// 是否已经结束， 相当于回收了资源。</span></span><br><span class="line">        System.out.println(service.isTerminated()); <span class="comment">// false</span></span><br><span class="line">        <span class="comment">// 是否已经关闭， 是否调用过shutdown方法</span></span><br><span class="line">        System.out.println(service.isShutdown());   <span class="comment">//true</span></span><br><span class="line">        <span class="comment">// [Shutting down, pool size = 5, active threads = 5, queued tasks = 1, completed               tasks = 0]</span></span><br><span class="line">        System.out.println(service);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// service.shutdown();</span></span><br><span class="line">        System.out.println(service.isTerminated()); <span class="comment">//true</span></span><br><span class="line">        System.out.println(service.isShutdown());   <span class="comment">//true</span></span><br><span class="line">        <span class="comment">// [Terminated, pool size = 0, active threads = 0, queued tasks = 0, completed                 tasks = 6]</span></span><br><span class="line">        System.out.println(service);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​        <strong>CachedThreadPool：</strong>缓存的线程池。容量不限（Integer.MAX_VALUE）。自动扩容。容量管理策略：如果线程池中的线程数量不满足任务执行，创建新的线程。每次有新任务无法即时处理的时候，都会创建新的线程。</p>
<ul>
<li>当线程池中的线程空闲时长达到一定的临界值（默认 60 秒），自动释放线程。</li>
<li>默认线程空闲 60 秒，自动销毁。</li>
<li>应用场景： 内部应用或测试应用。 内部应用，有条件的内部数据瞬间处理时应用，如：电信平台夜间执行数据整理（有把握在短时间内处理完所有工作，且对硬件和软件有足够的信心）。 </li>
<li>测试应用，在测试的时候，尝试得到硬件或软件的最高负载量，用于提供FixedThreadPool 容量的指导。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_05_CachedThreadPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService service = Executors.newCachedThreadPool();</span><br><span class="line">        System.out.println(service);    <span class="comment">// 容量为0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">            service.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" - test executor"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(service);    <span class="comment">// 容量为5</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">65</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(service);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>ScheduledThreadPool：</strong>计划任务线程池。可以根据计划自动执行任务的线程池。</p>
<ul>
<li>scheduleAtFixedRate(Runnable, start_limit, limit, timeunit)<ul>
<li>runnable - 要执行的任务。</li>
<li>start_limit - 第一次任务执行的间隔。</li>
<li>limit - 多次任务执行的间隔。</li>
<li>timeunit - 多次任务执行间隔的时间单位。</li>
</ul>
</li>
<li>他是阻塞的，效率低下。</li>
<li>他本质就是DelayedQueue</li>
<li>每间隔一定的时间，随机一个线程运行，并且运行完的线程，不会销毁，会继续等待下次选中运行。</li>
<li>使用场景： 计划任务时选用（具体与DelaydQueue比较后选择），如：电信行业中的数据整理，每分钟整理，每消失整理，每天整理等.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_07_ScheduledThreadPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ScheduledExecutorService service = Executors.newScheduledThreadPool(<span class="number">3</span>);</span><br><span class="line">        System.out.println(service);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定时完成任务。 scheduleAtFixedRate(Runnable, start_limit, limit, timeunit)</span></span><br><span class="line">        <span class="comment">// runnable - 要执行的任务。</span></span><br><span class="line">        service.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>, <span class="number">300</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>SingleThreadExceutor：</strong>单一容量的线程池。使用场景： 所有任务交给它处理，保证任务顺序时使用。如： 游戏大厅中的公共频道聊天。秒杀。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_06_SingleThreadExecutor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService service = Executors.newSingleThreadExecutor();</span><br><span class="line">        System.out.println(service);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">            service.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" - test executor"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>ForkJoinPool：</strong>分支合并线程池（mapduce 类似的设计思想，递归思想的运用）。适合用于处理复杂任务。</p>
<ul>
<li>初始化线程容量与 CPU 核心数相关。</li>
<li>线程池中运行的内容必须是 ForkJoinTask 的子类型（RecursiveTask,RecursiveAction）。</li>
<li>ForkJoinPool - 分支合并线程池。 可以递归完成复杂任务。要求可分支合并的任务必须是 ForkJoinTask 类型的子类型。其中提供了分支和合并的能力。ForkJoinTask 类型提供了两个抽象子类型，RecursiveTask 有返回结果的分支合并任务,RecursiveAction 无返回结果的分支合并任务。（Callable/Runnable）compute 方法：就是任务的执行逻辑。</li>
<li>ForkJoinPool 没有所谓的容量。默认都是 1 个线程。根据任务自动的分支新的子线程。当子线程任务结束后，自动合并。所谓自动是根据 fork 和 join 两个方法实现的。</li>
<li>应用： 主要是做科学计算或天文计算的。数据分析的.</li>
<li>拿空间换时间，效率高，但要看CPU能力。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_08_ForkJoinPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span>[] numbers = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1000000</span>];</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_SIZE = <span class="number">50000</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> Random r = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.length; i++)&#123;</span><br><span class="line">            numbers[i] = r.nextInt(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AddTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt;</span>&#123; <span class="comment">// RecursiveAction</span></span><br><span class="line">        <span class="keyword">int</span> begin, end;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">AddTask</span><span class="params">(<span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.begin = begin;</span><br><span class="line">            <span class="keyword">this</span>.end = end;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>((end - begin) &lt; MAX_SIZE)&#123;</span><br><span class="line">                <span class="keyword">long</span> sum = <span class="number">0L</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = begin; i &lt; end; i++)&#123;</span><br><span class="line">                    sum += numbers[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// System.out.println("form " + begin + " to " + end + " sum is : " + sum);</span></span><br><span class="line">                <span class="keyword">return</span> sum;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> middle = begin + (end - begin)/<span class="number">2</span>;</span><br><span class="line">                AddTask task1 = <span class="keyword">new</span> AddTask(begin, middle);</span><br><span class="line">                AddTask task2 = <span class="keyword">new</span> AddTask(middle, end);</span><br><span class="line">                task1.fork();<span class="comment">// 就是用于开启新的任务的。 就是分支工作的。 就是开启一个新的线程任务。</span></span><br><span class="line">                task2.fork();</span><br><span class="line">                <span class="comment">// join - 合并。将任务的结果获取。 这是一个阻塞方法。一定会得到结果数据。</span></span><br><span class="line">                <span class="keyword">return</span> task1.join() + task2.join();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> result = <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.length; i++)&#123;</span><br><span class="line">            result += numbers[i];</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(result);</span><br><span class="line"></span><br><span class="line">        ForkJoinPool pool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        AddTask task = <span class="keyword">new</span> AddTask(<span class="number">0</span>, numbers.length);</span><br><span class="line"></span><br><span class="line">        Future&lt;Long&gt; future = pool.submit(task);</span><br><span class="line">        System.out.println(future.get());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>ThreadPoolExecutor：</strong>线程池底层实现。除 ForkJoinPool 外，其他常用线程池底层都是使用ThreadPoolExecutor实现的。public ThreadPoolExecutor(int corePoolSize，int maximumPoolSize，long keepAliveTime，TimeUnit unit，BlockingQueue<runnable> workQueue);</runnable></p>
<ul>
<li>corePoolSize： 核心容量，创建线程池的时候，默认有多少线程。也是线程池保持的最少线程数</li>
<li>maximumPoolSize： 最大容量，线程池最多有多少线程</li>
<li>keepAliveTime：生命周期，0 为永久。当线程空闲多久后，自动回收。</li>
<li>unit：生命周期单位，为生命周期提供单位，如：秒，毫秒</li>
<li>workQueue：任务队列，阻塞队列。注意，泛型必须是</li>
</ul>
<p>使用场景： 默认提供的线程池不满足条件时使用。如：初始线程数据 4，最大线程数200，线程空闲周期 30 秒。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_09_ThreadPoolExecutor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 模拟fixedThreadPool， 核心线程5个，最大容量5个，线程的生命周期无限。</span></span><br><span class="line">        ExecutorService service = </span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">5</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS, </span><br><span class="line">                        <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)&#123;</span><br><span class="line">            service.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" - test executor"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(service);</span><br><span class="line"></span><br><span class="line">        service.shutdown();</span><br><span class="line">        System.out.println(service.isTerminated());</span><br><span class="line">        System.out.println(service.isShutdown());</span><br><span class="line">        System.out.println(service);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        service.shutdown();</span><br><span class="line">        System.out.println(service.isTerminated());</span><br><span class="line">        System.out.println(service.isShutdown());</span><br><span class="line">        System.out.println(service);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">练习：</span><br><span class="line">启动若干线程，并行访问同一个容器中的数据。保证获取容器中数据时没有数据错误，且线程安全。</span><br><span class="line">如：售票，秒杀等业务。</span><br></pre></td></tr></table></figure>
<p>使用synchronized</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// static List&lt;String&gt; list = new Vector&lt;&gt;();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)&#123;</span><br><span class="line">            list.add(<span class="string">"String "</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">while</span>(list.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">" - "</span> + list.remove(<span class="number">0</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">"Thread"</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*for(int i = 0; i &lt; 10; i++)&#123;</span></span><br><span class="line"><span class="comment">            new Thread(new Runnable() &#123;</span></span><br><span class="line"><span class="comment">                @Override</span></span><br><span class="line"><span class="comment">                public void run() &#123;</span></span><br><span class="line"><span class="comment">                    while(true)&#123;</span></span><br><span class="line"><span class="comment">                        synchronized (list) &#123;</span></span><br><span class="line"><span class="comment">                            if(list.size() &lt;= 0)&#123;</span></span><br><span class="line"><span class="comment">                                break;</span></span><br><span class="line"><span class="comment">                            &#125;</span></span><br><span class="line"><span class="comment">                            System.out.println(Thread.currentThread().getName() + " - " + list.remove(0));</span></span><br><span class="line"><span class="comment">                        &#125;</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;, "Thread" + i).start();</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用queue</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class Test_02 &#123;</span><br><span class="line"></span><br><span class="line">    static Queue&lt;String&gt; list = new ConcurrentLinkedQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    static&#123;</span><br><span class="line">        for(int i = 0; i &lt; 10000; i++)&#123;</span><br><span class="line">            list.add(&quot;String &quot; + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for(int i = 0; i &lt; 10; i++)&#123;</span><br><span class="line">            new Thread(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    while(true)&#123;</span><br><span class="line">                        String str = list.poll();</span><br><span class="line">                        if(str == null)&#123;</span><br><span class="line">                            break;</span><br><span class="line">                        &#125;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + &quot; - &quot; + str);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, &quot;Thread&quot; + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>小编是一枚Java Coder，业余写文章，现主营微信公众号《Java患者》，喜欢的话关注我的公众号或者加我微信我们一起学习Java</em></p>
<p><img src="\111公众号.jpg" alt=""></p>
<h2 id="化神期（JVM1-7）"><a href="#化神期（JVM1-7）" class="headerlink" title="化神期（JVM1.7）"></a>化神期（JVM1.7）</h2><h3 id="化神前期（jvm结构）"><a href="#化神前期（jvm结构）" class="headerlink" title="化神前期（jvm结构）"></a>化神前期（jvm结构）</h3><p><strong>jvm基本结构图：</strong></p>
<p><img src="\media\jvm基本结构图.jpg" alt="jvm基本结构图"></p>
<ul>
<li><strong>类加载子系统：</strong>类加载子系统负责从文件系统或者网络中加载 Class 信息，如ClassLoad这里面的组件。</li>
<li><strong>方法区：</strong>加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中可能还会存放运行时常量池信息，包括字符串字面量和数字常量（这部分常量信息是 Class 文件中常量池部分的内存映射）。</li>
<li><strong>Java 堆：</strong>java 堆在虚拟机启动的时候建立，它是 java 程序最主要的内存工作区域。几乎所有的java 对象实例都存放在 java 堆中。堆空间是所有线程共享的，这是一块与 java 应用密切相关的内存空间。</li>
<li><strong>直接内存：</strong>java 的 NIO 库允许 java 程序使用直接内存。直接内存是在 java 堆外的、直接向系统申请的内存空间。通常访问直接内存的速度会优于 java 堆。因此出于性能的考虑，读写频繁的场合可能会考虑使用直接内存。由于直接内存在 java 堆外，因此它的大小不会直接受限于 Xmx 指定的最大堆大小，但是系统内存是有限的，java 堆和直接内存的总和依然受限于操作系统能给出的最大内存。</li>
<li><strong>垃圾回收系统：</strong>垃圾回收系统是 java 虚拟机的重要组成部分，垃圾回收器可以对方法区、java 堆和直接内存进行回收。其中，java 堆是垃圾收集器的工作重点。和 C/C++不同，java 中所有的对象空间释放都是隐式的，也就是说，java 中没有类似 free()或者 delete()这样的函数释放指定的内存区域。对于不再使用的垃圾对象，垃圾回收系统会在后台默默工作，默默查找、标识并释放垃圾对象，完成包括 java 堆、方法区和直接内存中的全自动化管理。</li>
<li><strong>Java 栈：</strong>每一个 java 虚拟机线程都有一个私有的 java 栈，一个线程的 java 栈在线程创建的时候被创建，java 栈中保存着帧信息，java 栈中保存着局部变量、方法参数，同时和 java 方法的调用、返回密切相关。</li>
<li><strong>本地方法栈：</strong>本地方法栈和 java 栈非常类似，最大的不同在于 java 栈用于方法的调用，而本地方法栈则用于本地方法的调用，作为对 java 虚拟机的重要扩展，java 虚拟机允许 java 直接调用本地方法（通常使用 C 编写）。</li>
<li><strong>PC 寄存器：</strong>PC（Program Counter）寄存器也是每一个线程私有的空间，java 虚拟机会为每一个 java线程创建 PC 寄存器。在任意时刻，一个 java 线程总是在执行一个方法，这个正在被执行的方法称为当前方法。如果当前方法不是本地方法，PC 寄存器就会指向当前正在被执行的指令。如果当前方法是本地方法，那么 PC 寄存器的值就是 undefined。</li>
<li><strong>Java HotSpot Client 模式和 Server 模式的区别：</strong>当虚拟机运行在-client 模式的时候,使用的是一个代号为 C1 的轻量级编译器, 而-server模式启动的虚拟机采用相对重量级,代号为 C2 的编译器. C2 比 C1 编译器编译的相对彻底,服务起来之后,性能更高。<ul>
<li>JDK 安装目录/jre/lib/（x86、i386、amd32、amd64）/jvm.cfg文件中的内容，-server 和-client 哪一个配置在上，执行引擎就是哪一个。如果是 JDK1.5版本且是 64 位系统应用时，-client 无效。</li>
<li>–64 位系统内容<br>-server KNOWN<br>-client IGNORE</li>
<li>–32 位系统内容<br>-server KNOWN<br>-client KNOWN</li>
<li>注意 ：在部分 JDK1.6 版本和后续的 JDK 版本 (64 位系统 ) 中， -client 参数已经不起作用<br>了， Server 模式成为唯一。</li>
</ul>
</li>
</ul>
<h3 id="化神中期（堆结构及对象分代）"><a href="#化神中期（堆结构及对象分代）" class="headerlink" title="化神中期（堆结构及对象分代）"></a>化神中期（堆结构及对象分代）</h3><ul>
<li><strong>什么是分代，分代的必要性是什么？</strong></li>
</ul>
<blockquote>
<p>​        Java 虚拟机根据对象存活的周期不同，把堆内存划分为几块，一般分为新生代、老年代和永久代（对 HotSpot 虚拟机而言），这就是 JVM 的内存分代策略。<br>​        堆内存是虚拟机管理的内存中最大的一块，也是垃圾回收最频繁的一块区域，我们程序所有的对象实例都存放在堆内存中。给堆内存分代是为了提高对象内存分配和垃圾回收的效率。试想一下，如果堆内存没有区域划分，所有的新创建的对象和生命周期很长的对象放在一起，随着程序的执行，堆内存需要频繁进行垃圾收集，而每次回收都要遍历所有的对象，遍历这些对象所花费的时间代价是巨大的，会严重影响我们的 GC 效率，并且会产生碎片。<br>​        有了内存分代，情况就不同了，新创建的对象会在新生代中分配内存，经过多次回收仍然存活下来的对象存放在老年代中，静态属性、类信息等存放在永久代中，新生代中的对象存活时间短，只需要在新生代区域中频繁进行 GC，老年代中对象生命周期长，内存回收的频率相对较低，不需要频繁进行回收，永久代中回收效果太差，一般不进行垃圾回收，还可以根据不同年代的特点采用合适的垃圾收集算法。分代收集大大提升了收集效率，这些都是内存分代带来的好处。</p>
</blockquote>
<ul>
<li><strong>分代的划分Java</strong> </li>
</ul>
<blockquote>
<p>​        虚拟机将堆内存划分为 新生代、老年代和永久代 ，永久代是 HotSpot 虚拟机特有的概念（JDK1.8 之后为 metaspace 替代永久代），它采用永久代的方式来实现方法区，其他的虚拟机实现没有这一概念，而且 HotSpot 也有取消永久代的趋势，在 JDK 1.7 中 HotSpot 已经开始了“去永久化”，把原本放在永久代的字符串常量池移出。永久主要存放常量、类信息、静态变量等数据，与垃圾回收关系不大，新生代和老年代是垃圾回收的主要区域。</p>
</blockquote>
<p><img src="\media\堆内存简图.jpg" alt="堆内存简图"></p>
<ul>
<li><strong>新生代（Young Generation)</strong></li>
</ul>
<blockquote>
<p>​        新生成的对象优先存放在新生代中，新生代对象朝生夕死，存活率很低，在新生代Eden中，常规应用进行一次垃圾收集一般可以回收 70% ~ 95% 的空间，回收效率很高。<br>​        HotSpot 将新生代划分为三块，一块较大的 Eden（伊甸）空间和两块较小的 Survivor（幸存者）空间，默认比例为 8：1：1。划分的目的是因为 HotSpot 采用复制算法来回收新生代，设置这个比例是为了充分利用内存空间，减少浪费。新生成的对象在 Eden 区分配（大对象除外，大对象直接进入老年代），当 Eden 区没有足够的空间进行分配时，虚拟机将发起一次Minor GC。<br>​        GC 开始时，对象只会存在于 Eden 区和 From Survivor 区，To Survivor 区是空的（作为保留区域）。GC 进行时，Eden 区中所有存活的对象都会被复制到 To Survivor 区，而在 FromSurvivor 区中，仍存活的对象会根据它们的年龄值决定去向，年龄值达到年龄阀值（默认为15，新生代中的对象每熬过一轮垃圾回收，年龄值就加 1，GC 分代年龄存储在对象的 header中）的对象会被移到老年代中，没有达到阀值的对象会被复制到 To Survivor 区。接着清空Eden 区和 From Survivor 区，新生代中存活的对象都在 To Survivor 区。接着， From Survivor区和 To Survivor 区会交换它们的角色（复制算法减少碎片），也就是新的 To Survivor 区就是上次 GC 清空的 FromSurvivor 区，新的 From Survivor 区就是上次 GC 的 To Survivor 区，总之，不管怎样都会保证To Survivor 区在一轮 GC 后是空的。GC 时当 To Survivor 区没有足够的空间存放上一次新生代收集下来的存活对象时，需要依赖老年代进行分配担保，将这些对象存放在老年代中。</p>
</blockquote>
<ul>
<li><strong>老年代（Old Generationn ）</strong></li>
</ul>
<blockquote>
<p>​        在新生代中经历了多次（具体看虚拟机配置的阀值）GC 后仍然存活下来的对象会进入老年代中。老年代中的对象生命周期较长，存活率比较高，在老年代中进行 GC 的频率相对而言较低，而且回收的速度也比较慢。</p>
</blockquote>
<ul>
<li><strong>永久代（Permanent Generationn）</strong></li>
</ul>
<blockquote>
<p>​        永久代存储类信息、常量、静态变量、即时编译器编译后的代码等数据，对这一区域而言，Java 虚拟机规范指出可以不进行垃圾收集，一般而言不会进行垃圾回收。</p>
</blockquote>
<h3 id="化神后期（垃圾回收算法及分代垃圾）"><a href="#化神后期（垃圾回收算法及分代垃圾）" class="headerlink" title="化神后期（垃圾回收算法及分代垃圾）"></a>化神后期（垃圾回收算法及分代垃圾）</h3><p> <strong>常见 垃圾回收算法</strong></p>
<ul>
<li>引用计数 （Reference Counting ）：比较古老的回收算法。原理是此对象有一个引用，即增加一个计数，删除一个引用则减少一个计数。垃圾回收时，只用收集计数为 0 的对象。此算法最致命的是无法处理循环引用的问题。</li>
<li>复制（Copying）：此算法把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾回收时，遍历当前使用区域，把正在使用中的对象复制到另外一个区域中。此算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制过去以后还能进行相应的内存整理，不会出现“碎片”问题。当然，此算法的缺点也是很明显的，就是需要两倍内存空间。简图如下：</li>
</ul>
<p><img src="\media\复制算法.jpg" alt="复制算法"></p>
<ul>
<li>标记- 清除（Mark-Sweep ）：最古老的算法，此算法执行分两阶段。第一阶段从引用根节点开始标记所有被引用的对象，第二阶段遍历整个堆，把未标记的对象清除。此算法需要<strong>暂停整个应用</strong>，同时，会产生内存碎片。简图如下：</li>
</ul>
<p><img src="\media\标记-清楚算法.jpg" alt="标记-清楚算法"></p>
<ul>
<li>标记- 整理（Mark-Compact ）：此算法结合了“标记-清除”和“复制”两个算法的优点。也是分两阶段，第一阶段从根节点开始标记所有被引用对象，第二阶段遍历整个堆，把清除未标记对象并且把存活对象“压缩”到堆的其中一块，按顺序排放。此算法避免了“标记-清除”的碎片问题，同时也避免了“复制”算法的空间问题。简图如下：</li>
</ul>
<p><img src="\media\标记-整理.jpg" alt="标记-整理"></p>
<p><strong>垃圾收集器的分类</strong></p>
<ul>
<li><p>次收集器：Scavenge GC，指发生在新生代的 GC，因为新生代的 Java 对象大多都是朝生夕死，所以<br>Scavenge GC 非常频繁，一般回收速度也比较快。</p>
<ul>
<li>当 Eden 空间不足以为对象分配内存时，会触发 Scavenge GC。</li>
<li>一般情况下，当新对象生成，并且在 Eden 申请空间失败时，就会触发 Scavenge GC，对Eden 区域进行 GC，清除非存活对象，并且把尚且存活的对象移动到 Survivor 区。然后整理Survivor 的两个区。这种方式的 GC 是对年轻代的 Eden 区进行，不会影响到年老代。因为大部分对象都是从 Eden 区开始的，同时 Eden 区不会分配的很大，所以 Eden 区的 GC 会频繁进行。因而，一般在这里需要使用速度快、效率高的算法，使 Eden 去能尽快空闲出来。</li>
<li>当年轻代堆空间紧张时会被触发</li>
<li>相对于全收集而言，收集间隔较短</li>
</ul>
</li>
<li><p>全收集器：Full GC，指发生在老年代的 GC，出现了 Full GC 一般会伴随着至少一次的 Minor GC（老年代的对象大部分是 Scavenge GC 过程中从新生代进入老年代），比如：分配担保失败。FullGC 的速度一般会比 Scavenge GC 慢 10 倍以上。</p>
<ul>
<li>当老年代内存不足或者显式调用 System.gc()方法时，会触发 Full GC。</li>
<li>当老年代或者持久代堆空间满了，会触发全收集操作。</li>
<li>可以使用 System.gc()方法来显式的启动全收集，全收集一般根据堆大小的不同，需要的时间不尽相同，但一般会比较长。</li>
</ul>
</li>
<li><p>垃圾回收器的常规组合使用：</p>
<ul>
<li>Serial、ParNew、Parallel Scabenage构成新生代回收器。</li>
<li>Serial Old、Parallel Old、CMS是老年代回收器。</li>
<li>G1新老通用</li>
</ul>
</li>
</ul>
<p><img src="\media\垃圾回收的常见匹配.jpg" alt="垃圾回收的常见匹配"></p>
<p><strong>分代垃圾收集器</strong></p>
<ul>
<li>串行收集器（Serial ）：JDK1.3之前JVM唯一一个次收集器（新生代收集器），1.5版本也是默认次收集器，它是串收集器。<ul>
<li>Serial 收集器是 Hotspot 运行在 Client 模式下的默认新生代收集器。</li>
<li>它的特点是：只用一个 CPU（计算核心）/一条线程去完成 GC 工作, 且在进行垃圾收集时必须暂停其他所有的工作线程(“Stop The World” -后面简称 STW)。</li>
<li>可以使用-XX:+UseSerialGC 打开。虽然是单线程收集, 但它却简单而高效, 在 VM 管理内存不大的情况下(收集几十 M~一两百 M 的新生代), 停顿时间完全可以控制在几十毫秒~一百多毫秒内。</li>
<li>大多数收集器都是在串行收集器进行优化，减少他停顿的时间。</li>
</ul>
</li>
</ul>
<p><img src="\media\串行收集器.jpg" alt=""></p>
<ul>
<li><p>并行收集器（ParNew ）：ParNew 收集器其实是前面 Serial 的多线程版本,考虑用户等待的时间， 除使用多条线程进行 GC外, 包括 Serial可用的所有控制参数、收集算法、STW、对象分配规则、回收策略等都与 Serial 完全一样(也是VM启用 CMS 收集器-XX: +UseConcMarkSweepGC 的默认新生代收集器)。</p>
<p>由于存在线程切换的开销, ParNew 在单 CPU 的环境中比不上 Serial, 且在通过超线程技术实现的两个 CPU 的环境中也不能 100%保证能超越 Serial. 但随着可用的 CPU 数量的增加,收集效率肯定也会大大增加(ParNew 收集线程数与 CPU 的数量相同, 因此在 CPU 数量过大的环境中, 可用-XX:ParallelGCThreads=<n>参数控制 GC 线程数，一般与CPU的线程数相同)。</n></p>
</li>
</ul>
<p><img src="\media\并行收集器.jpg" alt=""></p>
<ul>
<li><p>Parallel Scavenge 收集器：与 ParNew 类似, Parallel Scavenge 也是使用复制算法, 也是并行多线程收集器. 但与其他收集器关注尽可能缩短垃圾收集时间不同, Parallel Scavenge 更关注系统吞吐量:</p>
<ul>
<li><p>系统吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)</p>
</li>
<li><p>停顿时间越短就越适用于用户交互的程序-良好的响应速度能提升用户的体验;</p>
</li>
<li><p>而高吞吐量则适用于后台运算而不需要太多交互的任务-可以最高效率地利用CPU时间,尽快地完成程序的运算任务. </p>
</li>
<li><p>Parallel Scavenge 提供了如下参数设置系统吞吐量:</p>
<p><img src="\media\Parallel Scavenge 参数.jpg" alt=""></p>
</li>
</ul>
</li>
<li><p>Serial Old 收集器：Serial Old 是 Serial 收集器的老年代版本, 同样是单线程收集器,使用“标记-整理”算法</p>
</li>
</ul>
<p><img src="\media\Serial Old收集器.jpg" alt=""></p>
<ul>
<li>Parallel Old 收集器：Parallel Old 是 Parallel Scavenge 收集器的老年代版本, 使用多线程和“标记－整理”算<br>法, 吞吐量优先, 主要与 Parallel Scavenge 配合在注重吞吐量及 CPU 资源敏感系统内使用；</li>
</ul>
<p><img src="\media\Parallel Old 收集器.jpg" alt=""></p>
<ul>
<li><p>CMS 收集器 （Concurrent Mark Sweep ）：CMS(Concurrent Mark Sweep)收集器是一款具有划时代意义的收集器, 一款真正意义上的并发收集器, 虽然现在已经有了理论意义上表现更好的 G1 收集器, 但现在主流互联网企业线上选用的仍是 CMS(如 Taobao、微店)。</p>
<ul>
<li>并发（concurrent）包含用户线程，并行（Parallel）不包含。</li>
<li>CMS是一种以获取最短回收停顿时间为目标的收集器(CMS又称多并发低暂停的收集器)，基于”标记-清除”算法实现， 整个 GC 过程分为以下 4 个步骤:<ul>
<li>初始标记(CMS initial mark)</li>
<li>并发标记(CMS concurrent mark: GC Roots Tracing 过程)</li>
<li>重新标记(CMS remark)</li>
<li>并发清除(CMS concurrent sweep: 已死对象将会就地释放, 注意:此处没有压缩)</li>
</ul>
</li>
<li>其中 1，3 两个步骤(初始标记、重新标记)仍需 STW. 但初始标记仅只标记一下 GC Roots能直接关联到的对象, 速度很快; 而重新标记则是为了修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录, 虽然一般比初始标记阶段稍长, 但要远小于并发标记时间。CMS 特点：<ul>
<li>CMS 默认启动的回收线程数=(CPU 数目+3)4，当 CPU 数&gt;4 时, GC线程一般占用不超过 25%的 CPU 资源, 但是当 CPU 数&lt;=4 时, GC线程可能就会过多的占用用户 CPU 资源, 从而导致应用程序变慢, 总吞吐量降低。</li>
<li>无法处理浮动垃圾, 可能出现 Promotion Failure、Concurrent Mode Failure 而导致另一<br>次 Full GC 的产生: 浮动垃圾是指在 CMS 并发清理阶段用户线程运行而产生的新垃圾. 由于<br>在 GC 阶段用户线程还需运行, 因此还需要预留足够的内存空间给用户线程使用, 导致 CMS<br>不 能 像 其 他收 集 器那 样 等到 老 年 代几 乎 填满 了 再进 行 收 集. 因此 CMS 提 供 了<br>-XX:CMSInitiatingOccupancyFraction 参 数 来 设 置 GC 的 触 发 百 分 比 ( 以 及<br>-XX:+UseCMSInitiatingOccupancyOnly 来启用该触发百分比), 当老年代的使用空间超过该比例<br>后 CMS 就会被触发(JDK 1.6 之后默认 92%). 但当 CMS 运行期间预留的内存无法满足程序需<br>要, 就会出现上述 Promotion Failure 等失败, 这时 VM 将启动后备预案: 临时启用 Serial Old<br>收集器来重新执行Full GC(CMS通常配合大内存使用, 一旦大内存转入串行的Serial GC, 那停<br>顿的时间就是大家都不愿看到的了).</li>
<li>最后, 由于 CMS 采用”标记-清除”算法实现, 可能会产生大量内存碎片. 内存碎片过<br>多 可 能 会 导 致 无 法 分 配 大 对 象 而 提 前 触 发 Full GC. 因 此 CMS 提 供 了<br>-XX:+UseCMSCompactAtFullCollection 开关参数, 用于在 Full GC 后再执行一个碎片整理过程.<br>但内存整理是无法并发的, 内存碎片问题虽然没有了, 但停顿时间也因此变长了, 因此 CMS<br>还提供了另外一个参数-XX:CMSFullGCsBeforeCompaction 用于设置在执行 N 次不进行内存整<br>理的 Full GC 后, 跟着来一次带整理的(默认为 0: 每次进入 Full GC 时都进行碎片整理).</li>
</ul>
</li>
</ul>
<p><img src="\media\CMS收集器.jpg" alt=""></p>
</li>
<li><p>分区收集- G1 收集器：G1(Garbage-First)是一款面向服务端应用的收集器, 主要目标用于配备多颗 CPU 的服务器治理大内存，-XX:+UseG1GC 启用 G1 收集器。</p>
<ul>
<li>与其他基于分代的收集器不同, G1 将整个 Java 堆划分为多个大小相等的独立区域(Region), 虽然还保留有新生代和老年代的概念, 但新生代和老年代不再是物理隔离的了,它们都是一部分 Region(不需要连续)的集合.如：</li>
</ul>
<p><img src="\media\G1.jpg" alt=""></p>
<ul>
<li><p>每块区域既有可能属于 O 区、也有可能是 Y 区，因此不需要一次就对整个老年代/新生代回收。而是当线程并发寻找可回收的对象时，有些区块包含可回收的对象要比其他区块多很多。 虽然在清理这些区块时 G1 仍然需要暂停应用线程,，但可以用相对较少的时间优先回收垃圾较多的 Region。这种方式保证了 G1 可以在有限的时间内获取尽可能高的收集效率。</p>
</li>
<li><p>G1的新生代收集跟ParNew类似: 存活的对象被转移到一个或多个Survivor Regions.，如果存活时间达到阀值, 这部分对象就会被提升到老年代.如图：</p>
<p><img src="\media\G11.jpg" alt=""></p>
</li>
<li><p>其特定是：</p>
<ul>
<li>一整块堆内存被分为多个 Regions.</li>
<li>存活对象被拷贝到新的 Survivor 区或老年代.</li>
<li>年轻代内存由一组不连续的 heap 区组成, 这种方法使得可以动态调整各代区域尺寸.</li>
<li>Young GC 会有 STW 事件, 进行时所有应用程序线程都会被暂停.</li>
<li>多线程并发 GC.</li>
</ul>
</li>
<li><p>G1 老年代 GC 特点如下 :</p>
<ul>
<li>并发标记阶段<ol>
<li>在与应用程序并发执行的过程中会计算活跃度信息 .</li>
<li>这些活跃度信息标识出那些 regions 最适合在 STW 期间回收 (which regions will be best<br>to reclaim during an evacuation pause).</li>
<li>不像 CMS 有清理阶段 .</li>
</ol>
</li>
<li>再次标记阶段<ol>
<li>使用 Snapshot-at-the-Beginning(SATB) 算法比 CMS 快得多 .</li>
<li>空 region 直接被回收 .</li>
</ol>
</li>
<li>拷贝 / 清理阶段 (Copying/Cleanup Phase)<ol>
<li>年轻代与老年代同时回收 .</li>
<li>老年代内存回收会基于他的活跃度信息</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="化神圆满（JVM优化）"><a href="#化神圆满（JVM优化）" class="headerlink" title="化神圆满（JVM优化）"></a>化神圆满（JVM优化）</h3><p><strong>JDK 常用 JVM 优化相关命令</strong></p>
<p><img src="\media\JVM相关命令.jpg" alt=""></p>
<ul>
<li><p>jps</p>
<ul>
<li>jps - l：显示线程 id 和执行线程的主类名</li>
<li>jps -v：显示线程 id 和执行线程的主类名和 JVM 配置信息</li>
</ul>
</li>
<li><p>jstat</p>
<ul>
<li>jstat -参数 线程 id 执行时间（单位毫秒） 执行次数</li>
<li>如：jstat -gc 4488 30 10<ul>
<li>SXC - survivor 初始空间大小，单位字节。（X为survivor中X区域）</li>
<li>SXU - survivor 使用空间大小， 单位字节。</li>
<li>EC - eden 初始空间大小</li>
<li>EU - eden 使用空间大小</li>
<li>OC - old 初始空间大小</li>
<li>OU - old 使用空间大小</li>
<li>PC - permanent 初始空间大小</li>
<li>PU - permanent 使用空间大小</li>
<li>YGC - youngGC 收集次数</li>
<li>YGCT - youngGC 收集使用时长， 单位秒</li>
<li>FGC - fullGC 收集次数</li>
<li>FGCT - fullGC 收集使用时长</li>
<li>GCT - 总计收集使用总时长 YGCT+FGCT</li>
</ul>
</li>
</ul>
</li>
<li><p>jvisualvm：一个 JDK 内置的图形化 VM 监视管理工具。一般我们会在里面安装visualgc 插件。（工具、插件、可用插件），设置编辑url连接地址。</p>
<p><strong>JVM 常见参数</strong><br><em>配置方式：java [options] MainClass [arguments]<br>options - JVM 启动参数。 配置多个参数的时候，参数之间使用空格分隔。<br>参数命名： 常见为 -参数名<br>参数赋值： 常见为 -参数名=参数值 | -参数名:参数值</em></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;GarbageCollectorMXBean&gt; l = ManagementFactory.getGarbageCollectorMXBeans();  </span><br><span class="line">        <span class="keyword">for</span>(GarbageCollectorMXBean b : l) &#123;  </span><br><span class="line">            System.out.println(b.getName());  <span class="comment">// 收集器名称</span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.in.read();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>内存设置</p>
<ul>
<li>-Xms:初始堆大小，JVM 启动的时候，给定堆空间大小。</li>
<li>-Xmx:最大堆大小，JVM 运行过程中，如果初始堆空间不足的时候，最大可以扩展到多少。</li>
<li>-Xmn：设置年轻代大小。整个堆大小=年轻代大小+年老代大小+持久代大小。持久代一般固定大小为 64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun 官方推荐配置为整个堆的 3/8。</li>
<li>-Xss： 设置每个线程的 Java 栈大小。JDK5.0 以后每个线程 Java 栈大小为 1M，以前每个线程堆栈大小为 256K。根据应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在 3000~5000 左右。</li>
<li>-XX:NewSize=n:设置年轻代大小</li>
<li>-XX:NewRatio=n:设置年轻代和年老代的比值。如:为 3，表示年轻代与年老代比值为 1：3，年轻代占整个年轻代+年老代和的 1/4</li>
<li>-XX:SurvivorRatio=n:年轻代中 Eden 区与两个 Survivor 区的比值。注意 Survivor 区有两个。如：3，表示 Eden：Survivor=3：2，一个 Survivor 区占整个年轻代的 1/5</li>
<li>-XX:MaxPermSize=n:设置持久代大小</li>
<li>-XX:MaxTenuringThreshold：设置垃圾最大年龄。如果设置为 0 的话，则年轻代对象不经过 Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在 Survivor 区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概率。</li>
</ul>
</li>
<li><p>收集器设置</p>
<ul>
<li>-XX:+UseSerialGC:设置串行收集器，年轻带收集器， 次收集器</li>
<li>-XX:+UseParallelGC:设置并行收集器</li>
<li>-XX:+UseParNewGC:设置年轻代为并行收集。可与 CMS 收集同时使用。JDK5.0 以上，JVM会根据系统配置自行设置，所以无需再设置此值。</li>
<li>-XX:+UseParallelOldGC:设置并行年老代收集器，JDK6.0 支持对年老代并行收集。</li>
<li>-XX:+UseConcMarkSweepGC:设置年老代并发收集器，测试中配置这个以后，-XX:NewRatio的配置失效，原因不明。所以，此时年轻代大小最好用-Xmn 设置。</li>
<li>-XX:+UseG1GC:设置 G1 收集器</li>
</ul>
</li>
<li><p>垃圾回收统计信息，类似日志的配置信息。会有控制台相关信息输出。 商业项目上线的时候，使用 loggc</p>
<ul>
<li>-XX:+PrintGC</li>
<li>-XX:+Printetails</li>
<li>-XX:+PrintGCTimeStamps</li>
<li>-Xloggc:filename</li>
</ul>
</li>
<li><p>并行收集器设置</p>
<ul>
<li>-XX:ParallelGCThreads=n:设置并行收集器收集时最大线程数使用的 CPU 数。并行收集线程数。</li>
<li>-XX:MaxGCPauseMillis=n:设置并行收集最大暂停时间，单位毫秒。可以减少 STW 时间。</li>
<li>-XX:GCTimeRatio=n:设置垃圾回收时间占程序运行时间的百分比。公式为 1/(1+n)并发收集器设置</li>
<li>-XX:+CMSIncrementalMode:设置为增量模式。适用于单 CPU 情况。</li>
<li>-XX:+UseAdaptiveSizePolicy：设置此选项后，并行收集器会自动选择年轻代区大小和相应的 Survivor 区比例，以达到目标系统规定的最低相应时间或者收集频率等，此值建议使用并行收集器时，一直打开。</li>
<li>-XX:CMSFullGCsBeforeCompaction=n：由于并发收集器不对内存空间进行压缩、整理，所以运行一段时间以后会产生“碎片”，使得运行效率降低。此值设置运行多少次 GC 以后对内存空间进行压缩、整理。</li>
<li>-XX:+UseCMSCompactAtFullCollection：打开对年老代的压缩。可能会影响性能，但是可<br>以消除碎片</li>
</ul>
</li>
<li><p>内存设置经验分享</p>
<ul>
<li>JVM 中最大堆大小有三方面限制：<ul>
<li>相关操作系统的数据模型（32-bt 还是 64-bit）限制；</li>
<li>系统的可用虚拟内存限制；</li>
<li>系统的可用物理内存限制。</li>
<li>32 位系统 下，一般限制在 1.5G~2G；64 为操作系统对内存无限制。</li>
</ul>
</li>
<li>Tomcat 配置方式： 编写 catalina.bat|catalina.sh ，增加 JAVA_OPTS 参数设置。 windows和 linux 配置方式不同。 windows - set “JAVA_OPTS=%JAVA_OPTS% 自定义参数 “ ； linux -JAVA_OPTS=”$JAVA_OPTS 自定义参数 “常见设置：<ul>
<li>-Xmx3550m -Xms3550m -Xmn2g -Xss128k 适合开发过程的测试应用。要求物理内存大于4G。<ul>
<li>设置JVM最大可用内存与初始内存相同，可以避免每次垃圾完成后JVM重新分配内存。</li>
<li>-Xmn2g，设置年轻代为2个g，持久代一般固定大小为64m，所以增大年轻代后，将会减小老年代大小。官方推荐设置成整个堆的3/8。</li>
<li>-Xss128k ，设置每个线程的堆栈大小，JDK1.5后每个线程栈大小为1M，以前每个线程栈大小为256k。在相同物理内存下，减少这个值能生成更多的线程，但是操作系统对进程内的线程数量是有限的，不能无线生成，经验值在3000~5000左右。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>收集器设置经验分享</p>
<ul>
<li>关于收集器的选择 JVM 给了三种选择：串行收集器、并行收集器、并发收集器，但是串行收集器只适用于小数据量的情况，所以这里的选择主要针对并行收集器和并发收集器。默认情况下，JDK5.0 以前都是使用串行收集器，如果想使用其他收集器需要在启动时加入相应参数。JDK5.0 以后，JVM 会根据当前系统配置进行判断。</li>
<li>常见配置：<ul>
<li>并行收集器主要以到达一定的吞吐量为目标，适用于科学计算和后台处理等。</li>
<li>-Xmx3800m -Xms3800m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:ParallelGCThreads=20</li>
<li>使用 ParallelGC 作为并行收集器， GC 线程为 20（CPU 核心数&gt;=20 时），内存问题根据硬件配置具体提供。建议使用物理内存的 80%左右作为 JVM 内存容量。</li>
<li>-Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:ParallelGCThreads=20<br>-XX:+UseParallelOldGC</li>
<li>指定老年代收集器，在JDK5.0之后的版本，ParallelGC对应的全收集器就是ParallelOldGC。可以忽略</li>
<li>-Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:MaxGCPauseMillis=100</li>
<li>指定 GC 时最大暂停时间。单位是毫秒。每次 GC 最长使用 100 毫秒。可以尽可能提高工作线程的执行资源。</li>
<li>-Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:MaxGCPauseMillis=100<br>-XX:+UseAdaptiveSizePolicy</li>
<li>UseAdaptiveSizePolicy 是提高年轻代 GC 效率的配置。次收集器执行效率。</li>
<li>并发收集器主要是保证系统的响应时间，减少垃圾收集时的停顿时间。适用于应用服务<br>器、电信领域、互联网领域等。</li>
<li>-Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:ParallelGCThreads=20<br>-XX:+UseConcMarkSweepGC -XX:+UseParNewGC</li>
<li>指定年轻代收集器为 ParNew，年老代收集器 ConcurrentMarkSweep，并发 GC 线程数为20（CPU 核心&gt;=20），并发 GC 的线程数建议使用（CPU 核心数+3）/4 或 CPU 核心数【不推荐使用】。</li>
<li>-Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseConcMarkSweepGC<br>-XX:CMSFullGCsBeforeCompaction=5 -XX:+UseCMSCompactAtFullCollection</li>
<li>CMSFullGCsBeforeCompaction=5 执行 5 次 GC 后，运行一次内存的整理。</li>
<li>UseCMSCompactAtFullCollection 执行老年代内存整理。可以避免内存碎片，提高 GC 过程中的效率，减少停顿时间。</li>
</ul>
</li>
</ul>
</li>
<li><p>简单总结</p>
<ul>
<li>年轻代大小选择<ul>
<li>响应时间优先的应用：尽可能设大，直到接近系统的最低响应时间限制（根据实际情况选择）。在此种情况下，年轻代收集发生的频率也是最小的。同时，减少到达年老代的对象。</li>
<li>吞吐量优先的应用：尽可能的设置大，可能到达 Gbit 的程度。因为对响应时间没有要求，垃圾收集可以并行进行，一般适合 8CPU 以上的应用。</li>
</ul>
</li>
<li>年老代大小选择<ul>
<li>响应时间优先的应用： 年老代使用并发收集器，所以其大小需要小心设置，一般要考虑并发会话率和会话持续时间等一些参数。如果堆设置小了，可以会造成内存碎片、高回收频率以及应用暂停而使用传统的标记清除方式；如果堆大了，则需要较 长的收集时间。最优化的方案，一般需要参考以下数据获得：<ul>
<li>并发垃圾收集信息</li>
<li>持久代并发收集次数</li>
<li>传统 GC 信息</li>
<li>花在年轻代和年老代回收上的时间比例</li>
<li>减少年轻代和年老代花费的时间，一般会提高应用的效率</li>
</ul>
</li>
<li>吞吐量优先的应用：一般吞吐量优先的应用都有一个很大的年轻代和一个较小的年老代。原因是，这样可以尽可能回收掉大部分短期对象，减少中期的对象，而年老代存放长期存活对象。</li>
<li>较小堆引起的碎片问题，因为年老代的并发收集器使用标记、清除算法，所以不会对堆进行压缩。当收集器回收时，他会把相邻的空间进行合并，这样可以分配给较大的对象。但是，当堆空间较小时，运行一段时间以后，就会出现“碎片”，如果并发收集器找不到足够的空间，那么并发收集器将会停止，然后使用传统的标记、整理方式进行回收。如果出现“碎片”，可能需要进行如下配置：<ul>
<li>-XX:+UseCMSCompactAtFullCollection：使用并发收集器时，开启对年老代的压缩。</li>
<li>-XX:CMSFullGCsBeforeCompaction=0：上面配置开启的情况下，这里设置多少次 Full GC后，对年老代进行压缩</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><em>小编是一枚Java Coder，业余写文章，现主营微信公众号《Java患者》，喜欢的话关注我的公众号或者加我微信我们一起学习Java</em></p>
<p><img src="\111公众号.jpg" alt=""></p>
<h2 id="合体期（网络编程）"><a href="#合体期（网络编程）" class="headerlink" title="合体期（网络编程）"></a>合体期（网络编程）</h2><h3 id="合体前期（Socket）"><a href="#合体前期（Socket）" class="headerlink" title="合体前期（Socket）"></a>合体前期（Socket）</h3><p>​            <em>首先注意，Socket不是Java中独有的概念，而是一个语言无关标准。任何可以实现网络编程的编程语言都有Socket。</em> </p>
<ul>
<li><p><strong>什么是</strong> <strong>Socket?</strong> </p>
<blockquote>
<p>​        网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个socket。 </p>
<p>​        建立网络通信连接至少要一个端口号。<em>socket</em> 本质是编程接口<em>(API)</em>，对 <em>TCP/IP</em> 的封装，<em>TCP/IP</em> 也要提供可供程序员做网络开发所用的接口，这就是 <em>Socket</em> 编程接口；<em>HTTP</em> 是轿车， 提供了封装或者显示数据的具体形式；<em>Socket</em> 是发动机，提供了网络通信的能力。 </p>
<p>​        <em>Socket</em> 的英文原义是<em>“</em>孔<em>”</em>或<em>“</em>插座<em>”</em>。作为 <em>BSD UNIX</em> 的进程通信机制，取后一种意思。通 常也称作<em>“</em>套接字<em>“</em>，用于描述 <em>IP</em> 地址和端口，是一个通信链的句柄，可以用来实现不同虚 拟机或不同计算机之间的通信。在 <em>Internet</em> 上的主机一般运行了多个服务软件，同时提供几 种服务。每种服务都打开一个 <em>Socket</em>，并绑定到一个端口上，不同的端口对应于不同的服务。<em>Socket</em> 正如其英文原义那样，像一个多孔插座。一台主机犹如布满各种插座的房间，每个插 座有一个编号，有的插座提供 <em>220</em> 伏交流电， 有的提供 <em>110</em> 伏交流电，有的则提供有线电 视节目。 客户软件将插头插到不同编号的插座，就可以得到不同的服务。</p>
</blockquote>
</li>
<li><p><strong>Socket</strong> <strong>连接步骤</strong> </p>
<p>​        <em>根据连接启动的方式以及本地套接字要连接的目标，套接字之间的连接过程可以分为三个步骤：服务器监听，客户端请求，连接确认。【如果包含数据交互+断开连接，那么一共是 五个步骤】</em></p>
<ol>
<li>服务器监听：是服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态。 </li>
<li>客户端请求：是指由客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。 </li>
<li>连接确认(三层握手)：是指当服务器端套接字监听到或者说接收到客户端套接字的连接请求【1】，它就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户端【2】，一旦客户端确认了此描述，连接就建立好了【3】。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。</li>
<li>断开连接：客户端向服务发起一个请求关闭消息【1】，服务器根据自己状态，等到可以关闭时候，发一个可以关闭的消息给客户端【2】，并且服务器再向浏览器发一个关闭成功的消息【3】，客户端发一个光笔成功的消息，至于服务器可以收到不管【4】。</li>
</ol>
<p><img src="\media\握手和挥手.jpg" alt=""></p>
</li>
<li><p><strong>Java</strong> <strong>中的</strong> <strong>Socket</strong> </p>
<p>​        <em>在java.net包是网络编程的基础类库。其中ServerSocket和Socket是网络编程的基础类型ServerSocket是服务端应用类型。Socket是建立连接的类型。当连接建立成功后，服务器和客户端都会有一个 Socket对象示例，可以通过这个Socket 对象示例，完成会话的所有操作。</em></p>
<p>​        <em>对于一个完整的网络连接来说，Socket是平等的，没有服务器客户端分级情况</em></p>
</li>
<li><p><strong>什么是同步和异步</strong> </p>
<p>​        同步和异步是针对应用程序和内核OS的交互而言的，同步指的是用户进程触发 <em>IO</em> 操作并 等待或者轮询的去查看 <em>IO</em> 操作是否就绪，而异步是指用户进程触发 <em>IO</em> 操作以后便开始做自 己的事情，而当 <em>IO</em> 操作已经完成的时候会得到 <em>IO</em> 完成的通知，异步是OS底层支持的一种操作。以银行取款为例： </p>
<ul>
<li>同步 ： 自己亲自出马持银行卡到银行取钱（使用同步 <em>IO</em> 时，<em>Java</em> 自己处理 <em>IO</em> 读写）； </li>
<li>异步 ： 委托一小弟拿银行卡到银行取钱，然后给你（使用异步 <em>IO</em> 时，<em>Java</em> 将 <em>IO</em> 读写 委托给 <em>OS</em> 处理，需要将数据缓冲区地址和大小传给 <em>OS(</em>银行卡和密码<em>)</em>，<em>OS</em> 需要支持异步 <em>IO</em> 操作 <em>API</em>）</li>
</ul>
</li>
<li><p><strong>什么是阻塞和非阻塞</strong> </p>
<p>​        阻塞和非阻塞是针对于进程在访问数据的时候，根据 <em>IO</em> 操作的就绪状态来采取的不同 方式，说白了是一种读取或者写入操作方法的实现方式，阻塞方式下读取或者写入函数将一直等待，而非阻塞方式下，读取或者写入方法会立即返回一个状态值。 以银行取款为例： </p>
<ul>
<li>阻塞 ： <em>ATM</em> 排队取款，你只能等待（使用阻塞 <em>IO</em> 时，<em>Java</em> 调用会一直阻塞到读写完 成才返回）； </li>
<li>非阻塞 ： 柜台取款，取个号，然后坐在椅子上做其它事，等号广播会通知你办理，没到号你就不能去，你可以不断问大堂经理排到了没有，大堂经理如果说还没到你就不能去（使用非阻塞 <em>IO</em> 时，如果不能读写 <em>Java</em> 调用会马上返回，当 <em>IO</em> 事件分发器通知可读写时再继 续进行读写，不断循环直到读写完成）</li>
<li>ajax是异步阻塞的。</li>
</ul>
</li>
</ul>
<h3 id="合体中期（BIO、NIO-、AIO）"><a href="#合体中期（BIO、NIO-、AIO）" class="headerlink" title="合体中期（BIO、NIO 、AIO）"></a>合体中期（BIO、NIO 、AIO）</h3><ul>
<li><p><strong>BIO</strong> <strong>编程</strong> ：<em>Blocking IO</em>同步阻塞的编程方式。 </p>
<ul>
<li><em>BIO</em> 编程方式通常是在 <em>JDK1.4</em> 版本之前常用的编程方式。编程实现过程为：首先在服务端启动一个 <em>ServerSocket</em> 来监听网络请求，客户端启动 <em>Socket</em> 发起网络请求，默认情况下 <em>ServerSocket</em> 回建立一个线程来处理此请求，如果服务端没有线程可用，客户端则会阻塞等待或遭到拒绝。 且建立好的连接，在通讯过程中，是同步的。在并发处理效率上比较低。大致结构如下：</li>
</ul>
<p><img src="\media\BIO结构.jpg" alt=""></p>
<ul>
<li><p>每次请求都要创建一个server socket和一个thread</p>
</li>
<li><p>同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就 需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可 以通过线程池机制改善（有人把这种叫做伪异步，实际上不能实现任何的异步的操作，归根还是同步）。</p>
</li>
<li><p><em>BIO</em> 方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，<em>JDK1.4</em> 以前的唯一选择，但程序直观简单易理解。</p>
</li>
<li><p>使用线程池机制改善后的 <em>BIO</em> 模型图如下<em>:</em> </p>
<p> <img src="\media\BIO线程池结果图.jpg" alt=""></p>
</li>
</ul>
</li>
</ul>
<p>Client：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String host = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(args.length &gt; <span class="number">2</span>)&#123;</span><br><span class="line">            host = args[<span class="number">0</span>];</span><br><span class="line">            port = Integer.parseInt(args[<span class="number">1</span>]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            host = <span class="string">"127.0.0.1"</span>;</span><br><span class="line">            port = <span class="number">9999</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Socket socket = <span class="keyword">null</span>;</span><br><span class="line">        BufferedReader reader = <span class="keyword">null</span>;</span><br><span class="line">        PrintWriter writer = <span class="keyword">null</span>;</span><br><span class="line">        Scanner s = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            socket = <span class="keyword">new</span> Socket(host, port);</span><br><span class="line">            String message = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            reader = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                    <span class="keyword">new</span> InputStreamReader(socket.getInputStream(), <span class="string">"UTF-8"</span>));</span><br><span class="line">            writer = <span class="keyword">new</span> PrintWriter(</span><br><span class="line">                    socket.getOutputStream(), <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                message = s.nextLine();</span><br><span class="line">                <span class="keyword">if</span>(message.equals(<span class="string">"exit"</span>))&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                writer.println(message);</span><br><span class="line">                writer.flush();</span><br><span class="line">                System.out.println(reader.readLine());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(socket != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            socket = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span>(reader != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    reader.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            reader = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span>(writer != <span class="keyword">null</span>)&#123;</span><br><span class="line">                writer.close();</span><br><span class="line">            &#125;</span><br><span class="line">            writer = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>server</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> port = genPort(args);</span><br><span class="line"></span><br><span class="line">        ServerSocket server = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            server = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line">            System.out.println(<span class="string">"server started!"</span>);</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                Socket socket = server.accept();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">new</span> Thread(<span class="keyword">new</span> Handler(socket)).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(server != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    server.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            server = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        Socket socket = <span class="keyword">null</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Socket socket)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.socket = socket;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            BufferedReader reader = <span class="keyword">null</span>;</span><br><span class="line">            PrintWriter writer = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">                reader = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                        <span class="keyword">new</span> InputStreamReader(socket.getInputStream(), <span class="string">"UTF-8"</span>));</span><br><span class="line">                writer = <span class="keyword">new</span> PrintWriter(</span><br><span class="line">                        <span class="keyword">new</span> OutputStreamWriter(socket.getOutputStream(), <span class="string">"UTF-8"</span>));</span><br><span class="line">                String readMessage = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"server reading... "</span>);</span><br><span class="line">                    <span class="keyword">if</span>((readMessage = reader.readLine()) == <span class="keyword">null</span>)&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(readMessage);</span><br><span class="line">                    writer.println(<span class="string">"server recive : "</span> + readMessage);</span><br><span class="line">                    writer.flush();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(socket != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        socket.close();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                socket = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span>(reader != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        reader.close();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                reader = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span>(writer != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    writer.close();</span><br><span class="line">                &#125;</span><br><span class="line">                writer = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">genPort</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(args.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> Integer.parseInt(args[<span class="number">0</span>]);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(NumberFormatException e)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">9999</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">9999</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>ThreadPool版的Server</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> port = genPort(args);</span><br><span class="line"></span><br><span class="line">        ServerSocket server = <span class="keyword">null</span>;</span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            server = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line">            System.out.println(<span class="string">"server started!"</span>);</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                Socket socket = server.accept();</span><br><span class="line"></span><br><span class="line">                service.execute(<span class="keyword">new</span> Handler(socket));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(server != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    server.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            server = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        Socket socket = <span class="keyword">null</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Socket socket)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.socket = socket;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            BufferedReader reader = <span class="keyword">null</span>;</span><br><span class="line">            PrintWriter writer = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">                reader = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                        <span class="keyword">new</span> InputStreamReader(socket.getInputStream(), <span class="string">"UTF-8"</span>));</span><br><span class="line">                writer = <span class="keyword">new</span> PrintWriter(</span><br><span class="line">                        <span class="keyword">new</span> OutputStreamWriter(socket.getOutputStream(), <span class="string">"UTF-8"</span>));</span><br><span class="line">                String readMessage = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"server reading... "</span>);</span><br><span class="line">                    <span class="keyword">if</span>((readMessage = reader.readLine()) == <span class="keyword">null</span>)&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(readMessage);</span><br><span class="line">                    writer.println(<span class="string">"server recive : "</span> + readMessage);</span><br><span class="line">                    writer.flush();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(socket != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        socket.close();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                socket = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span>(reader != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        reader.close();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                reader = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span>(writer != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    writer.close();</span><br><span class="line">                &#125;</span><br><span class="line">                writer = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">genPort</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(args.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> Integer.parseInt(args[<span class="number">0</span>]);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(NumberFormatException e)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">9999</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">9999</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>NIO</strong> <strong>编程</strong> <em>Unblocking IO</em>（<em>New IO</em>）： 同步非阻塞的编程方式。 </p>
<ul>
<li><p><em>NIO</em> 本身是基于事件驱动思想来完成的，其主要想解决的是 <em>BIO</em> 的大并发问题，<em>NIO</em> 基于<em>Reactor</em>，当 <em>socket</em> 有流可读或可写入 <em>socket</em> 时，操作系统会相应的通知应用程序进行处理，应用再将流读取到缓冲区或写入操作系统。也就是说，这个时候，已经不是一个连接就要对应一个处理线程了，而是有效的请求，对应一个线程，当连接没有数据时，是没有工作线程来处理的（即一个线程对应多个有效请求）。</p>
</li>
<li><p><em>NIO</em> 的最重要的地方是当一个连接创建后，不需要对应一个线程，这个连接会被注册到多路复用器上面，所以所有的连接只需要一个线程就可以搞定，当这个线程中的多路复用器进行轮询的时候，发现连接上有请求的话，才开启一个线程进行处理，也就是一个请求一个线程模式，并且面向缓存。 </p>
</li>
<li><p>在 <em>NIO</em> 的处理方式中，当一个请求来的话，开启线程进行处理，可能会等待后端应用的资源<em>(JDBC</em> 连接等待<em>)</em>，其实这个线程就被阻塞了，当并发上来的话，还是会有 <em>BIO</em> 一样的问题。 </p>
<p><img src="\media\NIO.jpg" alt=""></p>
</li>
<li><p>同步非阻塞，服务器实现模式为一个请求一个通道，即客户端发送的连接请求都会注册 到多路复用器上，多路复用器轮询到连接有 <em>I/O</em> 请求时才启动一个线程进行处理。 </p>
</li>
<li><p><em>NIO</em> 方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局 限于应用中，编程复杂，<em>JDK1.4</em> 开始支持。 </p>
</li>
<li><p><strong><em>Buffer:ByteBuffer,CharBuffer,ShortBuffer,IntBuffer,LongBuffer,FloatBuffer,DoubleBuffer<em>*</em></em></strong>。<em>*</em></p>
</li>
<li><p><strong><em>Channel:SocketChannel,ServerSocketChannel<em>*</em></em></strong>。<em>*</em> </p>
</li>
<li><p><strong><em>Selector:Selector,AbstractSelector</em></strong> </p>
</li>
<li><p><strong><em>SelectionKey:OP_READ,OP_WRITE,OP_CONNECT,OP_ACCEPT</em></strong></p>
</li>
</ul>
</li>
</ul>
<p>client</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 远程地址创建</span></span><br><span class="line">        InetSocketAddress remote = <span class="keyword">new</span> InetSocketAddress(<span class="string">"localhost"</span>, <span class="number">9999</span>);</span><br><span class="line">        SocketChannel channel = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义缓存。</span></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 开启通道</span></span><br><span class="line">            channel = SocketChannel.open();</span><br><span class="line">            <span class="comment">// 连接远程服务器。</span></span><br><span class="line">            channel.connect(remote);</span><br><span class="line">            Scanner reader = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                System.out.print(<span class="string">"put message for send to server &gt; "</span>);</span><br><span class="line">                String line = reader.nextLine();</span><br><span class="line">                <span class="keyword">if</span>(line.equals(<span class="string">"exit"</span>))&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 将控制台输入的数据写入到缓存。</span></span><br><span class="line">                buffer.put(line.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">                <span class="comment">// 重置缓存游标</span></span><br><span class="line">                buffer.flip();</span><br><span class="line">                <span class="comment">// 将数据发送给服务器</span></span><br><span class="line">                channel.write(buffer);</span><br><span class="line">                <span class="comment">// 清空缓存数据。</span></span><br><span class="line">                buffer.clear();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 读取服务器返回的数据</span></span><br><span class="line">                <span class="keyword">int</span> readLength = channel.read(buffer);</span><br><span class="line">                <span class="keyword">if</span>(readLength == -<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 重置缓存游标</span></span><br><span class="line">                buffer.flip();</span><br><span class="line">                <span class="keyword">byte</span>[] datas = <span class="keyword">new</span> <span class="keyword">byte</span>[buffer.remaining()];</span><br><span class="line">                <span class="comment">// 读取数据到字节数组。</span></span><br><span class="line">                buffer.get(datas);</span><br><span class="line">                System.out.println(<span class="string">"from server : "</span> + <span class="keyword">new</span> String(datas, <span class="string">"UTF-8"</span>));</span><br><span class="line">                <span class="comment">// 清空缓存。</span></span><br><span class="line">                buffer.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">null</span> != channel)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    channel.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>server</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOServer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 多路复用器， 选择器。 用于注册通道的。</span></span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="comment">// 定义了两个缓存。分别用于读和写。 初始化空间大小单位为字节。</span></span><br><span class="line">    <span class="comment">// Buffer1是不安全的，要想安全模仿BIO，独立定义为Handler对象</span></span><br><span class="line">    <span class="keyword">private</span> ByteBuffer readBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">private</span> ByteBuffer writeBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> NIOServer(<span class="number">9999</span>)).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NIOServer</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        init(port);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> port)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"server starting at port "</span> + port + <span class="string">" ..."</span>);</span><br><span class="line">            <span class="comment">// 开启多路复用器</span></span><br><span class="line">            <span class="keyword">this</span>.selector = Selector.open();</span><br><span class="line">            <span class="comment">// 开启服务通道</span></span><br><span class="line">            ServerSocketChannel serverChannel = ServerSocketChannel.open();</span><br><span class="line">            <span class="comment">// 非阻塞， 如果传递参数true，为阻塞模式。</span></span><br><span class="line">            serverChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">// 绑定端口</span></span><br><span class="line">            serverChannel.bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line">            <span class="comment">// 注册，并标记当前服务通道状态</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * register(Selector, int)</span></span><br><span class="line"><span class="comment">             * int - 状态编码</span></span><br><span class="line"><span class="comment">             *  OP_ACCEPT ： 连接成功的标记位。</span></span><br><span class="line"><span class="comment">             *  OP_READ ： 可以读取数据的标记</span></span><br><span class="line"><span class="comment">             *  OP_WRITE ： 可以写入数据的标记</span></span><br><span class="line"><span class="comment">             *  OP_CONNECT ： 连接建立后的标记</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            serverChannel.register(<span class="keyword">this</span>.selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">            System.out.println(<span class="string">"server started."</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 阻塞方法，当至少一个通道被选中，此方法返回。</span></span><br><span class="line">                <span class="comment">// 通道是否选择，由注册到多路复用器中的通道标记决定。</span></span><br><span class="line">                <span class="keyword">this</span>.selector.select();</span><br><span class="line">                <span class="comment">// 返回以选中的通道标记集合， 集合中保存的是通道的标记。相当于是通道的ID。</span></span><br><span class="line">                Iterator&lt;SelectionKey&gt; keys = <span class="keyword">this</span>.selector.selectedKeys().iterator();</span><br><span class="line">                <span class="keyword">while</span>(keys.hasNext())&#123;</span><br><span class="line">                    SelectionKey key = keys.next();</span><br><span class="line">                    <span class="comment">// 将本次要处理的通道从集合中删除，下次循环根据新的通道列表再次执行必要的业务逻辑</span></span><br><span class="line">                    keys.remove();</span><br><span class="line">                    <span class="comment">// 通道是否有效</span></span><br><span class="line">                    <span class="keyword">if</span>(key.isValid())&#123;</span><br><span class="line">                        <span class="comment">// 阻塞状态</span></span><br><span class="line">                        <span class="keyword">try</span>&#123;</span><br><span class="line">                            <span class="keyword">if</span>(key.isAcceptable())&#123;</span><br><span class="line">                                accept(key);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;<span class="keyword">catch</span>(CancelledKeyException cke)&#123;</span><br><span class="line">                            <span class="comment">// 断开连接。 出现异常。</span></span><br><span class="line">                            key.cancel();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 可读状态</span></span><br><span class="line">                        <span class="keyword">try</span>&#123;</span><br><span class="line">                            <span class="keyword">if</span>(key.isReadable())&#123;</span><br><span class="line">                                read(key);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;<span class="keyword">catch</span>(CancelledKeyException cke)&#123;</span><br><span class="line">                            key.cancel();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 可写状态</span></span><br><span class="line">                        <span class="keyword">try</span>&#123;</span><br><span class="line">                            <span class="keyword">if</span>(key.isWritable())&#123;</span><br><span class="line">                                write(key);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;<span class="keyword">catch</span>(CancelledKeyException cke)&#123;</span><br><span class="line">                            key.cancel();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(SelectionKey key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.writeBuffer.clear();</span><br><span class="line">        SocketChannel channel = (SocketChannel)key.channel();</span><br><span class="line">        Scanner reader = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.print(<span class="string">"put message for send to client &gt; "</span>);</span><br><span class="line">            String line = reader.nextLine();</span><br><span class="line">            <span class="comment">// 将控制台输入的字符串写入Buffer中。 写入的数据是一个字节数组。</span></span><br><span class="line">            writeBuffer.put(line.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">            writeBuffer.flip();</span><br><span class="line">            channel.write(writeBuffer);</span><br><span class="line"></span><br><span class="line">            channel.register(<span class="keyword">this</span>.selector, SelectionKey.OP_READ);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(SelectionKey key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 清空读缓存。</span></span><br><span class="line">            <span class="keyword">this</span>.readBuffer.clear();</span><br><span class="line">            <span class="comment">// 获取通道</span></span><br><span class="line">            SocketChannel channel = (SocketChannel)key.channel();</span><br><span class="line">            <span class="comment">// 将通道中的数据读取到缓存中。通道中的数据，就是客户端发送给服务器的数据。</span></span><br><span class="line">            <span class="keyword">int</span> readLength = channel.read(readBuffer);</span><br><span class="line">            <span class="comment">// 检查客户端是否写入数据。</span></span><br><span class="line">            <span class="keyword">if</span>(readLength == -<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">// 关闭通道</span></span><br><span class="line">                key.channel().close();</span><br><span class="line">                <span class="comment">// 关闭连接</span></span><br><span class="line">                key.cancel();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * flip， NIO中最复杂的操作就是Buffer的控制。</span></span><br><span class="line"><span class="comment">             * Buffer中有一个游标。游标信息在操作后不会归零，如果直接访问Buffer的话，数据有不一致的可能。</span></span><br><span class="line"><span class="comment">             * flip是重置游标的方法。NIO编程中，flip方法是常用方法。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">this</span>.readBuffer.flip();</span><br><span class="line">            <span class="comment">// 字节数组，保存具体数据的。 Buffer.remaining() -&gt; 是获取Buffer中有效数据长度的方法。</span></span><br><span class="line">            <span class="keyword">byte</span>[] datas = <span class="keyword">new</span> <span class="keyword">byte</span>[readBuffer.remaining()];</span><br><span class="line">            <span class="comment">// 是将Buffer中的有效数据保存到字节数组中。</span></span><br><span class="line">            readBuffer.get(datas);</span><br><span class="line">            System.out.println(<span class="string">"from "</span> + channel.getRemoteAddress() + <span class="string">" client : "</span> + <span class="keyword">new</span> String(datas, <span class="string">"UTF-8"</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 注册通道， 标记为写操作。</span></span><br><span class="line">            channel.register(<span class="keyword">this</span>.selector, SelectionKey.OP_WRITE);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                key.channel().close();</span><br><span class="line">                key.cancel();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e1) &#123;</span><br><span class="line">                e1.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(SelectionKey key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 此通道为init方法中注册到Selector上的ServerSocketChannel</span></span><br><span class="line">            ServerSocketChannel serverChannel = (ServerSocketChannel)key.channel();</span><br><span class="line">            <span class="comment">// 阻塞方法，当客户端发起请求后返回。 此通道和客户端一一对应。</span></span><br><span class="line">            SocketChannel channel = serverChannel.accept();</span><br><span class="line">            channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">// 设置对应客户端的通道标记状态，此通道为读取数据使用的。</span></span><br><span class="line">            channel.register(<span class="keyword">this</span>.selector, SelectionKey.OP_READ);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TestBuffer</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Buffer的应用固定逻辑</span></span><br><span class="line"><span class="comment"> * 写操作顺序</span></span><br><span class="line"><span class="comment"> * 1. clear()</span></span><br><span class="line"><span class="comment"> * 2. put() -&gt; 写操作</span></span><br><span class="line"><span class="comment"> * 3. flip() -&gt; 重置游标</span></span><br><span class="line"><span class="comment"> * 4. SocketChannel.write(buffer); -&gt; 将缓存数据发送到网络的另一端</span></span><br><span class="line"><span class="comment"> * 5. clear()</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 读操作顺序</span></span><br><span class="line"><span class="comment"> * 1. clear()</span></span><br><span class="line"><span class="comment"> * 2. SocketChannel.read(buffer); -&gt; 从网络中读取数据</span></span><br><span class="line"><span class="comment"> * 3. buffer.flip() -&gt; 重置游标</span></span><br><span class="line"><span class="comment"> * 4. buffer.get() -&gt; 读取数据</span></span><br><span class="line"><span class="comment"> * 5. buffer.clear()</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBuffer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] temp = <span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写入数据之前 ： java.nio.HeapByteBuffer[pos=0 lim=8 cap=8]</span></span><br><span class="line">        <span class="comment">// pos - 游标位置， lim - 限制数量， cap - 最大容量</span></span><br><span class="line">        System.out.println(<span class="string">"写入数据之前 ： "</span> + buffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写入字节数组到缓存</span></span><br><span class="line">        buffer.put(temp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写入数据之后 ： java.nio.HeapByteBuffer[pos=3 lim=8 cap=8]</span></span><br><span class="line">        <span class="comment">// 游标为3， 限制为8， 容量为8，默认限制与容量一样大小</span></span><br><span class="line">        System.out.println(<span class="string">"写入数据之后 ： "</span> + buffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重置游标 ， lim = pos ;  pos = 0;</span></span><br><span class="line">        buffer.flip();<span class="comment">//把这行注释掉后，下面的循环就是5次了。</span></span><br><span class="line">        <span class="comment">//在重置一次，pos为0，lim（可读写操作有效数据位数）为0，get会报错，也不让写。要写要clear</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重置游标之后 ： java.nio.HeapByteBuffer[pos=0 lim=3 cap=8]</span></span><br><span class="line">        <span class="comment">// 游标为0， 限制为3， </span></span><br><span class="line">        System.out.println(<span class="string">"重置游标之后 ： "</span> + buffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 清空Buffer， pos = 0; lim = cap;</span></span><br><span class="line">        <span class="comment">// buffer.clear();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// get() -&gt; 获取当前游标指向的位置的数据。</span></span><br><span class="line">        <span class="comment">// System.out.println(buffer.get());</span></span><br><span class="line">        <span class="comment">// remaining是lim-pos</span></span><br><span class="line">        <span class="comment">/*for(int i = 0; i &lt; buffer.remaining(); i++)&#123;</span></span><br><span class="line"><span class="comment">            // get(int index) -&gt; 获取指定位置的数据。</span></span><br><span class="line"><span class="comment">            int data = buffer.get(i);</span></span><br><span class="line"><span class="comment">            System.out.println(i + " - " + data);</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>AIO</strong> <strong>编程</strong> <em>AsynchronousIO</em>： 异步非阻塞的编程方式 <ul>
<li>与 <em>NIO</em> 不同，当进行读写操作时，只须直接调用 <em>API</em> 的 <em>read</em> 或 <em>write</em> 方法即可。这两种 方法均为异步的，对于读操作而言，当有流可读取时，操作系统会将可读的流传入 <em>read</em> 方 法的缓冲区，并通知应用程序；对于写操作而言，当操作系统将 <em>write</em> 方法传递的流写入完 毕时，操作系统主动通知应用程序。即可以理解为，<em>read/write</em> 方法都是异步的，完成后会 主动调用回调函数。</li>
<li>客户端向服务端发数据，首先是OS接收到，他会将数据写到buffer里，然后通知应用程序代码，数据已经准备好了，可以read拿走了。应用代码write时，也会不数据同步进入OS的Buffer里，通过反向通知告诉应用程序已经写完了。buffer数据会自动地反回给client。client与server交互借助OS实现异步操作。</li>
<li>在 <em>JDK1.7</em> 中，这部分内容被称作 <em>NIO.2</em>，主要在 <em>java.nio.channels</em> 包下增加了下面四个异步通道： <ul>
<li><em>AsynchronousSocketChannel</em> </li>
<li><em>AsynchronousServerSocketChannel</em></li>
<li><em>AsynchronousFileChannel</em> </li>
<li><em>AsynchronousDatagramChannel</em> </li>
</ul>
</li>
<li>异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的 <em>I/O</em> 请求都是由 <em>OS</em> 先完成了再通知服务器应用去启动线程进行处理。 </li>
<li><em>AIO</em> 方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调 用 <em>OS</em> 参与并发操作，编程比较复杂，<em>JDK7</em> 开始支持。 </li>
</ul>
</li>
</ul>
<p><img src="\media\AIO执行流程图.jpg" alt=""></p>
<p>server</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AIOServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程池， 提高服务端效率。</span></span><br><span class="line">    <span class="keyword">private</span> ExecutorService service;</span><br><span class="line">    <span class="comment">// 线程组</span></span><br><span class="line">    <span class="comment">// private AsynchronousChannelGroup group;</span></span><br><span class="line">    <span class="comment">// 服务端通道， 针对服务器端定义的通道。</span></span><br><span class="line">    <span class="keyword">private</span> AsynchronousServerSocketChannel serverChannel;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AIOServer</span><span class="params">(<span class="keyword">int</span> port)</span></span>&#123;</span><br><span class="line">        init(<span class="number">9999</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> port)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"server starting at port : "</span> + port + <span class="string">" ..."</span>);</span><br><span class="line">            <span class="comment">// 定长线程池</span></span><br><span class="line">            service = Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line">            <span class="comment">/* 使用线程组</span></span><br><span class="line"><span class="comment">            group = AsynchronousChannelGroup.withThreadPool(service);</span></span><br><span class="line"><span class="comment">            serverChannel = AsynchronousServerSocketChannel.open(group);</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="comment">// 开启服务端通道， 通过静态方法创建的。</span></span><br><span class="line">            serverChannel = AsynchronousServerSocketChannel.open();</span><br><span class="line">            <span class="comment">// 绑定监听端口， 服务器启动成功，但是未监听请求。</span></span><br><span class="line">            serverChannel.bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line">            System.out.println(<span class="string">"server started."</span>);</span><br><span class="line">            <span class="comment">// 开始监听 </span></span><br><span class="line">            <span class="comment">// accept(T attachment, CompletionHandler&lt;AsynchronousSocketChannel, ? super T&gt;)</span></span><br><span class="line">            <span class="comment">// AIO开发中，监听是一个类似递归的监听操作。每次监听到客户端请求后，都需要处理逻辑开启下一次的监听。</span></span><br><span class="line">            <span class="comment">// 下一次的监听，需要服务器的资源继续支持。this传递到AIOServerHandler的completed方法中</span></span><br><span class="line">            serverChannel.accept(<span class="keyword">this</span>, <span class="keyword">new</span> AIOServerHandler());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(Integer.MAX_VALUE);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> AIOServer(<span class="number">9999</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ExecutorService <span class="title">getService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> service;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setService</span><span class="params">(ExecutorService service)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.service = service;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AsynchronousServerSocketChannel <span class="title">getServerChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> serverChannel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setServerChannel</span><span class="params">(AsynchronousServerSocketChannel serverChannel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.serverChannel = serverChannel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AIOServerHandler</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AIOServerHandler</span> <span class="keyword">implements</span> <span class="title">CompletionHandler</span>&lt;<span class="title">AsynchronousSocketChannel</span>, <span class="title">AIOServer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 业务处理逻辑， 当请求到来后，监听成功，应该做什么。</span></span><br><span class="line"><span class="comment">     * 一定要实现的逻辑： 为下一次客户端请求开启监听。accept方法调用。</span></span><br><span class="line"><span class="comment">     * result参数 ： 就是和客户端直接建立关联的通道。</span></span><br><span class="line"><span class="comment">     *  无论BIO、NIO、AIO中，一旦连接建立，两端是平等的。</span></span><br><span class="line"><span class="comment">     *  result中有通道中的所有相关数据。如：OS操作系统准备好的读取数据缓存，或等待返回数据的缓存。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(AsynchronousSocketChannel result, AIOServer attachment)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 处理下一次的客户端请求。类似递归逻辑。</span></span><br><span class="line">        attachment.getServerChannel().accept(attachment, <span class="keyword">this</span>);</span><br><span class="line">        doRead(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异常处理逻辑， 当服务端代码出现异常的时候，做什么事情。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, AIOServer attachment)</span> </span>&#123;</span><br><span class="line">        exc.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 真实项目中，服务器返回的结果应该是根据客户端的请求数据计算得到的。不是等待控制台输入的。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doWrite</span><span class="params">(AsynchronousSocketChannel result)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            System.out.print(<span class="string">"enter message send to client &gt; "</span>);</span><br><span class="line">            Scanner s = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">            String line = s.nextLine();</span><br><span class="line">            buffer.put(line.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">            <span class="comment">// 重点：必须复位，必须复位，必须复位</span></span><br><span class="line">            buffer.flip();</span><br><span class="line">            <span class="comment">// write方法是一个异步操作。具体实现由OS实现。 可以增加get方法，实现阻塞，等待OS的写操作结束。</span></span><br><span class="line">            result.write(buffer);</span><br><span class="line">            <span class="comment">// result.write(buffer).get(); // 调用get代表服务端线程阻塞，等待写操作完成</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="comment">/* catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">            e.printStackTrace();</span></span><br><span class="line"><span class="comment">        &#125; catch (ExecutionException e) &#123;</span></span><br><span class="line"><span class="comment">            e.printStackTrace();</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doRead</span><span class="params">(<span class="keyword">final</span> AsynchronousSocketChannel channel)</span></span>&#123;</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 异步读操作， read(Buffer destination, A attachment, </span></span><br><span class="line"><span class="comment">         *                    CompletionHandler&lt;Integer, ? super A&gt; handler)</span></span><br><span class="line"><span class="comment">         * destination - 目的地， 是处理客户端传递数据的中转缓存。 可以不使用。</span></span><br><span class="line"><span class="comment">         * attachment - 处理客户端传递数据的对象。 通常使用Buffer处理。</span></span><br><span class="line"><span class="comment">         * handler - 处理逻辑</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.read(buffer, buffer, <span class="keyword">new</span> CompletionHandler&lt;Integer, ByteBuffer&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 业务逻辑，读取客户端传输数据</span></span><br><span class="line"><span class="comment">             * attachment - 在completed方法执行的时候，OS已经将客户端请求的数据写入到Buffer中了。</span></span><br><span class="line"><span class="comment">             *  但是未复位（flip）。 使用前一定要复位。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Integer result, ByteBuffer attachment)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(attachment.capacity());</span><br><span class="line">                    <span class="comment">// 复位</span></span><br><span class="line">                    attachment.flip();</span><br><span class="line">                    System.out.println(<span class="string">"from client : "</span> + <span class="keyword">new</span> String(attachment.array(), <span class="string">"UTF-8"</span>));</span><br><span class="line">                    doWrite(channel);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, ByteBuffer attachment)</span> </span>&#123;</span><br><span class="line">                exc.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>client</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AIOClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AsynchronousSocketChannel channel;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AIOClient</span><span class="params">(String host, <span class="keyword">int</span> port)</span></span>&#123;</span><br><span class="line">        init(host, port);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(String host, <span class="keyword">int</span> port)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 开启通道</span></span><br><span class="line">            channel = AsynchronousSocketChannel.open();</span><br><span class="line">            <span class="comment">// 发起请求，建立连接。</span></span><br><span class="line">            channel.connect(<span class="keyword">new</span> InetSocketAddress(host, port));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String line)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            buffer.put(line.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">            buffer.flip();</span><br><span class="line">            channel.write(buffer);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// read方法是异步方法，OS实现的。get方法是一个阻塞方法，会等待OS处理结束后再返回，要不代码不等待，下面没数据打印出来。真实开发可以不加，其结果依靠OS自己去等待，拿到数据再返回通知，</span></span><br><span class="line">            channel.read(buffer).get();</span><br><span class="line">            <span class="comment">// channel.read(dst, attachment, handler);</span></span><br><span class="line">            buffer.flip();</span><br><span class="line">            System.out.println(<span class="string">"from server : "</span> + <span class="keyword">new</span> String(buffer.array(), <span class="string">"UTF-8"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doDestory</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> != channel)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                channel.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AIOClient client = <span class="keyword">new</span> AIOClient(<span class="string">"localhost"</span>, <span class="number">9999</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.print(<span class="string">"enter message send to server &gt; "</span>);</span><br><span class="line">            Scanner s = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">            String line = s.nextLine();</span><br><span class="line">            client.write(line);</span><br><span class="line">            client.read();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            client.doDestory();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="合体后期（Netty）"><a href="#合体后期（Netty）" class="headerlink" title="合体后期（Netty）"></a>合体后期（Netty）</h3><ul>
<li><p><strong>简介</strong> </p>
<p>​        <em>Netty</em> 是由 <em>JBOSS</em> 提供的一个 <em>java</em> 开源框架。<em>Netty</em> 提供异步的、事件驱动的网络应用 程序框架和工具，用以快速开发高性能、高可靠性的网络服务器和客户端程序。 它是建立再NIO和AIO基础之上的。</p>
<p>​        也就是说，<em>Netty</em> 是一个基于 <em>NIO</em> 的客户、服务器端编程框架，使用 <em>Netty</em> 可以确保你 快速和简单的开发出一个网络应用，例如实现了某种协议的客户，服务端应用。<em>Netty</em> 相当 简化和流线化了网络应用的编程开发过程，例如，<em>TCP</em> 和 <em>UDP</em> 的 <em>socket</em> 服务开发。</p>
<p>​        “<em>快速</em>”<em>和</em>“<em>简单</em>”<em>并不用产生维护性或性能上的问题。</em>Netty<em> 是一个吸收了多种协议的实 现经验，这些协议包括 </em>FTP,SMTP,HTTP<em>，各种二进制，文本协议，并经过相当精心设计的项 目，最终，</em>Netty* 成功的找到了一种方式，在保证易于开发的同时还保证了其应用的性能， 稳定性和伸缩性。 </p>
<p>​        <em>Netty</em> 从 <em>4.x</em> 版本开始，需要使用 <em>JDK1.6</em> 及以上版本提供基础支撑。 </p>
<p>​        在设计上：针对多种传输类型的统一接口 <em>-</em> 阻塞和非阻塞；简单但更强大的线程模型； 真正的无连接的数据报套接字支持；链接逻辑支持复用； </p>
<p>​        在性能上：比核心 <em>Java API</em> 更好的吞吐量，较低的延时；资源消耗更少，这个得益于 共享池和重用；减少内存拷贝 </p>
<p>​        在健壮性上：消除由于慢，快，或重载连接产生的 <em>OutOfMemoryError</em>；消除经常发现 在 <em>NIO</em> 在高速网络中的应用中的不公平的读<em>/</em>写比 </p>
<p>​        在安全上：完整的 <em>SSL / TLS</em> 和 <em>StartTLS</em> 的支持 </p>
<p>​        且已得到大量商业应用的真实验证<em>,</em>如：<em>Hadoop</em> 项目的 <em>Avro</em>（<em>RPC</em> 框架）、<em>Dubbo</em>、<em>Dubbox</em>等 <em>RPC</em> 框架。 </p>
<p>​        <em>Netty</em> 的官网是：<em><span class="exturl" data-url="aHR0cDovL25ldHR5Lmlv" title="http://netty.io">http://netty.io<i class="fa fa-external-link"></i></span></em> </p>
<p>​        有 三 方 提 供 的 中 文 翻 译 <em>Netty</em> 用 户 手 册 （ 官 网 提 供 源 信 息 ）： <em><span class="exturl" data-url="aHR0cDovL2lmZXZlLmNvbS9uZXR0eTUtdXNlci1ndWlkZS8=" title="http://ifeve.com/netty5-user-guide/">http://ifeve.com/netty5-user-guide/<i class="fa fa-external-link"></i></span></em></p>
</li>
<li><p><strong>Netty</strong> <strong>架构</strong></p>
<p><img src="\media\Netty架构.jpg" alt=""></p>
</li>
<li><p>线程模型（acceptor是一个监听线程）</p>
<p><img src="\media\1582184953(1" alt="">.jpg)</p>
<ul>
<li><p><strong>单线程模型</strong> </p>
<p>​        在 <em>ServerBootstrap</em> 调用方法 <em>group</em> 的时候，传递的参数是同一个线程组，且在构造线程 组的时候，构造参数为 <em>1</em>，这种开发方式，就是一个单线程模型。 个人机开发测试使用。不推荐。</p>
<p>​        在处理acceptor和runnable task的线程组合并成一个，并且只有一个线程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 初始化线程组,构建线程组的时候，如果不传递参数，则默认构建的线程组线程数是CPU核心数量。</span><br><span class="line">acceptorGroup = new NioEventLoopGroup(1);</span><br><span class="line">// 初始化服务的配置</span><br><span class="line">bootstrap = new ServerBootstrap();</span><br><span class="line">// 绑定线程组</span><br><span class="line">bootstrap.group(acceptorGroup, acceptorGroup);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>多线程模型</strong> </p>
<p>​        在 <em>ServerBootstrap</em> 调用方法 <em>group</em> 的时候，传递的参数是两个不同的线程组。负责监听 的 <em>acceptor</em> 线程组，线程数为 <em>1</em>，也就是构造参数为 <em>1</em>。负责处理客户端任务的线程组，线 程数大于 <em>1</em>，也就是构造参数大于 <em>1</em>。这种开发方式，就是多线程模型。 </p>
<p>​        长连接，且客户端数量较少，连接持续时间较长情况下使用。如：企业内部交流应用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 初始化线程组,构建线程组的时候，如果不传递参数，则默认构建的线程组线程数是CPU核心数量。</span><br><span class="line">acceptorGroup = new NioEventLoopGroup(1);</span><br><span class="line">clientGroup = new NioEventLoopGroup(&gt;1);</span><br><span class="line">// 初始化服务的配置</span><br><span class="line">bootstrap = new ServerBootstrap();</span><br><span class="line">// 绑定线程组</span><br><span class="line">bootstrap.group(acceptorGroup, clientGroup);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>主从多线程模型</strong> </p>
<p>​        在 <em>ServerBootstrap</em> 调用方法 <em>group</em> 的时候，传递的参数是两个不同的线程组。负责监听 的 <em>acceptor</em> 线程组，线程数大于 <em>1</em>，也就是构造参数大于 <em>1</em>。负责处理客户端任务的线程组， 线程数大于 <em>1</em>，也就是构造参数大于 <em>1</em>。这种开发方式，就是主从多线程模型。 </p>
<p>​        长连接，客户端数量相对较多，连接持续时间比较长的情况下使用。如：对外提供服务 </p>
<p>的相册服务器。 </p>
</li>
</ul>
<p>案例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.netty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>netty-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.0.Alpha2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;version&gt;4.1.24.Final&lt;/version&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.netty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>netty-codec-http<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.0.Alpha2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;version&gt;4.1.24.Final&lt;/version&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 接收处理工具 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jboss.marshalling<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jboss-marshalling-river<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.11.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 序列化处理工具 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jboss.marshalling<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jboss-marshalling-serial<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.11.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 系统信息收集 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hyperic.sigar<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>com.springsource.org.hyperic.sigar<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.kaazing<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sigar.dist<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">classifier</span>&gt;</span>distribution<span class="tag">&lt;/<span class="name">classifier</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">type</span>&gt;</span>zip<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>工具类</p>
<p>GzipUtils</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GzipUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"D:\\3\\1.jpg"</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] temp = <span class="keyword">new</span> <span class="keyword">byte</span>[fis.available()];</span><br><span class="line">        <span class="keyword">int</span> length = fis.read(temp);</span><br><span class="line">        System.out.println(<span class="string">"长度 : "</span> + length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] zipArray = GzipUtils.zip(temp);</span><br><span class="line">        System.out.println(<span class="string">"压缩后的长度 : "</span> + zipArray.length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] unzipArray = GzipUtils.unzip(zipArray);</span><br><span class="line">        System.out.println(<span class="string">"解压缩后的长度 : "</span> + unzipArray.length);</span><br><span class="line"></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"D:\\3\\101.jpg"</span>);</span><br><span class="line">        fos.write(unzipArray);</span><br><span class="line">        fos.flush();</span><br><span class="line"></span><br><span class="line">        fos.close();</span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解压缩</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> source 源数据。需要解压的数据。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 解压后的数据。 恢复的数据。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] unzip(<span class="keyword">byte</span>[] source) <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        ByteArrayOutputStream out = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ByteArrayInputStream in = <span class="keyword">new</span> ByteArrayInputStream(source);</span><br><span class="line">        <span class="comment">// JDK提供的。 专门用于压缩使用的流对象。可以处理字节数组数据。</span></span><br><span class="line">        GZIPInputStream zipIn = <span class="keyword">new</span> GZIPInputStream(in);</span><br><span class="line">        <span class="keyword">byte</span>[] temp = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((length = zipIn.read(temp, <span class="number">0</span>, temp.length)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            out.write(temp, <span class="number">0</span>, length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将字节数组输出流中的数据，转换为一个字节数组。</span></span><br><span class="line">        <span class="keyword">byte</span>[] target = out.toByteArray();</span><br><span class="line"></span><br><span class="line">        zipIn.close();</span><br><span class="line">        out.close();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 压缩</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> source 源数据，需要压缩的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 压缩后的数据。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] zip(<span class="keyword">byte</span>[] source) <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        ByteArrayOutputStream out = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        <span class="comment">// 输出流，JDK提供的，提供解压缩功能。</span></span><br><span class="line">        GZIPOutputStream zipOut = <span class="keyword">new</span> GZIPOutputStream(out);</span><br><span class="line">        <span class="comment">// 将压缩信息写入到内存。 写入的过程会实现解压。</span></span><br><span class="line">        zipOut.write(source);</span><br><span class="line">        <span class="comment">// 结束。</span></span><br><span class="line">        zipOut.finish();</span><br><span class="line">        <span class="keyword">byte</span>[] target = out.toByteArray();</span><br><span class="line"></span><br><span class="line">        zipOut.close();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OSUtils</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OSUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// System信息，从jvm获取</span></span><br><span class="line">            property();</span><br><span class="line">            System.out.println(<span class="string">"----------------------------------"</span>);</span><br><span class="line">            <span class="comment">// cpu信息</span></span><br><span class="line">            cpu();</span><br><span class="line">            System.out.println(<span class="string">"----------------------------------"</span>);</span><br><span class="line">            <span class="comment">// 内存信息</span></span><br><span class="line">            memory();</span><br><span class="line">            System.out.println(<span class="string">"----------------------------------"</span>);</span><br><span class="line">            <span class="comment">// 操作系统信息</span></span><br><span class="line">            os();</span><br><span class="line">            System.out.println(<span class="string">"----------------------------------"</span>);</span><br><span class="line">            <span class="comment">// 用户信息</span></span><br><span class="line">            who();</span><br><span class="line">            System.out.println(<span class="string">"----------------------------------"</span>);</span><br><span class="line">            <span class="comment">// 文件系统信息</span></span><br><span class="line">            file();</span><br><span class="line">            System.out.println(<span class="string">"----------------------------------"</span>);</span><br><span class="line">            <span class="comment">// 网络信息</span></span><br><span class="line">            net();</span><br><span class="line">            System.out.println(<span class="string">"----------------------------------"</span>);</span><br><span class="line">            <span class="comment">// 以太网信息</span></span><br><span class="line">            ethernet();</span><br><span class="line">            System.out.println(<span class="string">"----------------------------------"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e1) &#123;</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">property</span><span class="params">()</span> <span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line">        Runtime r = Runtime.getRuntime();</span><br><span class="line">        Properties props = System.getProperties();</span><br><span class="line">        InetAddress addr;</span><br><span class="line">        addr = InetAddress.getLocalHost();</span><br><span class="line">        String ip = addr.getHostAddress();</span><br><span class="line">        Map&lt;String, String&gt; map = System.getenv();</span><br><span class="line">        String userName = map.get(<span class="string">"USERNAME"</span>);<span class="comment">// 获取用户名</span></span><br><span class="line">        String computerName = map.get(<span class="string">"COMPUTERNAME"</span>);<span class="comment">// 获取计算机名</span></span><br><span class="line">        String userDomain = map.get(<span class="string">"USERDOMAIN"</span>);<span class="comment">// 获取计算机域名</span></span><br><span class="line">        System.out.println(<span class="string">"用户名:    "</span> + userName);</span><br><span class="line">        System.out.println(<span class="string">"计算机名:    "</span> + computerName);</span><br><span class="line">        System.out.println(<span class="string">"计算机域名:    "</span> + userDomain);</span><br><span class="line">        System.out.println(<span class="string">"本地ip地址:    "</span> + ip);</span><br><span class="line">        System.out.println(<span class="string">"本地主机名:    "</span> + addr.getHostName());</span><br><span class="line">        System.out.println(<span class="string">"JVM可以使用的总内存:    "</span> + r.totalMemory());</span><br><span class="line">        System.out.println(<span class="string">"JVM可以使用的剩余内存:    "</span> + r.freeMemory());</span><br><span class="line">        System.out.println(<span class="string">"JVM可以使用的处理器个数:    "</span> + r.availableProcessors());</span><br><span class="line">        System.out.println(<span class="string">"Java的运行环境版本：    "</span> + props.getProperty(<span class="string">"java.version"</span>));</span><br><span class="line">        System.out.println(<span class="string">"Java的运行环境供应商：    "</span> + props.getProperty(<span class="string">"java.vendor"</span>));</span><br><span class="line">        System.out.println(<span class="string">"Java供应商的URL：    "</span> + props.getProperty(<span class="string">"java.vendor.url"</span>));</span><br><span class="line">        System.out.println(<span class="string">"Java的安装路径：    "</span> + props.getProperty(<span class="string">"java.home"</span>));</span><br><span class="line">        System.out.println(<span class="string">"Java的虚拟机规范版本：    "</span> + props.getProperty(<span class="string">"java.vm.specification.version"</span>));</span><br><span class="line">        System.out.println(<span class="string">"Java的虚拟机规范供应商：    "</span> + props.getProperty(<span class="string">"java.vm.specification.vendor"</span>));</span><br><span class="line">        System.out.println(<span class="string">"Java的虚拟机规范名称：    "</span> + props.getProperty(<span class="string">"java.vm.specification.name"</span>));</span><br><span class="line">        System.out.println(<span class="string">"Java的虚拟机实现版本：    "</span> + props.getProperty(<span class="string">"java.vm.version"</span>));</span><br><span class="line">        System.out.println(<span class="string">"Java的虚拟机实现供应商：    "</span> + props.getProperty(<span class="string">"java.vm.vendor"</span>));</span><br><span class="line">        System.out.println(<span class="string">"Java的虚拟机实现名称：    "</span> + props.getProperty(<span class="string">"java.vm.name"</span>));</span><br><span class="line">        System.out.println(<span class="string">"Java运行时环境规范版本：    "</span> + props.getProperty(<span class="string">"java.specification.version"</span>));</span><br><span class="line">        System.out.println(<span class="string">"Java运行时环境规范供应商：    "</span> + props.getProperty(<span class="string">"java.specification.vender"</span>));</span><br><span class="line">        System.out.println(<span class="string">"Java运行时环境规范名称：    "</span> + props.getProperty(<span class="string">"java.specification.name"</span>));</span><br><span class="line">        System.out.println(<span class="string">"Java的类格式版本号：    "</span> + props.getProperty(<span class="string">"java.class.version"</span>));</span><br><span class="line">        System.out.println(<span class="string">"Java的类路径：    "</span> + props.getProperty(<span class="string">"java.class.path"</span>));</span><br><span class="line">        System.out.println(<span class="string">"加载库时搜索的路径列表：    "</span> + props.getProperty(<span class="string">"java.library.path"</span>));</span><br><span class="line">        System.out.println(<span class="string">"默认的临时文件路径：    "</span> + props.getProperty(<span class="string">"java.io.tmpdir"</span>));</span><br><span class="line">        System.out.println(<span class="string">"一个或多个扩展目录的路径：    "</span> + props.getProperty(<span class="string">"java.ext.dirs"</span>));</span><br><span class="line">        System.out.println(<span class="string">"操作系统的名称：    "</span> + props.getProperty(<span class="string">"os.name"</span>));</span><br><span class="line">        System.out.println(<span class="string">"操作系统的构架：    "</span> + props.getProperty(<span class="string">"os.arch"</span>));</span><br><span class="line">        System.out.println(<span class="string">"操作系统的版本：    "</span> + props.getProperty(<span class="string">"os.version"</span>));</span><br><span class="line">        System.out.println(<span class="string">"文件分隔符：    "</span> + props.getProperty(<span class="string">"file.separator"</span>));</span><br><span class="line">        System.out.println(<span class="string">"路径分隔符：    "</span> + props.getProperty(<span class="string">"path.separator"</span>));</span><br><span class="line">        System.out.println(<span class="string">"行分隔符：    "</span> + props.getProperty(<span class="string">"line.separator"</span>));</span><br><span class="line">        System.out.println(<span class="string">"用户的账户名称：    "</span> + props.getProperty(<span class="string">"user.name"</span>));</span><br><span class="line">        System.out.println(<span class="string">"用户的主目录：    "</span> + props.getProperty(<span class="string">"user.home"</span>));</span><br><span class="line">        System.out.println(<span class="string">"用户的当前工作目录：    "</span> + props.getProperty(<span class="string">"user.dir"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">memory</span><span class="params">()</span> <span class="keyword">throws</span> SigarException </span>&#123;</span><br><span class="line">        Sigar sigar = <span class="keyword">new</span> Sigar();</span><br><span class="line">        Mem mem = sigar.getMem();</span><br><span class="line">        <span class="comment">// 内存总量</span></span><br><span class="line">        System.out.println(<span class="string">"内存总量:    "</span> + mem.getTotal() / <span class="number">1024L</span> + <span class="string">"K av"</span>);</span><br><span class="line">        <span class="comment">// 当前内存使用量</span></span><br><span class="line">        System.out.println(<span class="string">"当前内存使用量:    "</span> + mem.getUsed() / <span class="number">1024L</span> + <span class="string">"K used"</span>);</span><br><span class="line">        <span class="comment">// 当前内存剩余量</span></span><br><span class="line">        System.out.println(<span class="string">"当前内存剩余量:    "</span> + mem.getFree() / <span class="number">1024L</span> + <span class="string">"K free"</span>);</span><br><span class="line">        Swap swap = sigar.getSwap();</span><br><span class="line">        <span class="comment">// 交换区总量</span></span><br><span class="line">        System.out.println(<span class="string">"交换区总量:    "</span> + swap.getTotal() / <span class="number">1024L</span> + <span class="string">"K av"</span>);</span><br><span class="line">        <span class="comment">// 当前交换区使用量</span></span><br><span class="line">        System.out.println(<span class="string">"当前交换区使用量:    "</span> + swap.getUsed() / <span class="number">1024L</span> + <span class="string">"K used"</span>);</span><br><span class="line">        <span class="comment">// 当前交换区剩余量</span></span><br><span class="line">        System.out.println(<span class="string">"当前交换区剩余量:    "</span> + swap.getFree() / <span class="number">1024L</span> + <span class="string">"K free"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cpu</span><span class="params">()</span> <span class="keyword">throws</span> SigarException </span>&#123;</span><br><span class="line">        Sigar sigar = <span class="keyword">new</span> Sigar();</span><br><span class="line">        CpuInfo infos[] = sigar.getCpuInfoList();</span><br><span class="line">        CpuPerc cpuList[] = <span class="keyword">null</span>;</span><br><span class="line">        cpuList = sigar.getCpuPercList();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; infos.length; i++) &#123;<span class="comment">// 不管是单块CPU还是多CPU都适用</span></span><br><span class="line">            CpuInfo info = infos[i];</span><br><span class="line">            System.out.println(<span class="string">"第"</span> + (i + <span class="number">1</span>) + <span class="string">"块CPU信息"</span>);</span><br><span class="line">            System.out.println(<span class="string">"CPU的总量MHz:    "</span> + info.getMhz());<span class="comment">// CPU的总量MHz</span></span><br><span class="line">            System.out.println(<span class="string">"CPU生产商:    "</span> + info.getVendor());<span class="comment">// 获得CPU的卖主，如：Intel</span></span><br><span class="line">            System.out.println(<span class="string">"CPU类别:    "</span> + info.getModel());<span class="comment">// 获得CPU的类别，如：Celeron</span></span><br><span class="line">            System.out.println(<span class="string">"CPU缓存数量:    "</span> + info.getCacheSize());<span class="comment">// 缓冲存储器数量</span></span><br><span class="line">            printCpuPerc(cpuList[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printCpuPerc</span><span class="params">(CpuPerc cpu)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"CPU用户使用率:    "</span> + CpuPerc.format(cpu.getUser()));<span class="comment">// 用户使用率</span></span><br><span class="line">        System.out.println(<span class="string">"CPU系统使用率:    "</span> + CpuPerc.format(cpu.getSys()));<span class="comment">// 系统使用率</span></span><br><span class="line">        System.out.println(<span class="string">"CPU当前等待率:    "</span> + CpuPerc.format(cpu.getWait()));<span class="comment">// 当前等待率</span></span><br><span class="line">        System.out.println(<span class="string">"CPU当前错误率:    "</span> + CpuPerc.format(cpu.getNice()));<span class="comment">//</span></span><br><span class="line">        System.out.println(<span class="string">"CPU当前空闲率:    "</span> + CpuPerc.format(cpu.getIdle()));<span class="comment">// 当前空闲率</span></span><br><span class="line">        System.out.println(<span class="string">"CPU总的使用率:    "</span> + CpuPerc.format(cpu.getCombined()));<span class="comment">// 总的使用率</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">os</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        OperatingSystem OS = OperatingSystem.getInstance();</span><br><span class="line">        <span class="comment">// 操作系统内核类型如： 386、486、586等x86</span></span><br><span class="line">        System.out.println(<span class="string">"操作系统:    "</span> + OS.getArch());</span><br><span class="line">        System.out.println(<span class="string">"操作系统CpuEndian():    "</span> + OS.getCpuEndian());<span class="comment">//</span></span><br><span class="line">        System.out.println(<span class="string">"操作系统DataModel():    "</span> + OS.getDataModel());<span class="comment">//</span></span><br><span class="line">        <span class="comment">// 系统描述</span></span><br><span class="line">        System.out.println(<span class="string">"操作系统的描述:    "</span> + OS.getDescription());</span><br><span class="line">        <span class="comment">// 操作系统类型</span></span><br><span class="line">        <span class="comment">// System.out.println("OS.getName():    " + OS.getName());</span></span><br><span class="line">        <span class="comment">// System.out.println("OS.getPatchLevel():    " + OS.getPatchLevel());//</span></span><br><span class="line">        <span class="comment">// 操作系统的卖主</span></span><br><span class="line">        System.out.println(<span class="string">"操作系统的卖主:    "</span> + OS.getVendor());</span><br><span class="line">        <span class="comment">// 卖主名称</span></span><br><span class="line">        System.out.println(<span class="string">"操作系统的卖主名:    "</span> + OS.getVendorCodeName());</span><br><span class="line">        <span class="comment">// 操作系统名称</span></span><br><span class="line">        System.out.println(<span class="string">"操作系统名称:    "</span> + OS.getVendorName());</span><br><span class="line">        <span class="comment">// 操作系统卖主类型</span></span><br><span class="line">        System.out.println(<span class="string">"操作系统卖主类型:    "</span> + OS.getVendorVersion());</span><br><span class="line">        <span class="comment">// 操作系统的版本号</span></span><br><span class="line">        System.out.println(<span class="string">"操作系统的版本号:    "</span> + OS.getVersion());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">who</span><span class="params">()</span> <span class="keyword">throws</span> SigarException </span>&#123;</span><br><span class="line">        Sigar sigar = <span class="keyword">new</span> Sigar();</span><br><span class="line">        Who who[] = sigar.getWhoList();</span><br><span class="line">        <span class="keyword">if</span> (who != <span class="keyword">null</span> &amp;&amp; who.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; who.length; i++) &#123;</span><br><span class="line">                <span class="comment">// System.out.println("当前系统进程表中的用户名" + String.valueOf(i));</span></span><br><span class="line">                Who _who = who[i];</span><br><span class="line">                System.out.println(<span class="string">"用户控制台:    "</span> + _who.getDevice());</span><br><span class="line">                System.out.println(<span class="string">"用户host:    "</span> + _who.getHost());</span><br><span class="line">                <span class="comment">// System.out.println("getTime():    " + _who.getTime());</span></span><br><span class="line">                <span class="comment">// 当前系统进程表中的用户名</span></span><br><span class="line">                System.out.println(<span class="string">"当前系统进程表中的用户名:    "</span> + _who.getUser());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">file</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Sigar sigar = <span class="keyword">new</span> Sigar();</span><br><span class="line">        FileSystem fslist[] = sigar.getFileSystemList();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fslist.length; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">"分区的盘符名称"</span> + i);</span><br><span class="line">                FileSystem fs = fslist[i];</span><br><span class="line">                <span class="comment">// 分区的盘符名称</span></span><br><span class="line">                System.out.println(<span class="string">"盘符名称:    "</span> + fs.getDevName());</span><br><span class="line">                <span class="comment">// 分区的盘符名称</span></span><br><span class="line">                System.out.println(<span class="string">"盘符路径:    "</span> + fs.getDirName());</span><br><span class="line">                System.out.println(<span class="string">"盘符标志:    "</span> + fs.getFlags());<span class="comment">//</span></span><br><span class="line">                <span class="comment">// 文件系统类型，比如 FAT32、NTFS</span></span><br><span class="line">                System.out.println(<span class="string">"盘符类型:    "</span> + fs.getSysTypeName());</span><br><span class="line">                <span class="comment">// 文件系统类型名，比如本地硬盘、光驱、网络文件系统等</span></span><br><span class="line">                System.out.println(<span class="string">"盘符类型名:    "</span> + fs.getTypeName());</span><br><span class="line">                <span class="comment">// 文件系统类型</span></span><br><span class="line">                System.out.println(<span class="string">"盘符文件系统类型:    "</span> + fs.getType());</span><br><span class="line">                FileSystemUsage usage = <span class="keyword">null</span>;</span><br><span class="line">                usage = sigar.getFileSystemUsage(fs.getDirName());</span><br><span class="line">                <span class="keyword">switch</span> (fs.getType()) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">// TYPE_UNKNOWN ：未知</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// TYPE_NONE</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">// TYPE_LOCAL_DISK : 本地硬盘</span></span><br><span class="line">                        <span class="comment">// 文件系统总大小</span></span><br><span class="line">                        System.out.println(fs.getDevName() + <span class="string">"总大小:    "</span> + usage.getTotal() + <span class="string">"KB"</span>);</span><br><span class="line">                        <span class="comment">// 文件系统剩余大小</span></span><br><span class="line">                        System.out.println(fs.getDevName() + <span class="string">"剩余大小:    "</span> + usage.getFree() + <span class="string">"KB"</span>);</span><br><span class="line">                        <span class="comment">// 文件系统可用大小</span></span><br><span class="line">                        System.out.println(fs.getDevName() + <span class="string">"可用大小:    "</span> + usage.getAvail() + <span class="string">"KB"</span>);</span><br><span class="line">                        <span class="comment">// 文件系统已经使用量</span></span><br><span class="line">                        System.out.println(fs.getDevName() + <span class="string">"已经使用量:    "</span> + usage.getUsed() + <span class="string">"KB"</span>);</span><br><span class="line">                        <span class="keyword">double</span> usePercent = usage.getUsePercent() * <span class="number">100</span>D;</span><br><span class="line">                        <span class="comment">// 文件系统资源的利用率</span></span><br><span class="line">                        System.out.println(fs.getDevName() + <span class="string">"资源的利用率:    "</span> + usePercent + <span class="string">"%"</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">3</span>:<span class="comment">// TYPE_NETWORK ：网络</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">4</span>:<span class="comment">// TYPE_RAM_DISK ：闪存</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">5</span>:<span class="comment">// TYPE_CDROM ：光驱</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">6</span>:<span class="comment">// TYPE_SWAP ：页面交换</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(fs.getDevName() + <span class="string">"读出：    "</span> + usage.getDiskReads());</span><br><span class="line">                System.out.println(fs.getDevName() + <span class="string">"写入：    "</span> + usage.getDiskWrites());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">net</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Sigar sigar = <span class="keyword">new</span> Sigar();</span><br><span class="line">        String ifNames[] = sigar.getNetInterfaceList();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ifNames.length; i++) &#123;</span><br><span class="line">            String name = ifNames[i];</span><br><span class="line">            NetInterfaceConfig ifconfig = sigar.getNetInterfaceConfig(name);</span><br><span class="line">            System.out.println(<span class="string">"网络设备名:    "</span> + name);<span class="comment">// 网络设备名</span></span><br><span class="line">            System.out.println(<span class="string">"IP地址:    "</span> + ifconfig.getAddress());<span class="comment">// IP地址</span></span><br><span class="line">            System.out.println(<span class="string">"子网掩码:    "</span> + ifconfig.getNetmask());<span class="comment">// 子网掩码</span></span><br><span class="line">            <span class="keyword">if</span> ((ifconfig.getFlags() &amp; <span class="number">1L</span>) &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"!IFF_UP...skipping getNetInterfaceStat"</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            NetInterfaceStat ifstat = sigar.getNetInterfaceStat(name);</span><br><span class="line">            System.out.println(name + <span class="string">"接收的总包裹数:"</span> + ifstat.getRxPackets());<span class="comment">// 接收的总包裹数</span></span><br><span class="line">            System.out.println(name + <span class="string">"发送的总包裹数:"</span> + ifstat.getTxPackets());<span class="comment">// 发送的总包裹数</span></span><br><span class="line">            System.out.println(name + <span class="string">"接收到的总字节数:"</span> + ifstat.getRxBytes());<span class="comment">// 接收到的总字节数</span></span><br><span class="line">            System.out.println(name + <span class="string">"发送的总字节数:"</span> + ifstat.getTxBytes());<span class="comment">// 发送的总字节数</span></span><br><span class="line">            System.out.println(name + <span class="string">"接收到的错误包数:"</span> + ifstat.getRxErrors());<span class="comment">// 接收到的错误包数</span></span><br><span class="line">            System.out.println(name + <span class="string">"发送数据包时的错误数:"</span> + ifstat.getTxErrors());<span class="comment">// 发送数据包时的错误数</span></span><br><span class="line">            System.out.println(name + <span class="string">"接收时丢弃的包数:"</span> + ifstat.getRxDropped());<span class="comment">// 接收时丢弃的包数</span></span><br><span class="line">            System.out.println(name + <span class="string">"发送时丢弃的包数:"</span> + ifstat.getTxDropped());<span class="comment">// 发送时丢弃的包数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ethernet</span><span class="params">()</span> <span class="keyword">throws</span> SigarException </span>&#123;</span><br><span class="line">        Sigar sigar = <span class="keyword">null</span>;</span><br><span class="line">        sigar = <span class="keyword">new</span> Sigar();</span><br><span class="line">        String[] ifaces = sigar.getNetInterfaceList();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ifaces.length; i++) &#123;</span><br><span class="line">            NetInterfaceConfig cfg = sigar.getNetInterfaceConfig(ifaces[i]);</span><br><span class="line">            <span class="keyword">if</span> (NetFlags.LOOPBACK_ADDRESS.equals(cfg.getAddress()) || (cfg.getFlags() &amp; NetFlags.IFF_LOOPBACK) != <span class="number">0</span></span><br><span class="line">                    || NetFlags.NULL_HWADDR.equals(cfg.getHwaddr())) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(cfg.getName() + <span class="string">"IP地址:"</span> + cfg.getAddress());<span class="comment">// IP地址</span></span><br><span class="line">            System.out.println(cfg.getName() + <span class="string">"网关广播地址:"</span> + cfg.getBroadcast());<span class="comment">// 网关广播地址</span></span><br><span class="line">            System.out.println(cfg.getName() + <span class="string">"网卡MAC地址:"</span> + cfg.getHwaddr());<span class="comment">// 网卡MAC地址</span></span><br><span class="line">            System.out.println(cfg.getName() + <span class="string">"子网掩码:"</span> + cfg.getNetmask());<span class="comment">// 子网掩码</span></span><br><span class="line">            System.out.println(cfg.getName() + <span class="string">"网卡描述信息:"</span> + cfg.getDescription());<span class="comment">// 网卡描述信息</span></span><br><span class="line">            System.out.println(cfg.getName() + <span class="string">"网卡类型"</span> + cfg.getType());<span class="comment">//</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SerializableFactory4Marshalling</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializableFactory4Marshalling</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建Jboss Marshalling解码器MarshallingDecoder</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> MarshallingDecoder</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MarshallingDecoder <span class="title">buildMarshallingDecoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//首先通过Marshalling工具类的精通方法获取Marshalling实例对象 参数serial标识创建的是java序列化工厂对象。</span></span><br><span class="line">        <span class="comment">//jboss-marshalling-serial 包提供</span></span><br><span class="line">        <span class="keyword">final</span> MarshallerFactory marshallerFactory = Marshalling.getProvidedMarshallerFactory(<span class="string">"serial"</span>);</span><br><span class="line">        <span class="comment">//创建了MarshallingConfiguration对象，配置了版本号为5 </span></span><br><span class="line">        <span class="keyword">final</span> MarshallingConfiguration configuration = <span class="keyword">new</span> MarshallingConfiguration();</span><br><span class="line">        <span class="comment">// 序列化版本。只要使用JDK5以上版本，version只能定义为5。</span></span><br><span class="line">        configuration.setVersion(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">//根据marshallerFactory和configuration创建provider</span></span><br><span class="line">        UnmarshallerProvider provider = <span class="keyword">new</span> DefaultUnmarshallerProvider(marshallerFactory, configuration);</span><br><span class="line">        <span class="comment">//构建Netty的MarshallingDecoder对象，俩个参数分别为provider和单个消息序列化后的最大长度</span></span><br><span class="line">        MarshallingDecoder decoder = <span class="keyword">new</span> MarshallingDecoder(provider, <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> decoder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建Jboss Marshalling编码器MarshallingEncoder</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> MarshallingEncoder</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MarshallingEncoder <span class="title">buildMarshallingEncoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> MarshallerFactory marshallerFactory = Marshalling.getProvidedMarshallerFactory(<span class="string">"serial"</span>);</span><br><span class="line">        <span class="keyword">final</span> MarshallingConfiguration configuration = <span class="keyword">new</span> MarshallingConfiguration();</span><br><span class="line">        configuration.setVersion(<span class="number">5</span>);</span><br><span class="line">        MarshallerProvider provider = <span class="keyword">new</span> DefaultMarshallerProvider(marshallerFactory, configuration);</span><br><span class="line">        <span class="comment">//构建Netty的MarshallingEncoder对象，MarshallingEncoder用于实现序列化接口的POJO对象序列化为二进制数组</span></span><br><span class="line">        MarshallingEncoder encoder = <span class="keyword">new</span> MarshallingEncoder(provider);</span><br><span class="line">        <span class="keyword">return</span> encoder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HeatbeatMessage</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeatbeatMessage</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2827219147304706826L</span>;</span><br><span class="line">    <span class="keyword">private</span> String ip;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; cpuMsgMap;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; memMsgMap;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; fileSysMsgMap;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"HeatbeatMessage [\nip="</span> + ip </span><br><span class="line">                + <span class="string">", \ncpuMsgMap="</span> + cpuMsgMap </span><br><span class="line">                + <span class="string">", \nmemMsgMap="</span> + memMsgMap</span><br><span class="line">                + <span class="string">", \nfileSysMsgMap="</span> + fileSysMsgMap + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getIp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ip;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIp</span><span class="params">(String ip)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ip = ip;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">getCpuMsgMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cpuMsgMap;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCpuMsgMap</span><span class="params">(Map&lt;String, Object&gt; cpuMsgMap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cpuMsgMap = cpuMsgMap;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">getMemMsgMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> memMsgMap;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMemMsgMap</span><span class="params">(Map&lt;String, Object&gt; memMsgMap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.memMsgMap = memMsgMap;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">getFileSysMsgMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fileSysMsgMap;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFileSysMsgMap</span><span class="params">(Map&lt;String, Object&gt; fileSysMsgMap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.fileSysMsgMap = fileSysMsgMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RequestMessage</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestMessage</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7084843947860990140L</span>;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] attachment;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"RequestMessage [id="</span> + id + <span class="string">", message="</span> + message + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RequestMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RequestMessage</span><span class="params">(Long id, String message, <span class="keyword">byte</span>[] attachment)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">        <span class="keyword">this</span>.attachment = attachment;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessage</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] getAttachment() &#123;</span><br><span class="line">        <span class="keyword">return</span> attachment;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAttachment</span><span class="params">(<span class="keyword">byte</span>[] attachment)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.attachment = attachment;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ResponseMessage</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResponseMessage</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">8134313953478922076L</span>;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"ResponseMessage [id="</span> + id + <span class="string">", message="</span> + message + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ResponseMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ResponseMessage</span><span class="params">(Long id, String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessage</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>server端开发：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. 双线程组</span></span><br><span class="line"><span class="comment"> * 2. Bootstrap配置启动信息</span></span><br><span class="line"><span class="comment"> * 3. 注册业务处理Handler</span></span><br><span class="line"><span class="comment"> * 4. 绑定服务监听端口并启动服务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server4HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 监听线程组，监听客户端请求</span></span><br><span class="line">    <span class="keyword">private</span> EventLoopGroup acceptorGroup = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 处理客户端相关操作线程组，负责处理与客户端的数据通讯</span></span><br><span class="line">    <span class="keyword">private</span> EventLoopGroup clientGroup = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 服务端启动相关配置信息</span></span><br><span class="line">    <span class="keyword">private</span> ServerBootstrap bootstrap = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Server4HelloWorld</span><span class="params">()</span></span>&#123;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 初始化线程组,构建线程组的时候，如果不传递参数，则默认构建的线程组线程数是CPU核心数量。</span></span><br><span class="line">        acceptorGroup = <span class="keyword">new</span> NioEventLoopGroup();    <span class="comment">//监听线程组</span></span><br><span class="line">        clientGroup = <span class="keyword">new</span> NioEventLoopGroup();        <span class="comment">//处理客户端线程组</span></span><br><span class="line">        <span class="comment">// 初始化服务的配置</span></span><br><span class="line">        bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">        <span class="comment">// 绑定线程组</span></span><br><span class="line">        bootstrap.group(acceptorGroup, clientGroup);</span><br><span class="line">        <span class="comment">// 设定通讯模式为NIO， 同步非阻塞</span></span><br><span class="line">        bootstrap.channel(NioServerSocketChannel.class);</span><br><span class="line">        <span class="comment">// 设定缓冲区大小， 缓存区的单位是字节。</span></span><br><span class="line">        bootstrap.option(ChannelOption.SO_BACKLOG, <span class="number">1024</span>);</span><br><span class="line">        <span class="comment">// SO_SNDBUF发送缓冲区，SO_RCVBUF接收缓冲区，SO_KEEPALIVE开启心跳监测（保证连接有效）</span></span><br><span class="line">        bootstrap.option(ChannelOption.SO_SNDBUF, <span class="number">16</span>*<span class="number">1024</span>)</span><br><span class="line">            .option(ChannelOption.SO_RCVBUF, <span class="number">16</span>*<span class="number">1024</span>)</span><br><span class="line">            .option(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监听处理逻辑。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> port 监听端口。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> acceptorHandlers 处理器， 如何处理客户端请求。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">doAccept</span><span class="params">(<span class="keyword">int</span> port, <span class="keyword">final</span> ChannelHandler... acceptorHandlers)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * childHandler是服务的Bootstrap独有的方法。是用于提供处理对象的。</span></span><br><span class="line"><span class="comment">         * 可以一次性增加若干个处理逻辑。是类似责任链模式的处理方式。</span></span><br><span class="line"><span class="comment">         * 增加A，B两个处理逻辑，在处理客户端请求数据的时候，根据A-》B顺序依次处理。</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * ChannelInitializer - 用于提供处理器的一个模型对象。</span></span><br><span class="line"><span class="comment">         *  其中定义了一个方法，initChannel方法。</span></span><br><span class="line"><span class="comment">         *   方法是用于初始化处理逻辑责任链条的。</span></span><br><span class="line"><span class="comment">         *   可以保证服务端的Bootstrap只初始化一次处理器，尽量提供处理逻辑的重用。</span></span><br><span class="line"><span class="comment">         *   避免反复的创建处理器对象。节约资源开销。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        bootstrap.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                ch.pipeline().addLast(acceptorHandlers);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// bind方法 - 绑定监听端口的。ServerBootstrap可以绑定多个监听端口。 多次调用bind方法即可</span></span><br><span class="line">        <span class="comment">// sync - 开始监听逻辑。 返回一个ChannelFuture。 返回结果代表的是监听成功后的一个对应的未来结果</span></span><br><span class="line">        <span class="comment">// 可以使用ChannelFuture实现后续的服务器和客户端的交互。</span></span><br><span class="line">        ChannelFuture future = bootstrap.bind(port).sync();</span><br><span class="line">        <span class="keyword">return</span> future;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * shutdownGracefully - 方法是一个安全关闭的方法。可以保证不放弃任何一个已接收的客户端请求。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.acceptorGroup.shutdownGracefully();</span><br><span class="line">        <span class="keyword">this</span>.clientGroup.shutdownGracefully();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ChannelFuture future = <span class="keyword">null</span>;</span><br><span class="line">        Server4HelloWorld server = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            server = <span class="keyword">new</span> Server4HelloWorld();</span><br><span class="line">            future = server.doAccept(<span class="number">9999</span>,<span class="keyword">new</span> Server4HelloWorldHandler());</span><br><span class="line">            System.out.println(<span class="string">"server started."</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 关闭连接的。</span></span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">null</span> != future)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    future.channel().closeFuture().sync();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//回收线程组资源</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">null</span> != server)&#123;</span><br><span class="line">                server.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>serverHandler</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Sharable</span>注解 - </span></span><br><span class="line"><span class="comment"> *  代表当前Handler是一个可以分享的处理器。也就意味着，服务器注册此Handler后，可以分享给多个客户端同时使用。</span></span><br><span class="line"><span class="comment"> *  如果不使用注解描述类型，则每次客户端请求时，必须为客户端重新创建一个新的Handler对象。</span></span><br><span class="line"><span class="comment"> *  如果handler是一个Sharable的，一定避免定义可写的实例变量。修改会发生混乱</span></span><br><span class="line"><span class="comment"> *  bootstrap.childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;</span></span><br><span class="line"><span class="comment">            <span class="doctag">@Override</span></span></span><br><span class="line"><span class="comment">            protected void initChannel(SocketChannel ch) throws Exception &#123;</span></span><br><span class="line"><span class="comment">                ch.pipeline().addLast(new XxxHandler());</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> com.sxt.netty.first;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFutureListener;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandler.Sharable;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerAdapter;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Sharable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server4HelloWorldHandler</span> <span class="keyword">extends</span> <span class="title">ChannelHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 业务处理逻辑</span></span><br><span class="line"><span class="comment">     * 用于处理读取数据请求的逻辑。</span></span><br><span class="line"><span class="comment">     * ctx - 上下文对象。其中包含于客户端建立连接的所有资源。 如： 对应的Channel</span></span><br><span class="line"><span class="comment">     * msg - 读取到的数据。 默认类型是ByteBuf，是Netty自定义的。是对ByteBuffer的封装。 不需要考虑复位问题。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取读取的数据， 是一个缓冲。</span></span><br><span class="line">        ByteBuf readBuffer = (ByteBuf) msg;</span><br><span class="line">        <span class="comment">// 创建一个字节数组，用于保存缓存中的数据。</span></span><br><span class="line">        <span class="keyword">byte</span>[] tempDatas = <span class="keyword">new</span> <span class="keyword">byte</span>[readBuffer.readableBytes()];</span><br><span class="line">        <span class="comment">// 将缓存中的数据读取到字节数组中。</span></span><br><span class="line">        readBuffer.readBytes(tempDatas);</span><br><span class="line">        String message = <span class="keyword">new</span> String(tempDatas, <span class="string">"UTF-8"</span>);</span><br><span class="line">        System.out.println(<span class="string">"from client : "</span> + message);</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"exit"</span>.equals(message))&#123;</span><br><span class="line">            ctx.close();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String line = <span class="string">"server message to client!"</span>;</span><br><span class="line">        <span class="comment">// 写操作自动释放缓存，避免内存溢出问题。</span></span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(line.getBytes(<span class="string">"UTF-8"</span>)));</span><br><span class="line">        <span class="comment">// 注意，如果调用的是write方法。不会刷新缓存，缓存中的数据不会发送到客户端，必须再次调用flush方法才行。</span></span><br><span class="line">        <span class="comment">// ctx.write(Unpooled.copiedBuffer(line.getBytes("UTF-8")));</span></span><br><span class="line">        <span class="comment">// ctx.flush()</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异常处理逻辑， 当客户端异常退出的时候，也会运行。</span></span><br><span class="line"><span class="comment">     * ChannelHandlerContext关闭，也代表当前与客户端连接的资源关闭。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"server exceptionCaught method run..."</span>);</span><br><span class="line">        <span class="comment">// cause.printStackTrace();</span></span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>client</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 因为客户端是请求的发起者，不需要监听。</span></span><br><span class="line"><span class="comment"> * 只需要定义唯一的一个线程组即可。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client4HelloWorld</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理请求和处理服务端响应的线程组</span></span><br><span class="line">    <span class="keyword">private</span> EventLoopGroup group = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 客户端启动相关配置信息</span></span><br><span class="line">    <span class="keyword">private</span> Bootstrap bootstrap = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Client4HelloWorld</span><span class="params">()</span></span>&#123;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">        <span class="comment">// 绑定线程组</span></span><br><span class="line">        bootstrap.group(group);</span><br><span class="line">        <span class="comment">// 设定通讯模式为NIO</span></span><br><span class="line">        bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">doRequest</span><span class="params">(String host, <span class="keyword">int</span> port, <span class="keyword">final</span> ChannelHandler... handlers)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 客户端的Bootstrap没有childHandler方法。只有handler方法。</span></span><br><span class="line"><span class="comment">         * 方法含义等同ServerBootstrap中的childHandler</span></span><br><span class="line"><span class="comment">         * 在客户端必须绑定处理器，也就是必须调用handler方法。</span></span><br><span class="line"><span class="comment">         * 服务器必须绑定处理器，必须调用childHandler方法。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">this</span>.bootstrap.handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                ch.pipeline().addLast(handlers);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 建立连接。</span></span><br><span class="line">        ChannelFuture future = <span class="keyword">this</span>.bootstrap.connect(host, port).sync();</span><br><span class="line">        <span class="keyword">return</span> future;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.group.shutdownGracefully();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Client4HelloWorld client = <span class="keyword">null</span>;</span><br><span class="line">        ChannelFuture future = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            client = <span class="keyword">new</span> Client4HelloWorld();</span><br><span class="line">            future = client.doRequest(<span class="string">"localhost"</span>, <span class="number">9999</span>, <span class="keyword">new</span> Client4HelloWorldHandler());</span><br><span class="line"></span><br><span class="line">            Scanner s = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                s = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">                System.out.print(<span class="string">"enter message send to server (enter 'exit' for close client) &gt; "</span>);</span><br><span class="line">                String line = s.nextLine();</span><br><span class="line">                <span class="keyword">if</span>(<span class="string">"exit"</span>.equals(line))&#123;</span><br><span class="line">                    <span class="comment">// addListener - 增加监听，当某条件满足的时候，触发监听器。</span></span><br><span class="line">                    <span class="comment">// ChannelFutureListener.CLOSE - 关闭监听器，代表ChannelFuture执行返回后，关闭连接。</span></span><br><span class="line">                    future.channel().writeAndFlush(Unpooled.copiedBuffer(line.getBytes(<span class="string">"UTF-8"</span>)))</span><br><span class="line">                        .addListener(ChannelFutureListener.CLOSE);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                future.channel().writeAndFlush(Unpooled.copiedBuffer(line.getBytes(<span class="string">"UTF-8"</span>)));</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">null</span> != future)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    future.channel().closeFuture().sync();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">null</span> != client)&#123;</span><br><span class="line">                client.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>clientHandler</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client4HelloWorldHandler</span> <span class="keyword">extends</span> <span class="title">ChannelHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            ByteBuf readBuffer = (ByteBuf) msg;</span><br><span class="line">            <span class="keyword">byte</span>[] tempDatas = <span class="keyword">new</span> <span class="keyword">byte</span>[readBuffer.readableBytes()];</span><br><span class="line">            readBuffer.readBytes(tempDatas);</span><br><span class="line">            System.out.println(<span class="string">"from server : "</span> + <span class="keyword">new</span> String(tempDatas, <span class="string">"UTF-8"</span>));</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="comment">// 用于释放缓存。避免内存溢出</span></span><br><span class="line">            ReferenceCountUtil.release(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"client exceptionCaught method run..."</span>);</span><br><span class="line">        <span class="comment">// cause.printStackTrace();</span></span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*@Override // 断开连接时执行</span></span><br><span class="line"><span class="comment">    public void channelInactive(ChannelHandlerContext ctx) throws Exception &#123;</span></span><br><span class="line"><span class="comment">        System.out.println("channelInactive method run...");</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    @Override // 连接通道建立成功时执行</span></span><br><span class="line"><span class="comment">    public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;</span></span><br><span class="line"><span class="comment">        System.out.println("channelActive method run...");</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    @Override // 每次读取完成时执行</span></span><br><span class="line"><span class="comment">    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception &#123;</span></span><br><span class="line"><span class="comment">        System.out.println("channelReadComplete method run...");</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="合体圆满（基础代码演示）"><a href="#合体圆满（基础代码演示）" class="headerlink" title="合体圆满（基础代码演示）"></a>合体圆满（基础代码演示）</h3><p><strong>拆包粘包问题解决</strong> ：</p>
<p>​        <em>netty</em> 使用 <em>tcp/ip</em> 协议传输数据。而 <em>tcp/ip</em> 协议是类似水流一样的数据传输方式。多次 访问的时候有可能出现数据粘包的问题。（Netty是NIO的模型，是同步非阻塞的，一定执行read/write时候就继续向下执行了，让底层的代码给我们处理执行数据的准备，怎么去读写操作，如果我们客户端发起多个数据，read方法到底是读几条数据？不知道客户端发送过来到底是几套数据，每一条间到底有什么间隔）解决这种问题的方式如下：</p>
<ul>
<li><strong>定长数据流</strong> ：客户端和服务器，提前协调好，每个消息长度固定。（如：长度 <em>10</em>）。如果客户端或服 务器写出的数据不足 <em>10</em>，则使用空白字符补足（如：使用空格）。 </li>
</ul>
<p>server</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. 双线程组</span></span><br><span class="line"><span class="comment"> * 2. Bootstrap配置启动信息</span></span><br><span class="line"><span class="comment"> * 3. 注册业务处理Handler</span></span><br><span class="line"><span class="comment"> * 4. 绑定服务监听端口并启动服务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server4FixedLength</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 监听线程组，监听客户端请求</span></span><br><span class="line">    <span class="keyword">private</span> EventLoopGroup acceptorGroup = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 处理客户端相关操作线程组，负责处理与客户端的数据通讯</span></span><br><span class="line">    <span class="keyword">private</span> EventLoopGroup clientGroup = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 服务启动相关配置信息</span></span><br><span class="line">    <span class="keyword">private</span> ServerBootstrap bootstrap = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Server4FixedLength</span><span class="params">()</span></span>&#123;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        acceptorGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        clientGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">        <span class="comment">// 绑定线程组</span></span><br><span class="line">        bootstrap.group(acceptorGroup, clientGroup);</span><br><span class="line">        <span class="comment">// 设定通讯模式为NIO</span></span><br><span class="line">        bootstrap.channel(NioServerSocketChannel.class);</span><br><span class="line">        <span class="comment">// 设定缓冲区大小</span></span><br><span class="line">        bootstrap.option(ChannelOption.SO_BACKLOG, <span class="number">1024</span>);</span><br><span class="line">        <span class="comment">// SO_SNDBUF发送缓冲区，SO_RCVBUF接收缓冲区，SO_KEEPALIVE开启心跳监测（保证连接有效）</span></span><br><span class="line">        bootstrap.option(ChannelOption.SO_SNDBUF, <span class="number">16</span>*<span class="number">1024</span>)</span><br><span class="line">            .option(ChannelOption.SO_RCVBUF, <span class="number">16</span>*<span class="number">1024</span>)</span><br><span class="line">            .option(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">doAccept</span><span class="params">(<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line"></span><br><span class="line">        bootstrap.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                ChannelHandler[] acceptorHandlers = <span class="keyword">new</span> ChannelHandler[<span class="number">3</span>];</span><br><span class="line">                <span class="comment">// 定长Handler。通过构造参数设置消息长度（单位是字节）。发送的消息长度不足可以使用空格补全。</span></span><br><span class="line">                acceptorHandlers[<span class="number">0</span>] = <span class="keyword">new</span> FixedLengthFrameDecoder(<span class="number">3</span>);</span><br><span class="line">                <span class="comment">// 字符串解码器Handler，会自动处理channelRead方法的msg参数，将ByteBuf类型的数据转换为字符串对象</span></span><br><span class="line">                acceptorHandlers[<span class="number">1</span>] = <span class="keyword">new</span> StringDecoder(Charset.forName(<span class="string">"UTF-8"</span>));</span><br><span class="line">                acceptorHandlers[<span class="number">2</span>] = <span class="keyword">new</span> Server4FixedLengthHandler();</span><br><span class="line">                ch.pipeline().addLast(acceptorHandlers);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        ChannelFuture future = bootstrap.bind(port).sync();</span><br><span class="line">        <span class="keyword">return</span> future;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.acceptorGroup.shutdownGracefully();</span><br><span class="line">        <span class="keyword">this</span>.clientGroup.shutdownGracefully();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ChannelFuture future = <span class="keyword">null</span>;</span><br><span class="line">        Server4FixedLength server = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            server = <span class="keyword">new</span> Server4FixedLength();</span><br><span class="line"></span><br><span class="line">            future = server.doAccept(<span class="number">9999</span>);</span><br><span class="line">            System.out.println(<span class="string">"server started."</span>);</span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">null</span> != future)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    future.channel().closeFuture().sync();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">null</span> != server)&#123;</span><br><span class="line">                server.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>serverHandler</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server4FixedLengthHandler</span> <span class="keyword">extends</span> <span class="title">ChannelHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 业务处理逻辑</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String message = msg.toString();</span><br><span class="line">        System.out.println(<span class="string">"from client : "</span> + message.trim());</span><br><span class="line">        String line = <span class="string">"ok "</span>;</span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(line.getBytes(<span class="string">"UTF-8"</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异常处理逻辑</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"server exceptionCaught method run..."</span>);</span><br><span class="line">        <span class="comment">// cause.printStackTrace();</span></span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>client</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. 单线程组</span></span><br><span class="line"><span class="comment"> * 2. Bootstrap配置启动信息</span></span><br><span class="line"><span class="comment"> * 3. 注册业务处理Handler</span></span><br><span class="line"><span class="comment"> * 4. connect连接服务，并发起请求</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client4FixedLength</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理请求和处理服务端响应的线程组</span></span><br><span class="line">    <span class="keyword">private</span> EventLoopGroup group = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 服务启动相关配置信息</span></span><br><span class="line">    <span class="keyword">private</span> Bootstrap bootstrap = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Client4FixedLength</span><span class="params">()</span></span>&#123;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">        <span class="comment">// 绑定线程组</span></span><br><span class="line">        bootstrap.group(group);</span><br><span class="line">        <span class="comment">// 设定通讯模式为NIO</span></span><br><span class="line">        bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">doRequest</span><span class="params">(String host, <span class="keyword">int</span> port)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bootstrap.handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                ChannelHandler[] handlers = <span class="keyword">new</span> ChannelHandler[<span class="number">3</span>];</span><br><span class="line">                handlers[<span class="number">0</span>] = <span class="keyword">new</span> FixedLengthFrameDecoder(<span class="number">3</span>);</span><br><span class="line">                <span class="comment">// 字符串解码器Handler，会自动处理channelRead方法的msg参数，将ByteBuf类型的数据转换为字符串对象</span></span><br><span class="line">                handlers[<span class="number">1</span>] = <span class="keyword">new</span> StringDecoder(Charset.forName(<span class="string">"UTF-8"</span>));</span><br><span class="line">                handlers[<span class="number">2</span>] = <span class="keyword">new</span> Client4FixedLengthHandler();</span><br><span class="line"></span><br><span class="line">                ch.pipeline().addLast(handlers);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        ChannelFuture future = <span class="keyword">this</span>.bootstrap.connect(host, port).sync();</span><br><span class="line">        <span class="keyword">return</span> future;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.group.shutdownGracefully();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Client4FixedLength client = <span class="keyword">null</span>;</span><br><span class="line">        ChannelFuture future = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            client = <span class="keyword">new</span> Client4FixedLength();</span><br><span class="line"></span><br><span class="line">            future = client.doRequest(<span class="string">"localhost"</span>, <span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line">            Scanner s = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                s = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">                System.out.print(<span class="string">"enter message send to server &gt; "</span>);</span><br><span class="line">                String line = s.nextLine();</span><br><span class="line">                <span class="keyword">byte</span>[] bs = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">5</span>];</span><br><span class="line">                <span class="keyword">byte</span>[] temp = line.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line">                <span class="keyword">if</span>(temp.length &lt;= <span class="number">5</span>)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; temp.length; i++)&#123;</span><br><span class="line">                        bs[i] = temp[i];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                future.channel().writeAndFlush(Unpooled.copiedBuffer(bs));</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">null</span> != future)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    future.channel().closeFuture().sync();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">null</span> != client)&#123;</span><br><span class="line">                client.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>clientHandler</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client4FixedLengthHandler</span> <span class="keyword">extends</span> <span class="title">ChannelHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            String message = msg.toString();</span><br><span class="line">            System.out.println(<span class="string">"from server : "</span> + message);</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="comment">// 用于释放缓存。避免内存溢出</span></span><br><span class="line">            ReferenceCountUtil.release(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"client exceptionCaught method run..."</span>);</span><br><span class="line">        <span class="comment">// cause.printStackTrace();</span></span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>注意：此时客户端只要不能满足的数据是3的长度，要可以进行多次发送。服务端才能收到数据，并且是连起来的。当客户端发的是大3的长度是，如发送abc123def4，服务器会把它当成三条数据，4不会出来，客户端在发送2个长度数据，服务端才可以接收到。</p>
<p>​        中文问题，unicode中，一个汉字可能长度是2也可能是3。如果在上面代码中的客户端发送”中国”二个字就有意思了。服务端会接收到2次，一个字一次。</p>
<ul>
<li><p><strong>特殊结束符</strong> ：客户端和服务器，协商定义一个特殊的分隔符号，分隔符号长度自定义。如：‘<em>#</em>’、‘<em>$_$</em>’、 </p>
<p>‘<em>AA@</em>’。在通讯的时候，只要没有发送分隔符号，则代表一条数据没有结束。</p>
</li>
</ul>
<p>server</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">doAccept</span><span class="params">(<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line"></span><br><span class="line">    bootstrap.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">// 数据分隔符, 定义的数据分隔符一定是一个ByteBuf类型的数据对象。</span></span><br><span class="line">            ByteBuf delimiter = Unpooled.copiedBuffer(<span class="string">"$E$"</span>.getBytes());</span><br><span class="line">            ChannelHandler[] acceptorHandlers = <span class="keyword">new</span> ChannelHandler[<span class="number">3</span>];</span><br><span class="line">            <span class="comment">// 处理固定结束标记符号的Handler。这个Handler没有@Sharable注解修饰，</span></span><br><span class="line">            <span class="comment">// 必须每次初始化通道时创建一个新对象</span></span><br><span class="line">            <span class="comment">// 使用特殊符号分隔处理数据粘包问题，也要定义每个数据包最大长度。netty建议数据有最大长度。</span></span><br><span class="line">            acceptorHandlers[<span class="number">0</span>] = <span class="keyword">new</span> DelimiterBasedFrameDecoder(<span class="number">1024</span>, delimiter);</span><br><span class="line">            <span class="comment">// 字符串解码器Handler，会自动处理channelRead方法的msg参数，将ByteBuf类型的数据转换为字符串对象</span></span><br><span class="line">            acceptorHandlers[<span class="number">1</span>] = <span class="keyword">new</span> StringDecoder(Charset.forName(<span class="string">"UTF-8"</span>));</span><br><span class="line">            acceptorHandlers[<span class="number">2</span>] = <span class="keyword">new</span> Server4DelimiterHandler();</span><br><span class="line">            ch.pipeline().addLast(acceptorHandlers);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    ChannelFuture future = bootstrap.bind(port).sync();</span><br></pre></td></tr></table></figure>
<p>serverHandler</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 业务处理逻辑</span></span><br><span class="line"><span class="meta">@Overridepublic</span> <span class="function"><span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;   </span><br><span class="line">    String message = msg.toString();   </span><br><span class="line">    System.out.println(<span class="string">"from client : "</span> + message);   </span><br><span class="line">    <span class="comment">//会放回三条字符串   </span></span><br><span class="line">    String line = <span class="string">"server message $E$ test delimiter handler!! $E$ second message $E$"</span>;         ctx.writeAndFlush(Unpooled.copiedBuffer(line.getBytes(<span class="string">"UTF-8"</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>client和server改动基本一样。此时如果客户端不输入分隔符，可以进行不断输入。</p>
<ul>
<li><p><strong>协议</strong> ：相对最成熟的数据传递方式。有服务器的开发者提供一个固定格式的协议标准。客户端 </p>
<p>和服务器发送数据和接受数据的时候，都依据协议制定和解析消息。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">协议格式：HEADcontent-length:xxxxHEADBODYxxxxxxBODY</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">doAccept</span><span class="params">(<span class="keyword">int</span> port, <span class="keyword">final</span> ChannelHandler... acceptorHandlers)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line"></span><br><span class="line">    bootstrap.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> StringDecoder(Charset.forName(<span class="string">"UTF-8"</span>)));</span><br><span class="line">            ch.pipeline().addLast(acceptorHandlers);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    ChannelFuture future = bootstrap.bind(port).sync();</span><br><span class="line">    <span class="keyword">return</span> future;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>serverHandler</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Sharable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server4ProtocolHandler</span> <span class="keyword">extends</span> <span class="title">ChannelHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 业务处理逻辑</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String message = msg.toString();</span><br><span class="line">        System.out.println(<span class="string">"server receive protocol content : "</span> + message);</span><br><span class="line">        message = ProtocolParser.parse(message);</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> == message)&#123;</span><br><span class="line">            System.out.println(<span class="string">"error request from client"</span>);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"from client : "</span> + message);</span><br><span class="line">        String line = <span class="string">"server message"</span>;</span><br><span class="line">        line = ProtocolParser.transferTo(line);</span><br><span class="line">        System.out.println(<span class="string">"server send protocol content : "</span> + line);</span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(line.getBytes(<span class="string">"UTF-8"</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异常处理逻辑</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"server exceptionCaught method run..."</span>);</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ProtocolParser</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">parse</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">            String[] temp = message.split(<span class="string">"HEADBODY"</span>);</span><br><span class="line">            temp[<span class="number">0</span>] = temp[<span class="number">0</span>].substring(<span class="number">4</span>);</span><br><span class="line">            temp[<span class="number">1</span>] = temp[<span class="number">1</span>].substring(<span class="number">0</span>, (temp[<span class="number">1</span>].length()-<span class="number">4</span>));</span><br><span class="line">            <span class="keyword">int</span> length = Integer.parseInt(temp[<span class="number">0</span>].substring(temp[<span class="number">0</span>].indexOf(<span class="string">":"</span>)+<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">if</span>(length != temp[<span class="number">1</span>].length())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> temp[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">transferTo</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">            message = <span class="string">"HEADcontent-length:"</span> + message.length() + <span class="string">"HEADBODY"</span> + message + <span class="string">"BODY"</span>;</span><br><span class="line">            <span class="keyword">return</span> message;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>协议限定拆分的格式。解决粘包。</p>
<ul>
<li><strong>序列化对象</strong> ：<em>JBoss Marshalling</em> 序列化 ，<em>Java</em> 是面向对象的开发语言。传递的数据如果是 <em>Java</em> 对象，应该是最方便且可靠。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">doAccept</span><span class="params">(<span class="keyword">int</span> port, <span class="keyword">final</span> ChannelHandler... acceptorHandlers)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line"></span><br><span class="line">    bootstrap.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            ch.pipeline().addLast(SerializableFactory4Marshalling.buildMarshallingDecoder());</span><br><span class="line">            ch.pipeline().addLast(SerializableFactory4Marshalling.buildMarshallingEncoder());</span><br><span class="line">            ch.pipeline().addLast(acceptorHandlers);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    ChannelFuture future = bootstrap.bind(port).sync();</span><br><span class="line">    <span class="keyword">return</span> future;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>serverHandler</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Sharable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server4SerializableHandler</span> <span class="keyword">extends</span> <span class="title">ChannelHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 业务处理逻辑</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"from client : ClassName - "</span> + msg.getClass().getName()</span><br><span class="line">                + <span class="string">" ; message : "</span> + msg.toString());</span><br><span class="line">        <span class="keyword">if</span>(msg <span class="keyword">instanceof</span> RequestMessage)&#123;</span><br><span class="line">            RequestMessage request = (RequestMessage)msg;</span><br><span class="line">            <span class="comment">// 解压缩</span></span><br><span class="line">            <span class="comment">// byte[] attachment = GzipUtils.unzip(request.getAttachment());</span></span><br><span class="line">            <span class="comment">// System.out.println(new String(attachment));</span></span><br><span class="line">        &#125;</span><br><span class="line">        ResponseMessage response = <span class="keyword">new</span> ResponseMessage(<span class="number">0L</span>, <span class="string">"test response"</span>);</span><br><span class="line">        ctx.writeAndFlush(response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异常处理逻辑</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"server exceptionCaught method run..."</span>);</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>client</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">doRequest</span><span class="params">(String host, <span class="keyword">int</span> port, <span class="keyword">final</span> ChannelHandler... handlers)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.bootstrap.handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            ch.pipeline().addLast(SerializableFactory4Marshalling.buildMarshallingDecoder());</span><br><span class="line">            ch.pipeline().addLast(SerializableFactory4Marshalling.buildMarshallingEncoder());</span><br><span class="line">            ch.pipeline().addLast(handlers);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    ChannelFuture future = <span class="keyword">this</span>.bootstrap.connect(host, port).sync();</span><br><span class="line">    <span class="keyword">return</span> future;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.group.shutdownGracefully();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Client4Serializable client = <span class="keyword">null</span>;</span><br><span class="line">    ChannelFuture future = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        client = <span class="keyword">new</span> Client4Serializable();</span><br><span class="line">        future = client.doRequest(<span class="string">"localhost"</span>, <span class="number">9999</span>, <span class="keyword">new</span> Client4SerializableHandler());</span><br><span class="line">        String attachment = <span class="string">"test attachment"</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] attBuf = attachment.getBytes();</span><br><span class="line">        <span class="comment">// attBuf = GzipUtils.zip(attBuf);</span></span><br><span class="line">        <span class="comment">// RequestMessage msg = new RequestMessage(new Random().nextLong(), </span></span><br><span class="line">        <span class="comment">//        "test", new byte[0]);</span></span><br><span class="line">        <span class="comment">// 压缩，有效减少网络中传递的数据</span></span><br><span class="line">        attBuf = GzipUtils.zip(attBuf);</span><br><span class="line">        RequestMessage msg = <span class="keyword">new</span> RequestMessage(<span class="keyword">new</span> Random().nextLong(), </span><br><span class="line">            <span class="string">"test"</span>, attBuf);</span><br><span class="line">        future.channel().writeAndFlush(msg);</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        future.addListener(ChannelFutureListener.CLOSE);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> != future)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                future.channel().closeFuture().sync();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> != client)&#123;</span><br><span class="line">            client.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>clientHandler</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client4SerializableHandler</span> <span class="keyword">extends</span> <span class="title">ChannelHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"from server : ClassName - "</span> + msg.getClass().getName()</span><br><span class="line">                + <span class="string">" ; message : "</span> + msg.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"client exceptionCaught method run..."</span>);</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>定时断线重连</strong> ：客户端断线重连机制。 客户端数量多，且需要传递的数据量级较大。可以周期性的发送数据的时候，使用。要 求对数据的即时性不高的时候，才可使用。 优点： 可以使用数据缓存。不是每条数据进行一次数据交互。可以定时回收资源，对 资源利用率高。相对来说，即时性可以通过其他方式保证。如： <em>120</em> 秒自动断线。数据变 化 <em>1000</em> 次请求服务器一次。<em>300</em> 秒中自动发送不足 <em>1000</em> 次的变化数据（Timer）。</li>
</ul>
<p>server</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">doAccept</span><span class="params">(<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line"></span><br><span class="line">    bootstrap.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            ch.pipeline().addLast(SerializableFactory4Marshalling.buildMarshallingDecoder());</span><br><span class="line">            ch.pipeline().addLast(SerializableFactory4Marshalling.buildMarshallingEncoder());</span><br><span class="line">            <span class="comment">// 定义一个定时断线处理器，当多长时间内，没有任何的可读取数据，自动断开连接。</span></span><br><span class="line">            <span class="comment">// 没有@Sharable的</span></span><br><span class="line">            <span class="comment">// 构造参数，就是间隔时长。 默认的单位是秒。</span></span><br><span class="line">            <span class="comment">// 自定义间隔时长单位。 new ReadTimeoutHandler(long times, TimeUnit unit);</span></span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> ReadTimeoutHandler(<span class="number">3</span>));</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> Server4TimerHandler());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    ChannelFuture future = bootstrap.bind(port).sync();</span><br><span class="line">    <span class="keyword">return</span> future;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>client</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHandlers</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.bootstrap.handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            ch.pipeline().addLast(SerializableFactory4Marshalling.buildMarshallingDecoder());</span><br><span class="line">            ch.pipeline().addLast(SerializableFactory4Marshalling.buildMarshallingEncoder());</span><br><span class="line">            <span class="comment">// 写操作自定断线。 在指定时间内，没有写操作，自动断线。</span></span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> WriteTimeoutHandler(<span class="number">3</span>));</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> Client4TimerHandler());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">getChannelFuture</span><span class="params">(String host, <span class="keyword">int</span> port)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">    <span class="comment">// future是null，我们就要建立连接</span></span><br><span class="line">    <span class="keyword">if</span>(future == <span class="keyword">null</span>)&#123;</span><br><span class="line">        future = <span class="keyword">this</span>.bootstrap.connect(host, port).sync();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果非空，看些连接未来状态中的通道是否有效。</span></span><br><span class="line">    <span class="comment">// 如果future非空，但是有个channel，证明已经和服务器断开了，但是future没有被回收</span></span><br><span class="line">    <span class="comment">// 重连操作</span></span><br><span class="line">    <span class="keyword">if</span>(!future.channel().isActive())&#123;</span><br><span class="line">        future = <span class="keyword">this</span>.bootstrap.connect(host, port).sync();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> future;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.group.shutdownGracefully();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Client4Timer client = <span class="keyword">null</span>;</span><br><span class="line">    ChannelFuture future = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        client = <span class="keyword">new</span> Client4Timer();</span><br><span class="line">        client.setHandlers();</span><br><span class="line"></span><br><span class="line">        future = client.getChannelFuture(<span class="string">"localhost"</span>, <span class="number">9999</span>);</span><br><span class="line">        <span class="comment">// 循环3从。睡眠2秒，没有超出时长</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">            RequestMessage msg = <span class="keyword">new</span> RequestMessage(<span class="keyword">new</span> Random().nextLong(), </span><br><span class="line">                    <span class="string">"test"</span>+i, <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>]);</span><br><span class="line">            future.channel().writeAndFlush(msg);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 有超出时长</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        future = client.getChannelFuture(<span class="string">"localhost"</span>, <span class="number">9999</span>);</span><br><span class="line">        RequestMessage msg = <span class="keyword">new</span> RequestMessage(<span class="keyword">new</span> Random().nextLong(), </span><br><span class="line">                <span class="string">"test"</span>, <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>]);</span><br><span class="line">        future.channel().writeAndFlush(msg);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> != future)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                future.channel().closeFuture().sync();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> != client)&#123;</span><br><span class="line">            client.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>clientHandler</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client4TimerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"from server : ClassName - "</span> + msg.getClass().getName()</span><br><span class="line">                + <span class="string">" ; message : "</span> + msg.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"client exceptionCaught method run..."</span>);</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当连接建立成功后，出发的代码逻辑。</span></span><br><span class="line"><span class="comment">     * 在一次连接中只运行唯一一次。</span></span><br><span class="line"><span class="comment">     * 通常用于实现连接确认和资源初始化的。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"client channel active"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>server端运行图。有断线有异常，</p>
<p><img src="\media\1582293141(1" alt="">.jpg)</p>
<p><img src="\media\1582293463(1" alt="">.jpg)</p>
<ul>
<li><strong>心跳监测</strong> ：使用定时发送消息的方式，实现硬件检测，达到心态检测的目的。 心跳监测是用于检测电脑硬件和软件信息的一种技术。如：<em>CPU</em> 使用率，磁盘使用率， 内存使用率，进程情况，线程情况等。 </li>
<li><strong>sigar</strong> ：需要下载一个 <em>zip</em> 压缩包。内部包含若干 <em>sigar</em> 需要的操作系统文件。<em>sigar</em> 插件是通过 <em>JVM</em> 访问操作系统，读取计算机硬件的一个插件库。读取计算机硬件过程中，必须由操作系统提供硬件信息。硬件信息是通过操作系统提供的。<em>zip</em> 压缩包中是 <em>sigar</em> 编写的操作系统文 件，如：<em>windows</em> 中的动态链接库文件。 解压需要的操作系统文件，将操作系统文件赋值到<em>${Java_home}/bin</em> 目录中。</li>
</ul>
<p>server</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server4Heatbeat</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 监听线程组，监听客户端请求</span></span><br><span class="line">    <span class="keyword">private</span> EventLoopGroup acceptorGroup = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 处理客户端相关操作线程组，负责处理与客户端的数据通讯</span></span><br><span class="line">    <span class="keyword">private</span> EventLoopGroup clientGroup = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 服务启动相关配置信息</span></span><br><span class="line">    <span class="keyword">private</span> ServerBootstrap bootstrap = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Server4Heatbeat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        acceptorGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        clientGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">        <span class="comment">// 绑定线程组</span></span><br><span class="line">        bootstrap.group(acceptorGroup, clientGroup);</span><br><span class="line">        <span class="comment">// 设定通讯模式为NIO</span></span><br><span class="line">        bootstrap.channel(NioServerSocketChannel.class);</span><br><span class="line">        <span class="comment">// 设定缓冲区大小</span></span><br><span class="line">        bootstrap.option(ChannelOption.SO_BACKLOG, <span class="number">1024</span>);</span><br><span class="line">        <span class="comment">// SO_SNDBUF发送缓冲区，SO_RCVBUF接收缓冲区，SO_KEEPALIVE开启心跳监测（保证连接有效）</span></span><br><span class="line">        bootstrap.option(ChannelOption.SO_SNDBUF, <span class="number">16</span>*<span class="number">1024</span>)</span><br><span class="line">            .option(ChannelOption.SO_RCVBUF, <span class="number">16</span>*<span class="number">1024</span>)</span><br><span class="line">            .option(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">doAccept</span><span class="params">(<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line"></span><br><span class="line">        bootstrap.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                ch.pipeline().addLast(SerializableFactory4Marshalling.buildMarshallingDecoder());</span><br><span class="line">                ch.pipeline().addLast(SerializableFactory4Marshalling.buildMarshallingEncoder());</span><br><span class="line">                ch.pipeline().addLast(<span class="keyword">new</span> Server4HeatbeatHandler());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        ChannelFuture future = bootstrap.bind(port).sync();</span><br><span class="line">        <span class="keyword">return</span> future;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.acceptorGroup.shutdownGracefully();</span><br><span class="line">        <span class="keyword">this</span>.clientGroup.shutdownGracefully();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ChannelFuture future = <span class="keyword">null</span>;</span><br><span class="line">        Server4Heatbeat server = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            server = <span class="keyword">new</span> Server4Heatbeat();</span><br><span class="line">            future = server.doAccept(<span class="number">9999</span>);</span><br><span class="line">            System.out.println(<span class="string">"server started."</span>);</span><br><span class="line"></span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">null</span> != future)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    future.channel().closeFuture().sync();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">null</span> != server)&#123;</span><br><span class="line">                server.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>serverHandler</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Sharable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server4HeatbeatHandler</span> <span class="keyword">extends</span> <span class="title">ChannelHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; credentials = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String HEATBEAT_SUCCESS = <span class="string">"SERVER_RETURN_HEATBEAT_SUCCESS"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Server4HeatbeatHandler</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 初始化客户端列表信息。一般通过配置文件读取或数据库读取。</span></span><br><span class="line">        credentials.add(<span class="string">"192.168.199.222_WIN-QIUB2JF5TDP"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 业务处理逻辑</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(msg <span class="keyword">instanceof</span> String)&#123;</span><br><span class="line">            <span class="keyword">this</span>.checkCredential(ctx, msg.toString());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> HeatbeatMessage)&#123;</span><br><span class="line">            <span class="keyword">this</span>.readHeatbeatMessage(ctx, msg);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 服务器发送的信息是错误的，或者对外暴露的ip和端口号被与系统无关的人访问到了，自动断开连接</span></span><br><span class="line">            ctx.writeAndFlush(<span class="string">"wrong message"</span>).addListener(ChannelFutureListener.CLOSE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readHeatbeatMessage</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span></span>&#123;</span><br><span class="line">        HeatbeatMessage message = (HeatbeatMessage) msg;</span><br><span class="line">        System.out.println(message);</span><br><span class="line">        System.out.println(<span class="string">"======================================="</span>);</span><br><span class="line">        ctx.writeAndFlush(<span class="string">"receive heatbeat message"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 身份检查。检查客户端身份是否有效。</span></span><br><span class="line"><span class="comment">     * 客户端身份信息应该是通过数据库或数据文件定制的。</span></span><br><span class="line"><span class="comment">     * 身份通过 - 返回确认消息。</span></span><br><span class="line"><span class="comment">     * 身份无效 - 断开连接</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> credential</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkCredential</span><span class="params">(ChannelHandlerContext ctx, String credential)</span></span>&#123;</span><br><span class="line">        System.out.println(credential);</span><br><span class="line">        System.out.println(credentials);</span><br><span class="line">        <span class="keyword">if</span>(credentials.contains(credential))&#123;</span><br><span class="line">            ctx.writeAndFlush(HEATBEAT_SUCCESS);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ctx.writeAndFlush(<span class="string">"no credential contains"</span>).addListener(ChannelFutureListener.CLOSE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异常处理逻辑</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"server exceptionCaught method run..."</span>);</span><br><span class="line">        <span class="comment">// cause.printStackTrace();</span></span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>clientHandler</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client4HeatbeatHandler</span> <span class="keyword">extends</span> <span class="title">ChannelHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ScheduledExecutorService executorService = Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> ScheduledFuture heatbeat;</span><br><span class="line">    <span class="keyword">private</span> InetAddress remoteAddr;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String HEATBEAT_SUCCESS = <span class="string">"SERVER_RETURN_HEATBEAT_SUCCESS"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//只运行一次</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取本地INET信息</span></span><br><span class="line">        <span class="keyword">this</span>.remoteAddr = InetAddress.getLocalHost();</span><br><span class="line">        <span class="comment">// 获取本地计算机名</span></span><br><span class="line">        String computerName = System.getenv().get(<span class="string">"COMPUTERNAME"</span>);</span><br><span class="line">        String credentials = <span class="keyword">this</span>.remoteAddr.getHostAddress() + <span class="string">"_"</span> + computerName;</span><br><span class="line">        System.out.println(credentials);</span><br><span class="line">        <span class="comment">// 发送到服务器，作为信息比对证书</span></span><br><span class="line">        ctx.writeAndFlush(credentials);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(msg <span class="keyword">instanceof</span> String)&#123;</span><br><span class="line">                <span class="keyword">if</span>(HEATBEAT_SUCCESS.equals(msg))&#123;</span><br><span class="line">                    <span class="keyword">this</span>.heatbeat = <span class="keyword">this</span>.executorService.scheduleWithFixedDelay(<span class="keyword">new</span> HeatbeatTask(ctx), <span class="number">0L</span>, <span class="number">2L</span>, TimeUnit.SECONDS);</span><br><span class="line">                    System.out.println(<span class="string">"client receive - "</span> + msg);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">"client receive - "</span> + msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            ReferenceCountUtil.release(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"client exceptionCaught method run..."</span>);</span><br><span class="line">        <span class="comment">// cause.printStackTrace();</span></span><br><span class="line">        <span class="comment">// 回收资源</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.heatbeat != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.heatbeat.cancel(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">this</span>.heatbeat = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">HeatbeatTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> ChannelHandlerContext ctx;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">HeatbeatTask</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">HeatbeatTask</span><span class="params">(ChannelHandlerContext ctx)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.ctx = ctx;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                HeatbeatMessage msg = <span class="keyword">new</span> HeatbeatMessage();</span><br><span class="line">                msg.setIp(remoteAddr.getHostAddress());</span><br><span class="line">                Sigar sigar = <span class="keyword">new</span> Sigar();</span><br><span class="line">                <span class="comment">// CPU信息</span></span><br><span class="line">                CpuPerc cpuPerc = sigar.getCpuPerc();</span><br><span class="line">                Map&lt;String, Object&gt; cpuMsgMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                cpuMsgMap.put(<span class="string">"Combined"</span>, cpuPerc.getCombined());</span><br><span class="line">                cpuMsgMap.put(<span class="string">"User"</span>, cpuPerc.getUser());</span><br><span class="line">                cpuMsgMap.put(<span class="string">"Sys"</span>, cpuPerc.getSys());</span><br><span class="line">                cpuMsgMap.put(<span class="string">"Wait"</span>, cpuPerc.getWait());</span><br><span class="line">                cpuMsgMap.put(<span class="string">"Idle"</span>, cpuPerc.getIdle());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 内存信息</span></span><br><span class="line">                Map&lt;String, Object&gt; memMsgMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                Mem mem = sigar.getMem();</span><br><span class="line">                memMsgMap.put(<span class="string">"Total"</span>, mem.getTotal());</span><br><span class="line">                memMsgMap.put(<span class="string">"Used"</span>, mem.getUsed());</span><br><span class="line">                memMsgMap.put(<span class="string">"Free"</span>, mem.getFree());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 文件系统</span></span><br><span class="line">                Map&lt;String, Object&gt; fileSysMsgMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                FileSystem[] list = sigar.getFileSystemList();</span><br><span class="line">                fileSysMsgMap.put(<span class="string">"FileSysCount"</span>, list.length);</span><br><span class="line">                List&lt;String&gt; msgList = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">for</span>(FileSystem fs : list)&#123;</span><br><span class="line">                    msgList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                    msgList.add(fs.getDevName() + <span class="string">"总大小:    "</span> + sigar.getFileSystemUsage(fs.getDirName()).getTotal() + <span class="string">"KB"</span>);</span><br><span class="line">                    msgList.add(fs.getDevName() + <span class="string">"剩余大小:    "</span> + sigar.getFileSystemUsage(fs.getDirName()).getFree() + <span class="string">"KB"</span>);</span><br><span class="line">                    fileSysMsgMap.put(fs.getDevName(), msgList);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                msg.setCpuMsgMap(cpuMsgMap);</span><br><span class="line">                msg.setMemMsgMap(memMsgMap);</span><br><span class="line">                msg.setFileSysMsgMap(fileSysMsgMap);</span><br><span class="line"></span><br><span class="line">                ctx.writeAndFlush(msg);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>HTTP</strong> <strong>协议处理</strong> ：使用 <em>Netty</em> 服务开发。实现 <em>HTTP</em> 协议处理逻辑。 没有客户端，做一个http协议文件传输到netty服务器</li>
</ul>
<p>server</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * http协议文件传输 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Qixuan.Chen </span></span><br><span class="line"><span class="comment"> * 创建时间：2015年5月4日 </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpStaticFileServer</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> port;<span class="comment">//端口  </span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HttpStaticFileServer</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.port = port;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();<span class="comment">//线程一 //这个是用于serversocketchannel的event  </span></span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();<span class="comment">//线程二//这个是用于处理accept到的channel  </span></span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();  </span><br><span class="line">            b.group(bossGroup, workerGroup)  </span><br><span class="line">             .channel(NioServerSocketChannel.class)  </span><br><span class="line">             .childHandler(<span class="keyword">new</span> HttpStaticFileServerInitializer());  </span><br><span class="line"></span><br><span class="line">            b.bind(port).sync().channel().closeFuture().sync();  </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">            bossGroup.shutdownGracefully();  </span><br><span class="line">            workerGroup.shutdownGracefully();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">8089</span>;  </span><br><span class="line">        <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">            port = Integer.parseInt(args[<span class="number">0</span>]);  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            port = <span class="number">8089</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">new</span> HttpStaticFileServer(port).run();<span class="comment">//启动服务  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpStaticFileServerInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">        <span class="comment">// Create a default pipeline implementation.</span></span><br><span class="line">        <span class="comment">// 通道的连接点</span></span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Uncomment the following line if you want HTTPS  </span></span><br><span class="line">        <span class="comment">//SSLEngine engine = SecureChatSslContextFactory.getServerContext().createSSLEngine();  </span></span><br><span class="line">        <span class="comment">//engine.setUseClientMode(false);  </span></span><br><span class="line">        <span class="comment">//pipeline.addLast("ssl", new SslHandler(engine));  </span></span><br><span class="line">       <span class="comment">/** </span></span><br><span class="line"><span class="comment">        *   （1）ReadTimeoutHandler，用于控制读取数据的时候的超时，10表示如果10秒钟都没有数据读取了，那么就引发超时，然后关闭当前的channel </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            （2）WriteTimeoutHandler，用于控制数据输出的时候的超时，构造参数1表示如果持续1秒钟都没有数据写了，那么就超时。 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            （3）HttpRequestrianDecoder，这个handler用于从读取的数据中将http报文信息解析出来，无非就是什么requestline，header，body什么的。。。 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            （4）然后HttpObjectAggregator则是用于将上卖解析出来的http报文的数据组装成为封装好的httprequest对象。。 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            （5）HttpresponseEncoder，用于将用户返回的httpresponse编码成为http报文格式的数据 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            （6）HttpHandler，自定义的handler，用于处理接收到的http请求。 </span></span><br><span class="line"><span class="comment">        */</span>  </span><br><span class="line"></span><br><span class="line">        pipeline.addLast(<span class="string">"decoder"</span>, <span class="keyword">new</span> HttpRequestDecoder());<span class="comment">// http-request解码器,http服务器端对request解码  </span></span><br><span class="line">        pipeline.addLast(<span class="string">"aggregator"</span>, <span class="keyword">new</span> HttpObjectAggregator(<span class="number">65536</span>));<span class="comment">//对传输文件大少进行限制  </span></span><br><span class="line">        pipeline.addLast(<span class="string">"encoder"</span>, <span class="keyword">new</span> HttpResponseEncoder());<span class="comment">//http-response解码器,http服务器端对response编码  </span></span><br><span class="line">        <span class="comment">// 向客户端发送数据的一个Handler</span></span><br><span class="line">        pipeline.addLast(<span class="string">"chunkedWriter"</span>, <span class="keyword">new</span> ChunkedWriteHandler());  </span><br><span class="line"></span><br><span class="line">        pipeline.addLast(<span class="string">"handler"</span>, <span class="keyword">new</span> HttpStaticFileServerHandler(<span class="keyword">true</span>)); <span class="comment">// Specify false if SSL.(如果是ssl,就指定为false)  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>serverHandler</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpStaticFileServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">FullHttpRequest</span>&gt; </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HTTP_DATE_FORMAT = <span class="string">"EEE, dd MMM yyyy HH:mm:ss zzz"</span>;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HTTP_DATE_GMT_TIMEZONE = <span class="string">"GMT"</span>;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HTTP_CACHE_SECONDS = <span class="number">60</span>;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> useSendFile;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HttpStaticFileServerHandler</span><span class="params">(<span class="keyword">boolean</span> useSendFile)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.useSendFile = useSendFile;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 类似channelRead方法。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">messageReceived</span><span class="params">(  </span></span></span><br><span class="line"><span class="function"><span class="params">            ChannelHandlerContext ctx, FullHttpRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">        <span class="comment">// 请求头信息是否正确的</span></span><br><span class="line">        <span class="keyword">if</span> (!request.decoderResult().isSuccess()) &#123;  </span><br><span class="line">            sendError(ctx, BAD_REQUEST);  </span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (request.method() != GET) &#123;  </span><br><span class="line">            sendError(ctx, METHOD_NOT_ALLOWED);  </span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> String uri = request.uri();  </span><br><span class="line">        System.out.println(<span class="string">"-----uri----"</span>+uri);  </span><br><span class="line">        <span class="keyword">final</span> String path = sanitizeUri(uri);  </span><br><span class="line">        System.out.println(<span class="string">"-----path----"</span>+path);  </span><br><span class="line">        <span class="keyword">if</span> (path == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            sendError(ctx, FORBIDDEN);  </span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        File file = <span class="keyword">new</span> File(path);  </span><br><span class="line">        <span class="keyword">if</span> (file.isHidden() || !file.exists()) &#123;  </span><br><span class="line">            sendError(ctx, NOT_FOUND);  </span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (file.isDirectory()) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (uri.endsWith(<span class="string">"/"</span>)) &#123;  </span><br><span class="line">                sendListing(ctx, file);  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                sendRedirect(ctx, uri + <span class="string">'/'</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!file.isFile()) &#123;  </span><br><span class="line">            sendError(ctx, FORBIDDEN);  </span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Cache Validation  </span></span><br><span class="line">        String ifModifiedSince = (String) request.headers().get(IF_MODIFIED_SINCE);  </span><br><span class="line">        <span class="keyword">if</span> (ifModifiedSince != <span class="keyword">null</span> &amp;&amp; !ifModifiedSince.isEmpty()) &#123;  </span><br><span class="line">            SimpleDateFormat dateFormatter = <span class="keyword">new</span> SimpleDateFormat(HTTP_DATE_FORMAT, Locale.US);  </span><br><span class="line">            Date ifModifiedSinceDate = dateFormatter.parse(ifModifiedSince);  </span><br><span class="line"></span><br><span class="line">            <span class="comment">// Only compare up to the second because the datetime format we send to the client  </span></span><br><span class="line">            <span class="comment">// does not have milliseconds  </span></span><br><span class="line">            <span class="keyword">long</span> ifModifiedSinceDateSeconds = ifModifiedSinceDate.getTime() / <span class="number">1000</span>;  </span><br><span class="line">            <span class="keyword">long</span> fileLastModifiedSeconds = file.lastModified() / <span class="number">1000</span>;  </span><br><span class="line">            <span class="keyword">if</span> (ifModifiedSinceDateSeconds == fileLastModifiedSeconds) &#123;  </span><br><span class="line">                sendNotModified(ctx);  </span><br><span class="line">                <span class="keyword">return</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">          <span class="comment">// 文件下载</span></span><br><span class="line">        RandomAccessFile raf;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            raf = <span class="keyword">new</span> RandomAccessFile(file, <span class="string">"r"</span>);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException fnfe) &#123;  </span><br><span class="line">            sendError(ctx, NOT_FOUND);  </span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">long</span> fileLength = raf.length();  </span><br><span class="line"></span><br><span class="line">        HttpResponse response = <span class="keyword">new</span> DefaultHttpResponse(HTTP_1_1, OK);  </span><br><span class="line">        <span class="comment">//setContentLength(response, fileLength);  </span></span><br><span class="line">        HttpHeaderUtil.setContentLength(response, fileLength);</span><br><span class="line">        setContentTypeHeader(response, file);  </span><br><span class="line">        setDateAndCacheHeaders(response, file);  </span><br><span class="line">        <span class="keyword">if</span> (HttpHeaderUtil.isKeepAlive(request)) &#123;</span><br><span class="line"></span><br><span class="line">            response.headers().set(CONNECTION, HttpHeaderValues.KEEP_ALIVE);  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write the initial line and the header.  </span></span><br><span class="line">        ctx.write(response);  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write the content.  </span></span><br><span class="line">        ChannelFuture sendFileFuture;  </span><br><span class="line">        <span class="keyword">if</span> (useSendFile) &#123;  </span><br><span class="line">            sendFileFuture =  </span><br><span class="line">                    ctx.write(<span class="keyword">new</span> DefaultFileRegion(raf.getChannel(), <span class="number">0</span>, fileLength), ctx.newProgressivePromise());  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            sendFileFuture =  </span><br><span class="line">                    ctx.write(<span class="keyword">new</span> ChunkedFile(raf, <span class="number">0</span>, fileLength, <span class="number">8192</span>), ctx.newProgressivePromise());  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        sendFileFuture.addListener(<span class="keyword">new</span> ChannelProgressiveFutureListener() &#123;  </span><br><span class="line">            <span class="meta">@Override</span>  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationProgressed</span><span class="params">(ChannelProgressiveFuture future, <span class="keyword">long</span> progress, <span class="keyword">long</span> total)</span> </span>&#123;  </span><br><span class="line">                <span class="keyword">if</span> (total &lt; <span class="number">0</span>) &#123; <span class="comment">// total unknown  </span></span><br><span class="line">                    System.err.println(<span class="string">"Transfer progress: "</span> + progress);  </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                    System.err.println(<span class="string">"Transfer progress: "</span> + progress + <span class="string">" / "</span> + total);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span>  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelProgressiveFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">                System.err.println(<span class="string">"Transfer complete."</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;);  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write the end marker  </span></span><br><span class="line">        ChannelFuture lastContentFuture = ctx.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT);  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Decide whether to close the connection or not.  </span></span><br><span class="line">        <span class="keyword">if</span> (!HttpHeaderUtil.isKeepAlive(request)) &#123;  </span><br><span class="line">            <span class="comment">// Close the connection when the whole content is written out.  </span></span><br><span class="line">            lastContentFuture.addListener(ChannelFutureListener.CLOSE);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">        cause.printStackTrace();  </span><br><span class="line">        <span class="keyword">if</span> (ctx.channel().isActive()) &#123;  </span><br><span class="line">            sendError(ctx, INTERNAL_SERVER_ERROR);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Pattern INSECURE_URI = Pattern.compile(<span class="string">".*[&lt;&gt;&amp;\"].*"</span>);  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 路径解码 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uri </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">sanitizeUri</span><span class="params">(String uri)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// Decode the path.  </span></span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            uri = URLDecoder.decode(uri, <span class="string">"UTF-8"</span>);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;  </span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                uri = URLDecoder.decode(uri, <span class="string">"ISO-8859-1"</span>);  </span><br><span class="line">            &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e1) &#123;  </span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!uri.startsWith(<span class="string">"/"</span>)) &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Convert file separators.  </span></span><br><span class="line">        uri = uri.replace(<span class="string">'/'</span>, File.separatorChar);  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Simplistic dumb security check.  </span></span><br><span class="line">        <span class="comment">// You will have to do something serious in the production environment.  </span></span><br><span class="line">        <span class="keyword">if</span> (uri.contains(File.separator + <span class="string">'.'</span>) ||  </span><br><span class="line">            uri.contains(<span class="string">'.'</span> + File.separator) ||  </span><br><span class="line">            uri.startsWith(<span class="string">"."</span>) || uri.endsWith(<span class="string">"."</span>) ||  </span><br><span class="line">            INSECURE_URI.matcher(uri).matches()) &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Convert to absolute path.  </span></span><br><span class="line">        <span class="keyword">return</span> System.getProperty(<span class="string">"user.dir"</span>) + File.separator + uri;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Pattern ALLOWED_FILE_NAME = Pattern.compile(<span class="string">"[A-Za-z0-9][-_A-Za-z0-9\\.]*"</span>);  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendListing</span><span class="params">(ChannelHandlerContext ctx, File dir)</span> </span>&#123;  </span><br><span class="line">        FullHttpResponse response = <span class="keyword">new</span> DefaultFullHttpResponse(HTTP_1_1, OK);  </span><br><span class="line">        response.headers().set(CONTENT_TYPE, <span class="string">"text/html; charset=UTF-8"</span>);  </span><br><span class="line"></span><br><span class="line">        StringBuilder buf = <span class="keyword">new</span> StringBuilder();  </span><br><span class="line">        String dirPath = dir.getPath();  </span><br><span class="line"></span><br><span class="line">        buf.append(<span class="string">"&lt;!DOCTYPE html&gt;\r\n"</span>);  </span><br><span class="line">        buf.append(<span class="string">"&lt;html&gt;&lt;head&gt;&lt;title&gt;"</span>);  </span><br><span class="line">        buf.append(<span class="string">"Listing of: "</span>);  </span><br><span class="line">        buf.append(dirPath);  </span><br><span class="line">        buf.append(<span class="string">"&lt;/title&gt;&lt;/head&gt;&lt;body&gt;\r\n"</span>);  </span><br><span class="line"></span><br><span class="line">        buf.append(<span class="string">"&lt;h3&gt;Listing of: "</span>);  </span><br><span class="line">        buf.append(dirPath);  </span><br><span class="line">        buf.append(<span class="string">"&lt;/h3&gt;\r\n"</span>);  </span><br><span class="line"></span><br><span class="line">        buf.append(<span class="string">"&lt;ul&gt;"</span>);  </span><br><span class="line">        buf.append(<span class="string">"&lt;li&gt;&lt;a href=\"../\"&gt;..&lt;/a&gt;&lt;/li&gt;\r\n"</span>);  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (File f: dir.listFiles()) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (f.isHidden() || !f.canRead()) &#123;  </span><br><span class="line">                <span class="keyword">continue</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line"></span><br><span class="line">            String name = f.getName();  </span><br><span class="line">            <span class="keyword">if</span> (!ALLOWED_FILE_NAME.matcher(name).matches()) &#123;  </span><br><span class="line">                <span class="keyword">continue</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line"></span><br><span class="line">            buf.append(<span class="string">"&lt;li&gt;&lt;a href=\""</span>);  </span><br><span class="line">            buf.append(name);  </span><br><span class="line">            buf.append(<span class="string">"\"&gt;"</span>);  </span><br><span class="line">            buf.append(name);  </span><br><span class="line">            buf.append(<span class="string">"&lt;/a&gt;&lt;/li&gt;\r\n"</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        buf.append(<span class="string">"&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;\r\n"</span>);  </span><br><span class="line">        ByteBuf buffer = Unpooled.copiedBuffer(buf, CharsetUtil.UTF_8);  </span><br><span class="line">        response.content().writeBytes(buffer);  </span><br><span class="line">        buffer.release();  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Close the connection as soon as the error message is sent.  </span></span><br><span class="line">        ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendRedirect</span><span class="params">(ChannelHandlerContext ctx, String newUri)</span> </span>&#123;  </span><br><span class="line">        FullHttpResponse response = <span class="keyword">new</span> DefaultFullHttpResponse(HTTP_1_1, FOUND);  </span><br><span class="line">        response.headers().set(LOCATION, newUri);  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Close the connection as soon as the error message is sent.  </span></span><br><span class="line">        ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendError</span><span class="params">(ChannelHandlerContext ctx, HttpResponseStatus status)</span> </span>&#123;  </span><br><span class="line">        FullHttpResponse response = <span class="keyword">new</span> DefaultFullHttpResponse(  </span><br><span class="line">                HTTP_1_1, status, Unpooled.copiedBuffer(<span class="string">"Failure: "</span> + status.toString() + <span class="string">"\r\n"</span>, CharsetUtil.UTF_8));  </span><br><span class="line">        response.headers().set(CONTENT_TYPE, <span class="string">"text/plain; charset=UTF-8"</span>);  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Close the connection as soon as the error message is sent.  </span></span><br><span class="line">        ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * When file timestamp is the same as what the browser is sending up, send a "304 Not Modified" </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx </span></span><br><span class="line"><span class="comment">     *            Context </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendNotModified</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;  </span><br><span class="line">        FullHttpResponse response = <span class="keyword">new</span> DefaultFullHttpResponse(HTTP_1_1, NOT_MODIFIED);  </span><br><span class="line">        setDateHeader(response);  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Close the connection as soon as the error message is sent.  </span></span><br><span class="line">        ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * Sets the Date header for the HTTP response </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response </span></span><br><span class="line"><span class="comment">     *            HTTP response </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setDateHeader</span><span class="params">(FullHttpResponse response)</span> </span>&#123;  </span><br><span class="line">        SimpleDateFormat dateFormatter = <span class="keyword">new</span> SimpleDateFormat(HTTP_DATE_FORMAT, Locale.US);  </span><br><span class="line">        dateFormatter.setTimeZone(TimeZone.getTimeZone(HTTP_DATE_GMT_TIMEZONE));  </span><br><span class="line"></span><br><span class="line">        Calendar time = <span class="keyword">new</span> GregorianCalendar();  </span><br><span class="line">        response.headers().set(DATE, dateFormatter.format(time.getTime()));  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * Sets the Date and Cache headers for the HTTP Response </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response </span></span><br><span class="line"><span class="comment">     *            HTTP response </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fileToCache </span></span><br><span class="line"><span class="comment">     *            file to extract content type </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setDateAndCacheHeaders</span><span class="params">(HttpResponse response, File fileToCache)</span> </span>&#123;  </span><br><span class="line">        SimpleDateFormat dateFormatter = <span class="keyword">new</span> SimpleDateFormat(HTTP_DATE_FORMAT, Locale.US);  </span><br><span class="line">        dateFormatter.setTimeZone(TimeZone.getTimeZone(HTTP_DATE_GMT_TIMEZONE));  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Date header  </span></span><br><span class="line">        Calendar time = <span class="keyword">new</span> GregorianCalendar();  </span><br><span class="line">        response.headers().set(DATE, dateFormatter.format(time.getTime()));  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add cache headers  </span></span><br><span class="line">        time.add(Calendar.SECOND, HTTP_CACHE_SECONDS);  </span><br><span class="line">        response.headers().set(EXPIRES, dateFormatter.format(time.getTime()));  </span><br><span class="line">        response.headers().set(CACHE_CONTROL, <span class="string">"private, max-age="</span> + HTTP_CACHE_SECONDS);  </span><br><span class="line">        response.headers().set(  </span><br><span class="line">                LAST_MODIFIED, dateFormatter.format(<span class="keyword">new</span> Date(fileToCache.lastModified())));  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * Sets the content type header for the HTTP Response </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response </span></span><br><span class="line"><span class="comment">     *            HTTP response </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file </span></span><br><span class="line"><span class="comment">     *            file to extract content type </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setContentTypeHeader</span><span class="params">(HttpResponse response, File file)</span> </span>&#123;  </span><br><span class="line">        MimetypesFileTypeMap mimeTypesMap = <span class="keyword">new</span> MimetypesFileTypeMap();  </span><br><span class="line">        response.headers().set(CONTENT_TYPE, mimeTypesMap.getContentType(file.getPath()));  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>流数据的传输处理</strong> </p>
<p>​        在基于流的传输里比如 <em>TCP/IP</em>，接收到的数据会先被存储到一个 <em>socket</em> 接收缓冲里。不 幸的是，基于流的传输并不是一个数据包队列，而是一个字节队列。即使你发送了 <em>2</em> 个独立 的数据包，操作系统也不会作为 <em>2</em> 个消息处理而仅仅是作为一连串的字节而言。因此这是不 能保证你远程写入的数据就会准确地读取。所以一个接收方不管他是客户端还是服务端，都 应该把接收到的数据整理成一个或者多个更有意思并且能够让程序的业务逻辑更好理解的 数据。 </p>
<p>在处理流数据粘包拆包时，可以使用下述处理方式： </p>
<p>使用定长数据处理，如：每个完整请求数据长度为 <em>8</em> 字节等。（<em>FixedLengthFrameDecoder</em>） </p>
<p>使用特殊分隔符的方式处理，如：每个完整请求数据末尾使用<em>’\0’</em>作为数据结束标记。（<em>DelimiterBasedFrameDecoder</em>） </p>
<p>使用自定义协议方式处理，如：<em>http</em> 协议格式等。 </p>
<p>使用 <em>POJO</em> 来替代传递的流数据，如：每个完整的请求数据都是一个 <em>RequestMessage</em> 对象，在 <em>Java</em> 语言中，使用 <em>POJO</em> 更符合语种特性，推荐使用。</p>
<p>转载至微信公众号《Java患者》。</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 并发和多线程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[关于fastjson解析后的属性排序问题解决方案]]></title>
      <url>/%E5%85%B3%E4%BA%8Efastjson%E8%A7%A3%E6%9E%90%E5%90%8E%E7%9A%84%E5%B1%9E%E6%80%A7%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html</url>
      <content type="html"><![CDATA[<h2 id="问题起因："><a href="#问题起因：" class="headerlink" title="问题起因："></a>问题起因：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String testJson = <span class="string">"&#123;\"lh_u\":32,\"ps\":7,\"qt\":24,\"ns\":87,\"gm\":11,\"dp\":2,\"lh_ua\":34,\"ft\":82,\"jzsj\":\"24时\",\"lg\":71,\"yt\":6,\"jzrq\":\"3月4日\",\"ba\":62&#125;"</span>;</span><br><span class="line">JSONObject jsonObject = JSON.parseObject(jsonString); ----- ①</span><br><span class="line">System.out.println(jsonObject.toJSONString());</span><br></pre></td></tr></table></figure>
<p>上述方法得到的jsonObject属性排序和字符串的字段排序是一样的，如果想对jsonObject的属性进行排序，可以做此处理：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JSONObject jsonObjectNew1 = JSON.parseObject(JSON.toJSONString(jsonObject,SerializerFeature.MapSortField));</span><br><span class="line">JSONObject jsonObjectNew2 = JSON.parseObject(JSON.toJSONString(jsonObject,SerializerFeature.MapSortField),Feature.OrderedField);</span><br></pre></td></tr></table></figure></p>
<p>将jsonObject转成按字母排序的字符串，然后再转成jsonObject对象，再次转成jsonObject时如果不加Feature.OrderedField，则jsonObject和①中的一样，加上则保持属性顺序不变。<br><span class="exturl" data-url="aHR0cHM6Ly93d3cub3NjaGluYS5uZXQvcXVlc3Rpb24vMjMzNjU2MF8yMjk0Nzg/c29ydD10aW1l" title="https://www.oschina.net/question/2336560_229478?sort=time">参考文章<i class="fa fa-external-link"></i></span></p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> fastjson </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hashcode详解]]></title>
      <url>/hashcode%E8%AF%A6%E8%A7%A3.html</url>
      <content type="html"><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>写这篇文章是因为在看hashMap源码时遇到有什么hashcode值，然后就去查，脑袋里面是有映像的，不就是在Object中有equals和hashcode方法嘛，这在学java基础的时候就遇到过，不过那时候无所谓，不懂就不懂，就一笔带过去了，然后到现在，又回过头来补本应该以前就搞清楚的问题，所以知道了一个道理，学习不是一个追求速度的事情，不懂就要去查清楚，弄明白，一步一个脚印，虽然刚开始可能会很慢，不过慢慢的，学习的多了，理解的多了，会越来越快的。越来越轻松，不至于现在还在补原来的知识。后悔也无事于补了，起码现在知道了这个道理，学习永远都不会迟，只要突然一天的醒悟，一切都会慢慢好起来的。　　<br>弄懂这知识点，查了很多博文，发现很多类似，我不知道哪个才是原著，所以复制一个我觉得比较好的，不过看了也有些迷惑，我会写下来。<br><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhhbmd5dWFuMTk4ODA2MDYvYXJ0aWNsZS9kZXRhaWxzLzUxMjQwMzcy" title="http://blog.csdn.net/zhangyuan19880606/article/details/51240372">引用博文<i class="fa fa-external-link"></i></span><br><a id="more"></a></p>
<h2 id="一、hashcode是什么？"><a href="#一、hashcode是什么？" class="headerlink" title="一、hashcode是什么？"></a>一、hashcode是什么？</h2><h3 id="1、hash和hash表是什么？"><a href="#1、hash和hash表是什么？" class="headerlink" title="1、hash和hash表是什么？　　　"></a>1、hash和hash表是什么？　　　</h3><p>想要知道这个hashcode，首先得知道hash，通过百度百科看一下</p>
<p>hash是一个函数，该函数中的实现就是一种算法，就是通过一系列的算法来得到一个hash值，这个时候，我们就需要知道另一个东西，hash表，通过hash算法得到的hash值就在这张hash表中，也就是说，hash表就是所有的hash值组成的，有很多种hash函数，也就代表着有很多种算法得到hash值，如上面截图的三种，等会我们就拿第一种来说。</p>
<h3 id="2、hashcode"><a href="#2、hashcode" class="headerlink" title="2、hashcode　"></a>2、hashcode　</h3><p>有了前面的基础，这里讲解就简单了，hashcode就是通过hash函数得来的，通俗的说，就是通过某一种算法得到的，hashcode就是在hash表中有对应的位置。每个对象都有hashcode，对象的hashcode怎么得来的呢？</p>
<p>首先一个对象肯定有物理地址，在别的博文中会hashcode说成是代表对象的地址，这里肯定会让读者形成误区，对象的物理地址跟这个hashcode地址不一样，hashcode代表对象的地址说的是对象在hash表中的位置，物理地址说的对象存放在内存中的地址，那么对象如何得到hashcode呢？通过对象的内部地址(也就是物理地址)转换成一个整数，然后该整数通过hash函数的算法就得到了hashcode，所以，hashcode是什么呢？就是在hash表中对应的位置。这里如果还不是很清楚的话，举个例子，hash表中有 hashcode为1、hashcode为2、(…)3、4、5、6、7、8这样八个位置，有一个对象A，A的物理地址转换为一个整数17(这是假如)，就通过直接取余算法，17%8=1，那么A的hashcode就为1，且A就在hash表中1的位置。肯定会有其他疑问，接着看下面，这里只是举个例子来让你们知道什么是hashcode的意义。</p>
<h2 id="二、hashcode有什么作用呢？"><a href="#二、hashcode有什么作用呢？" class="headerlink" title="二、hashcode有什么作用呢？"></a>二、hashcode有什么作用呢？</h2><p>前面说了这么多关于hash函数，和hashcode是怎么得来的，还有hashcode对应的是hash表中的位置，可能大家就有疑问，为什么hashcode不直接写物理地址呢，还要另外用一张hash表来代表对象的地址？接下来就告诉你hashcode的作用，</p>
<p>1、HashCode的存在主要是为了查找的快捷性，HashCode是用来在散列存储结构中确定对象的存储地址的(后半句说的用hashcode来代表对象就是在hash表中的位置)<br> 为什么hashcode就查找的更快，比如：我们有一个能存放1000个数这样大的内存中，在其中要存放1000个不一样的数字，用最笨的方法，就是存一个数字，就遍历一遍，看有没有相同得数，当存了900个数字，开始存901个数字的时候，就需要跟900个数字进行对比，这样就很麻烦，很是消耗时间，用hashcode来记录对象的位置，来看一下。hash表中有1、2、3、4、5、6、7、8个位置，存第一个数，hashcode为1，该数就放在hash表中1的位置，存到100个数字，hash表中8个位置会有很多数字了，1中可能有20个数字，存101个数字时，他先查hashcode值对应的位置，假设为1，那么就有20个数字和他的hashcode相同，他只需要跟这20个数字相比较(equals)，如果每一个相同，那么就放在1这个位置，这样比较的次数就少了很多，实际上hash表中有很多位置，这里只是举例只有8个，所以比较的次数会让你觉得也挺多的，实际上，如果hash表很大，那么比较的次数就很少很少了。  通过对原始方法和使用hashcode方法进行对比，我们就知道了hashcode的作用，并且为什么要使用hashcode了</p>
<h2 id="三、equals方法和hashcode的关系？"><a href="#三、equals方法和hashcode的关系？" class="headerlink" title="三、equals方法和hashcode的关系？"></a>三、equals方法和hashcode的关系？</h2><p>通过前面这个例子，大概可以知道，先通过hashcode来比较，如果hashcode相等，那么就用equals方法来比较两个对象是否相等，用个例子说明：上面说的hash表中的8个位置，就好比8个桶，每个桶里能装很多的对象，对象A通过hash函数算法得到将它放到1号桶中，当然肯定有别的对象也会放到1号桶中，如果对象B也通过算法分到了1号桶，那么它如何识别桶中其他对象是否和它一样呢，这时候就需要equals方法来进行筛选了。<br>1、如果两个对象equals相等，那么这两个对象的HashCode一定也相同<br> 2、如果两个对象的HashCode相同，不代表两个对象就相同，只能说明这两个对象在散列存储结构中，存放于同一个位置<br>这两条你们就能够理解了。</p>
<h2 id="四、为什么equals方法重写的话，建议也一起重写hashcode方法？"><a href="#四、为什么equals方法重写的话，建议也一起重写hashcode方法？" class="headerlink" title="四、为什么equals方法重写的话，建议也一起重写hashcode方法？"></a>四、为什么equals方法重写的话，建议也一起重写hashcode方法？</h2><p>（如果对象的equals方法被重写，那么对象的HashCode方法也尽量重写）举个例子，其实就明白了这个道理，比如：有个A类重写了equals方法，但是没有重写hashCode方法，看输出结果，对象a1和对象a2使用equals方法相等，按照上面的hashcode的用法，那么他们两个的hashcode肯定相等，但是这里由于没重写hashcode方法，他们两个hashcode并不一样，所以，我们在重写了equals方法后，尽量也重写了hashcode方法，通过一定的算法，使他们在equals相等时，也会有相同的hashcode值。</p>
<p>实例：现在来看一下String的源码中的equals方法和hashcode方法。这个类就重写了这两个方法，现在为什么需要重写这两个方法了吧？<br>equals方法：其实跟我上面写的那个例子是一样的原理，所以通过源码又知道了String的equals方法验证的是两个字符串的值是否一样。还有Double类也重写了这些方法。很多类有比较这类的，都重写了这两个方法，因为在所有类的父类Object中。equals的功能就是 “==”号的功能。你们还可以比较String对象的equals和==的区别啦。这里不再说明。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vd2hnay9wLzYwNzE2MTcuaHRtbA==" title="https://www.cnblogs.com/whgk/p/6071617.html">转载至<i class="fa fa-external-link"></i></span></p>
<p>　　　　　　　　</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[greenplum安装与部署（详细）]]></title>
      <url>/greenplum%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2%EF%BC%88%E8%AF%A6%E7%BB%86%EF%BC%89.html</url>
      <content type="html"><![CDATA[<h2 id="修改系统配置"><a href="#修改系统配置" class="headerlink" title="修改系统配置"></a>修改系统配置</h2><h3 id="1-1-gp服务器列表"><a href="#1-1-gp服务器列表" class="headerlink" title="1.1  gp服务器列表"></a>1.1  gp服务器列表</h3><p>192.168.7.11  hadoop01   主节点<br>192.168.7.12  hadoop02   数据节点1<br>192.168.7.13  hadoop03   数据节点2<br>192.168.7.14  hadoop04   主节点切换备份节点<br><a id="more"></a></p>
<h3 id="1-2-修改系统配置项"><a href="#1-2-修改系统配置项" class="headerlink" title="1.2 修改系统配置项"></a>1.2 修改系统配置项</h3><p>关闭SELINUX<br>vi /etc/selinux/config<br>SELINUX=disabled</p>
<h3 id="1-3-关闭防火墙"><a href="#1-3-关闭防火墙" class="headerlink" title="1.3 关闭防火墙"></a>1.3 关闭防火墙</h3><p>systemctl status firewalld<br>systemctl stop firewalld.service<br>systemctl disable firewalld.service</p>
<h3 id="1-4-修改内核配置参数-并执行-sysctl-p使之生效"><a href="#1-4-修改内核配置参数-并执行-sysctl-p使之生效" class="headerlink" title="1.4 修改内核配置参数,并执行 sysctl -p使之生效"></a>1.4 修改内核配置参数,并执行 sysctl -p使之生效</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/sysctl.conf</span><br><span class="line">kernel.shmmax = 500000000</span><br><span class="line">kernel.shmmni = 4096</span><br><span class="line">kernel.shmall = 4000000000</span><br><span class="line">kernel.sem = 2000 4096000 2000 2048</span><br><span class="line">kernel.sysrq = 1</span><br><span class="line">kernel.core_uses_pid = 1</span><br><span class="line">kernel.msgmnb = 65536</span><br><span class="line">kernel.msgmax = 65536</span><br><span class="line">kernel.msgmni = 2048</span><br><span class="line">net.ipv4.tcp_syncookies = 1</span><br><span class="line">net.ipv4.ip_forward = 0</span><br><span class="line">net.ipv4.conf.default.accept_source_route = 0</span><br><span class="line">net.ipv4.tcp_tw_recycle = 1</span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 4096</span><br><span class="line">net.ipv4.conf.all.arp_filter = 1</span><br><span class="line">net.ipv4.ip_local_port_range = 1025 65535</span><br><span class="line">net.core.netdev_max_backlog = 10000</span><br><span class="line">net.core.rmem_max = 2097152</span><br><span class="line">net.core.wmem_max = 2097152</span><br><span class="line">vm.overcommit_memory = 2  (服务器核数，根据实际情况修改参数)</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/security/limits.conf</span><br><span class="line">* soft nofile 65536</span><br><span class="line">* hard nofile 65536</span><br><span class="line">* soft nproc 131072</span><br><span class="line">* hard nproc 131072</span><br></pre></td></tr></table></figure>
<h3 id="1-5-配置集群中各节点hosts信息"><a href="#1-5-配置集群中各节点hosts信息" class="headerlink" title="1.5 配置集群中各节点hosts信息"></a>1.5 配置集群中各节点hosts信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/hosts</span><br><span class="line">192.168.7.11  hadoop01   </span><br><span class="line">192.168.7.12  hadoop02   </span><br><span class="line">192.168.7.13  hadoop03   </span><br><span class="line">192.168.7.14  hadoop04</span><br></pre></td></tr></table></figure>
<h2 id="安装greenplum-db"><a href="#安装greenplum-db" class="headerlink" title="安装greenplum-db"></a>安装greenplum-db</h2><h3 id="2-1-下载greenplum"><a href="#2-1-下载greenplum" class="headerlink" title="2.1 下载greenplum"></a>2.1 下载greenplum</h3><p><span class="exturl" data-url="aHR0cHM6Ly9ncmVlbnBsdW0uY24=" title="https://greenplum.cn">下载地址<i class="fa fa-external-link"></i></span><br>执行安装包：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh greenplum-db-6.1.0-rhel7-x86_64.rpm --nodeps --force</span><br></pre></td></tr></table></figure></p>
<h3 id="2-2-创建gpadmin用户"><a href="#2-2-创建gpadmin用户" class="headerlink" title="2.2 创建gpadmin用户"></a>2.2 创建gpadmin用户</h3><p>解压完成后以root身份创建gpadmin用户和组，用来管理greenplum-db<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">groupadd gpadmin                    # 创建分组    </span><br><span class="line">useradd gpadmin -g gpadmin            # 创建用户并分配组    </span><br><span class="line">passwd gpadmin                        # 为gpadmin分配密码   </span><br><span class="line"> cd /usr/local/greenplum-db</span><br><span class="line"> chown -R gpadmin:gpadmin greenplum-db/    </span><br><span class="line">chown -R gpadmin:gpadmin greenplum-cc-web/</span><br></pre></td></tr></table></figure></p>
<h3 id="2-3-创建配置文件"><a href="#2-3-创建配置文件" class="headerlink" title="2.3 创建配置文件"></a>2.3 创建配置文件</h3><h4 id="切换到gpadmin用户下"><a href="#切换到gpadmin用户下" class="headerlink" title="切换到gpadmin用户下"></a>切换到gpadmin用户下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">su - gpadmin   </span><br><span class="line">mkdir -p /usr/local/greenplum-db/gpconfigs  </span><br><span class="line">cd /usr/local/greenplum-db/gpconfigs</span><br></pre></td></tr></table></figure>
<h4 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vim hostfile_exkeys</span><br><span class="line">输入</span><br><span class="line">hadoop01</span><br><span class="line">hadoop02</span><br><span class="line">hadoop03</span><br><span class="line">hadoop04</span><br><span class="line">vi hostfile</span><br><span class="line">hadoop02</span><br><span class="line">hadoop03</span><br><span class="line">hadoop04</span><br></pre></td></tr></table></figure>
<h3 id="2-4-在gpadmin和root用户下添加环境变量"><a href="#2-4-在gpadmin和root用户下添加环境变量" class="headerlink" title="2.4 在gpadmin和root用户下添加环境变量"></a>2.4 在gpadmin和root用户下添加环境变量</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vi ~/.bashrc</span><br><span class="line"><span class="meta">#</span>#添加以下内容   </span><br><span class="line">export LD_LIBRARY_PATH=$GPHOME/lib    </span><br><span class="line">export MASTER_DATA_DIRECTORY=/home/gpadmin/gpdata/master/gpseg-1    </span><br><span class="line">source /usr/local/greenplum-db/greenplum_path.sh    </span><br><span class="line">source  /usr/local/greenplum-cc-web/gpcc_path.sh</span><br><span class="line">保存退出，执行下面语句使其生效</span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure>
<h3 id="2-5-切换到root用户"><a href="#2-5-切换到root用户" class="headerlink" title="2.5 切换到root用户"></a>2.5 切换到root用户</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gpssh-exkeys -f /usr/local/greenplum-db/gpconfigs/hostfile_exkeys    </span><br><span class="line"><span class="meta">#</span>拷贝mster节点公钥至各segment节点            </span><br><span class="line">gpseginstall -f /usr/local/greenplum-db/gpconfigs/hostfile_exkeys -p gpadmin</span><br></pre></td></tr></table></figure>
<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>gpssh-exkeys -f hostfile_exkeys  将会在master节点生成公私钥，并拷贝至hostfile_exkeys各segment节点，实现后续无密钥登陆<br>gpseginstall -f /usr/local/greenplum-db/gpconfigs/hostfile_exkeys -p gpadmin  使用默认用户名(gpadmin) 密码：gpadmin 在各segment节点安装Greenplum-db</p>
<h3 id="2-6-在master及各segment节点创建数据存储目录"><a href="#2-6-在master及各segment节点创建数据存储目录" class="headerlink" title="2.6 在master及各segment节点创建数据存储目录"></a>2.6 在master及各segment节点创建数据存储目录</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mkdir /home/gpadmin/gpdata/master</span><br><span class="line">cd /home/gpadmin/</span><br><span class="line">chown -R gpadmin:gpadmin gpdata/master</span><br><span class="line">gpssh -f /usr/local/greenplum-db/gpconfigs/hostfile -e "mkdir -p /home/gpadmin/gpdata/data1/primary;mkdir -p /home/gpadmin/gpdata/data2/primary”</span><br><span class="line">gpssh -f /usr/local/greenplum-db/gpconfigs/hostfile -e "mkdir -p /home/gpadmin/gpdata/data1/mirror;mkdir -p /home/gpadmin/gpdata/data2/mirror"</span><br><span class="line">gpssh -f /usr/local/greenplum-db/gpconfigs/hostfile -e "chown -R gpadmin:gpadmin /home/gpadmin/gpdata"</span><br><span class="line">gpssh -f /usr/local/greenplum-db/gpconfigs/hostfile_exkeys -v -e 'ntpd'</span><br></pre></td></tr></table></figure>
<h4 id="切换到gpadmin用户下-初始化数据库集群"><a href="#切换到gpadmin用户下-初始化数据库集群" class="headerlink" title="切换到gpadmin用户下,初始化数据库集群"></a>切换到gpadmin用户下,初始化数据库集群</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">su - gpadmin </span><br><span class="line">cd /usr/local/greenplum-db/</span><br><span class="line"> cp /usr/local/greenplum-db/docs/cli_help/gpconfigs/gpinitsystem_config /usr/local/greenplum-db/gpconfigs/gpinitsystem_config</span><br><span class="line"> vi /usr/local/greenplum-db/gpconfigs/gpinitsystem_config</span><br><span class="line"><span class="meta">#</span>##修改以下内容</span><br><span class="line">MASTER_HOSTNAME=mdw</span><br><span class="line">PORT_BASE=40000</span><br><span class="line">declare -a DATA_DIRECTORY=(/home/gpadmin/gpdata/data1/primary /home/gpadmin/gpdata/data1/primary /home/gpadmin/gpdata/data2/primary /home/gpadmin/gpdata/data2/primary)</span><br><span class="line">MASTER_DIRECTORY=/home/gpadmin/gpdata/master</span><br><span class="line">MASTER_PORT=5432</span><br><span class="line">MIRROR_PORT_BASE=50000</span><br><span class="line">REPLICATION_PORT_BASE=41000</span><br><span class="line">MIRROR_REPLICATION_PORT_BASE=51000</span><br><span class="line">declare -a MIRROR_DATA_DIRECTORY=(/home/gpadmin/gpdata/data1/mirror /home/gpadmin/gpdata/data1/mirror /home/gpadmin/gpdata/data2/mirror /home/gpadmin/gpdata/data2/mirror)</span><br><span class="line">DATABASE_NAME=gpdb</span><br><span class="line">MACHINE_LIST_FILE=/usr/local/greenplum-db/gpconfigs/hostfile</span><br></pre></td></tr></table></figure>
<h3 id="2-7-配置修改完成之后，执行以下命令初始化数据库"><a href="#2-7-配置修改完成之后，执行以下命令初始化数据库" class="headerlink" title="2.7 配置修改完成之后，执行以下命令初始化数据库"></a>2.7 配置修改完成之后，执行以下命令初始化数据库</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpinitsystem -c /usr/local/greenplum-db/gpconfigs/gpinitsystem_config -h /usr/local/greenplum-db/gpconfigs/hostfile</span><br></pre></td></tr></table></figure>
<h3 id="2-8-psql修改数据库密码"><a href="#2-8-psql修改数据库密码" class="headerlink" title="2.8 psql修改数据库密码"></a>2.8 psql修改数据库密码</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">psql -d gpdb    </span><br><span class="line">gpdb=# alter user gpadmin with password 'gpadmin'     </span><br><span class="line">gpdb=# \q    </span><br><span class="line">然后，重启greenplumdb集群</span><br><span class="line">gpstop -a</span><br><span class="line">gpstart -a</span><br></pre></td></tr></table></figure>
<h3 id="2-9-使用pgadmin，navicat-等工具连接"><a href="#2-9-使用pgadmin，navicat-等工具连接" class="headerlink" title="2.9 使用pgadmin，navicat 等工具连接"></a>2.9 使用pgadmin，navicat 等工具连接</h3><p>连接时，如果登录不成功，一般报错如下样子：<br> psql: FATAL:  no pg_hba.conf entry for host “192.168.xxx.xxx”,<br>表示访问权限不够<br>修改文件/home/gpadmin/gpdata/master/gpseg-1/pg_hba.conf</p>
]]></content>
      
        <categories>
            
            <category> 大数据 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> greenplum </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[git配置多个SSH-Key]]></title>
      <url>/git%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AASSH-Key.html</url>
      <content type="html"><![CDATA[<h1 id="1、生成一个公司用的SSH-Key"><a href="#1、生成一个公司用的SSH-Key" class="headerlink" title="1、生成一个公司用的SSH-Key"></a>1、生成一个公司用的SSH-Key</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ssh-keygen -t rsa -C "youremail@yourcompany.com” -f ~/.ssh/id-rsa</span><br></pre></td></tr></table></figure>
<p>在~/.ssh/目录会生成id-rsa和id-rsa.pub私钥和公钥。 我们将id-rsa.pub中的内容粘帖到公司gitlab服务器的SSH-key的配置中。<br><a id="more"></a></p>
<h1 id="2、-生成一个github用的SSH-Key"><a href="#2、-生成一个github用的SSH-Key" class="headerlink" title="2、 生成一个github用的SSH-Key"></a>2、 生成一个github用的SSH-Key</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ssh-keygen -t rsa -C "youremail@your.com” -f ~/.ssh/github-rsa</span><br></pre></td></tr></table></figure>
<p>在~/.ssh/目录会生成github-rsa和github-rsa.pub私钥和公钥。 我们将github-rsa.pub中的内容粘帖到github服务器的SSH-key的配置中。</p>
<h1 id="3、添加私钥"><a href="#3、添加私钥" class="headerlink" title="3、添加私钥"></a>3、添加私钥</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ssh-add ~/.ssh/id_rsa $ ssh-add ~/.ssh/github_rsa</span><br></pre></td></tr></table></figure>
<p>如果执行ssh-add时提示”Could not open a connection to your authentication agent”，可以现执行命令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ssh-agent bash</span><br></pre></td></tr></table></figure></p>
<p>然后再运行ssh-add命令。<br>可以通过 ssh-add -l 来确私钥列表<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ssh-add -l</span><br></pre></td></tr></table></figure></p>
<p>可以通过 ssh-add -D 来清空私钥列表<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ssh-add -D</span><br></pre></td></tr></table></figure></p>
<h1 id="4、修改配置文件"><a href="#4、修改配置文件" class="headerlink" title="4、修改配置文件"></a>4、修改配置文件</h1><p>在 ~/.ssh 目录下新建一个config文件<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch config</span><br></pre></td></tr></table></figure></p>
<p>添加内容：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> gitlab</span><br><span class="line">Host gitlab.com</span><br><span class="line">    HostName gitlab.com</span><br><span class="line">    PreferredAuthentications publickey</span><br><span class="line">    IdentityFile ~/.ssh/id_rsa</span><br><span class="line"><span class="meta">#</span> github</span><br><span class="line">Host github.com</span><br><span class="line">    HostName github.com</span><br><span class="line">    PreferredAuthentications publickey</span><br><span class="line">    IdentityFile ~/.ssh/github_rsa</span><br></pre></td></tr></table></figure></p>
<h1 id="5、测试"><a href="#5、测试" class="headerlink" title="5、测试"></a>5、测试</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ssh -T git@github.com</span><br></pre></td></tr></table></figure>
<p>输出<br>Hi stefzhlg! You’ve successfully authenticated, but GitHub does not provide shell access.</p>
]]></content>
      
        <categories>
            
            <category> 系统 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> github </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[windows添加公钥后，无法克隆的问题解决]]></title>
      <url>/Permission.html</url>
      <content type="html"><![CDATA[<p>背景：windows下添加公钥后，无法克隆github 上的文件，报错Permission denied (publickey). fatal: Could not read from remote repository.<br>　　博主在github上下载tiny face的的源代码的时候，遇到git clone命令为：git clone –recursive git@github.com:peiyunh/tiny.git<br>　　而当我在ternimal下执行这条语句的时候，出现错误：<br>　　Permissiondenied (publickey).<br>　　fatal:Could not read from remote repository.<br>　　Pleasemake sure you have the correct access rights<br>　　and the repository exists.</p>
<a id="more"></a>
<p>　　但是其实执行命令：git clone git@github.com:peiyunh/tiny.git 是没有问题的（不加–recursive参数），于是百度了一番，我理解的是原因是由于你在本地（或者服务器上）没有生成ssh key，你可以在ternimal下执行：<br>　　cd ~/.ssh ls来查看是否有文件id_rsa以及文件id_rsa.pub，如下图所示：（我的已经生成了，所以我ls后会显示。）<br>　　下面记录下解决办法：<br>　　1.首先，如果你没有ssh key的话，在ternimal下输入命令：ssh-keygen -t rsa -C “youremail@example.com”， youremail@example.com改为自己的邮箱即可，途中会让你输入密码啥的，不需要管，一路回车即可，会生成你的ssh key。（如果重新生成的话会覆盖之前的ssh key。）<br>　　2.然后再ternimal下执行命令：<br>　　ssh -v git@github.com<br>　　最后两句会出现：<br>　　No more authentication methods to try.<br>　　Permission denied (publickey).<br>　　3.这时候再在ternimal下输入：<br>　　ssh-agent -s<br>　　然后会提示类似的信息：<br>　　SSH_AUTH_SOCK=/tmp/ssh-GTpABX1a05qH/agent.404; export SSH_AUTH_SOCK;<br>　　SSH_AGENT_PID=13144; export SSH_AGENT_PID;<br>　　echo Agent pid 13144;<br>　　4.接着再输入：<br>　　ssh-add ~/.ssh/id_rsa<br>　　这时候应该会提示：<br>　　Identity added: …（这里是一些ssh key文件路径的信息）<br>　　（注意）如果出现错误提示：<br>　　Could not open a connection to your authentication agent.<br>　　请执行命令：eval <code>ssh-agent -s</code>后继续执行命令 ssh-add ~/.ssh/id_rsa，这时候一般没问题啦。<br>　　5.打开你刚刚生成的id_rsa.pub，将里面的内容复制，进入你的github账号，在settings下，SSH and GPG keys下new SSH key，title随便取一个名字，然后将id_rsa.pub里的内容复制到Key中，完成后Add SSH Key。<br>　　6.最后一步，验证Key<br>　　在ternimal下输入命令：<br>　　ssh -T git@github.com<br>　　提示：Hi xxx! You’ve successfully authenticated, but GitHub does not provide shell  access.<br>　　这时候你的问题就解决啦，可以使用命令 git clone –recursive git@github.com:peiyunh/tiny.git 去下载你的代码啦。</p>
<p>　　</p>
]]></content>
      
        <categories>
            
            <category> 系统 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> github </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[kafka基本操作]]></title>
      <url>/kafka%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C.html</url>
      <content type="html"><![CDATA[<h2 id="kafka基本操作："><a href="#kafka基本操作：" class="headerlink" title="kafka基本操作："></a>kafka基本操作：</h2><h2 id="查看topic主题："><a href="#查看topic主题：" class="headerlink" title="查看topic主题："></a>查看topic主题：</h2><p>kafka-topics.sh –list –zookeeper node1:2181,node2:2181,node3:2181</p>
<h2 id="查看分区："><a href="#查看分区：" class="headerlink" title="查看分区："></a>查看分区：</h2><p>kafka-topics.sh –zookeeper node2:2181,node3:2181,node4:2181  –describe –topic  MotorVehicle<br>kafka-topics.sh –zookeeper node2:2181,node3:2181,node4:2181  –describe –topic  WifiRecord<br>kafka-topics.sh –zookeeper node2:2181,node3:2181,node4:2181  –describe –topic  ImsiRecord<br><a id="more"></a></p>
<h2 id="创建topic主题："><a href="#创建topic主题：" class="headerlink" title="创建topic主题："></a>创建topic主题：</h2><p>kafka-topics.sh –create –zookeeper node1:2181,node2:2181,node3:2181 –replication-factor 1 –partitions 1 –topic MotorImsi</p>
<h2 id="删除主题："><a href="#删除主题：" class="headerlink" title="删除主题："></a>删除主题：</h2><p>kafka-topics.sh –delete –zookeeper node1:2181,node2:2181,node3:2181 –topic Test004</p>
<h2 id="开启生产者：（注意kafka所在节点）目前都是单节点"><a href="#开启生产者：（注意kafka所在节点）目前都是单节点" class="headerlink" title="开启生产者：（注意kafka所在节点）目前都是单节点"></a>开启生产者：（注意kafka所在节点）目前都是单节点</h2><p>kafka-console-producer.sh –broker-list node3:6667 –topic MotorWifi</p>
<h2 id="开启消费者："><a href="#开启消费者：" class="headerlink" title="开启消费者："></a>开启消费者：</h2><p>kafka-console-consumer.sh –bootstrap-server node1:6667,node2:6667,node3:6667 –topic Test003 –from-beginning</p>
<h2 id="kafka中默认消息的保留时间是7天，若想更改，需在配置文件"><a href="#kafka中默认消息的保留时间是7天，若想更改，需在配置文件" class="headerlink" title="kafka中默认消息的保留时间是7天，若想更改，需在配置文件"></a>kafka中默认消息的保留时间是7天，若想更改，需在配置文件</h2><p>server.properties里更改选项：<br>log.retention.hours=168<br>但是有的时候我们需要对某一个主题的消息存留的时间进行变更，而不影响其他主题。</p>
<h2 id="可以使用命令："><a href="#可以使用命令：" class="headerlink" title="可以使用命令："></a>可以使用命令：</h2><p>kafka-configs.sh –zookeeper localhost:2181 –entity-type topics –entity-name topicName –alter –add-config log.retention.hours=120<br>使得主题的留存时间保存为5天</p>
<h2 id="如果报错的话，可以将时间单位更改成毫秒："><a href="#如果报错的话，可以将时间单位更改成毫秒：" class="headerlink" title="如果报错的话，可以将时间单位更改成毫秒："></a>如果报错的话，可以将时间单位更改成毫秒：</h2><p>kafka-configs.sh –zookeeper localhost:2181 –entity-type topics –entity-name test –alter –add-config retention.ms=43200000</p>
<h2 id="将jar包放入后台运行："><a href="#将jar包放入后台运行：" class="headerlink" title="将jar包放入后台运行："></a>将jar包放入后台运行：</h2><p>nohup java -jar  xinyi_kafka_consumer-0.0.1-SNAPSHOT-imsi.jar &gt;&gt; xinyi_kafka_consumer-0.0.1-SNAPSHOT-imsi.out 2&gt;&amp;1 &amp;</p>
<p>nohup java -jar  xinfo-spark-scheduler.jar  &gt;&gt; xinfo-spark-scheduler.out 2&gt;&amp;1 &amp;</p>
<p>nohup java -jar  xinyi_kafka_consumer_video-0.0.1-SNAPSHOT.jar &gt;&gt; xinyi_kafka_consumer_video-0.0.1-SNAPSHOT.out 2&gt;&amp;1 &amp;</p>
]]></content>
      
        <categories>
            
            <category> 大数据 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> kafKa </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[kafka如何彻底删除topic及数据]]></title>
      <url>/kafka%E5%A6%82%E4%BD%95%E5%BD%BB%E5%BA%95%E5%88%A0%E9%99%A4topic%E5%8F%8A%E6%95%B0%E6%8D%AE.html</url>
      <content type="html"><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>删除kafka topic及其数据，严格来说并不是很难的操作。但是，往往给kafka 使用者带来诸多问题。项目组之前接触过多个开发者，发现都会偶然出现无法彻底删除kafka的情况。本文总结多个删除kafka topic的应用场景，总结一套删除kafka topic的标准操作方法。</p>
<h2 id="step1："><a href="#step1：" class="headerlink" title="step1："></a>step1：</h2><p>如果需要被删除topic 此时正在被程序 produce和consume，则这些生产和消费程序需要停止。<br>因为如果有程序正在生产或者消费该topic，则该topic的offset信息一致会在broker更新。调用kafka delete命令则无法删除该topic。<br>同时，需要设置 auto.create.topics.enable = false，默认设置为true。如果设置为true，则produce或者fetch 不存在的topic也会自动创建这个topic。这样会给删除topic带来很多意向不到的问题。<br>所以，这一步很重要，必须设置auto.create.topics.enable = false，并认真把生产和消费程序彻底全部停止。<br><a id="more"></a></p>
<h2 id="step2："><a href="#step2：" class="headerlink" title="step2："></a>step2：</h2><p>server.properties 设置 delete.topic.enable=true<br>如果没有设置 delete.topic.enable=true，则调用kafka 的delete命令无法真正将topic删除，而是显示（marked for deletion）</p>
<h2 id="step3："><a href="#step3：" class="headerlink" title="step3："></a>step3：</h2><p>调用命令删除topic：<br>./bin/kafka-topics –delete –zookeeper 【zookeeper server:port】 –topic 【topic name】</p>
<h2 id="step4："><a href="#step4：" class="headerlink" title="step4："></a>step4：</h2><p>删除kafka存储目录（server.properties文件log.dirs配置，默认为”/data/kafka-logs”）相关topic的数据目录。<br>注意：如果kafka 有多个 broker，且每个broker 配置了多个数据盘（比如 /data/kafka-logs,/data1/kafka-logs …），且topic也有多个分区和replica，则需要对所有broker的所有数据盘进行扫描，删除该topic的所有分区数据。</p>
<p>一般而言，经过上面4步就可以正常删除掉topic和topic的数据。但是，如果经过上面四步，还是无法正常删除topic，则需要对kafka在zookeeer的存储信息进行删除。具体操作如下：<br>（注意：以下步骤里面，kafka在zk里面的节点信息是采用默认值，如果你的系统修改过kafka在zk里面的节点信息，则需要根据系统的实际情况找到准确位置进行操作）</p>
<h2 id="step5："><a href="#step5：" class="headerlink" title="step5："></a>step5：</h2><p>找一台部署了zk的服务器，使用命令：<br>bin/zkCli.sh -server 【zookeeper server:port】<br>登录到zk shell，然后找到topic所在的目录：ls /brokers/topics，找到要删除的topic，然后执行命令：<br>rmr /brokers/topics/【topic name】<br>即可，此时topic被彻底删除。<br>如果topic 是被标记为 marked for deletion，则通过命令 ls /admin/delete_topics，找到要删除的topic，然后执行命令：<br>rmr /admin/delete_topics/【topic name】<br>备注：<br>网络上很多其它文章还说明，需要删除topic在zk上面的消费节点记录、配置节点记录，比如：<br>rmr /consumers/【consumer-group】<br>rmr /config/topics/【topic name】<br>其实正常情况是不需要进行这两个操作的，如果需要，那都是由于操作不当导致的。比如step1停止生产和消费程序没有做，step2没有正确配置。也就是说，正常情况下严格按照step1 – step5 的步骤，是一定能够正常删除topic的。<br>step6：<br>完成之后，调用命令：<br>./bin/kafka-topics.sh –list –zookeeper 【zookeeper server:port】<br>查看现在kafka的topic信息。正常情况下删除的topic就不会再显示。<br>但是，如果还能够查询到删除的topic，则重启zk和kafka即可。</p>
]]></content>
      
        <categories>
            
            <category> 大数据 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Kafka </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[修改kafka保留天数对数据入库的影响]]></title>
      <url>/%E4%BF%AE%E6%94%B9kafka%E4%BF%9D%E7%95%99%E5%A4%A9%E6%95%B0%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%85%A5%E5%BA%93%E7%9A%84%E5%BD%B1%E5%93%8D.html</url>
      <content type="html"><![CDATA[<h2 id="场景介绍："><a href="#场景介绍：" class="headerlink" title="场景介绍："></a>场景介绍：</h2><p>Kafka集群三个broker，同时有一个生产者和一个消费者，生产者producer 已生产2个多小时约10万条数据，同时消费者将数据插入hbase中。</p>
<h2 id="测试："><a href="#测试：" class="headerlink" title="测试："></a>测试：</h2><p>1、打开ambari操作界面，在kafka配置页下修改保留天数的参数log.retention.hours 为1小时，同时修改文件大小segment为10000。（此处数值的设置，为了方便测试）<br><a id="more"></a><br><img src="https://hexoblog-1254111960.cos.ap-guangzhou.myqcloud.com/%E4%BF%AE%E6%94%B9kafka%E4%BF%9D%E7%95%99%E5%A4%A9%E6%95%B0%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%85%A5%E5%BA%93%E7%9A%84%E5%BD%B1%E5%93%8D.png" alt=""><br><span class="exturl" data-url="aHR0cHM6Ly9oZXhvYmxvZy0xMjU0MTExOTYwLmNvcy5hcC1ndWFuZ3pob3UubXlxY2xvdWQuY29tLyVFNCVCRiVBRSVFNiU5NCVCOWthZmthJUU0JUJGJTlEJUU3JTk1JTk5JUU1JUE0JUE5JUU2JTk1JUIwJUU1JUFGJUI5JUU2JTk1JUIwJUU2JThEJUFFJUU1JTg1JUE1JUU1JUJBJTkzJUU3JTlBJTg0JUU1JUJEJUIxJUU1JTkzJThELnBuZw==" title="https://hexoblog-1254111960.cos.ap-guangzhou.myqcloud.com/%E4%BF%AE%E6%94%B9kafka%E4%BF%9D%E7%95%99%E5%A4%A9%E6%95%B0%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%85%A5%E5%BA%93%E7%9A%84%E5%BD%B1%E5%93%8D.png">https://hexoblog-1254111960.cos.ap-guangzhou.myqcloud.com/%E4%BF%AE%E6%94%B9kafka%E4%BF%9D%E7%95%99%E5%A4%A9%E6%95%B0%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%85%A5%E5%BA%93%E7%9A%84%E5%BD%B1%E5%93%8D.png<i class="fa fa-external-link"></i></span><br>2、修改完参数之后，逐一重启broker，在重启的过程中，在消费者控制台可以看到如下错误：<br><img src="https://hexoblog-1254111960.cos.ap-guangzhou.myqcloud.com/%E4%BF%AE%E6%94%B9kafka%E4%BF%9D%E7%95%99%E5%A4%A9%E6%95%B0%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%85%A5%E5%BA%93%E7%9A%84%E5%BD%B1%E5%93%8D.13.png" alt=""><br>重启完之后，错误消失。</p>
<p>3、测试结果：<br>当把保留天数修改为1小时，则kafka中的数据只保留最近1小时的数据，早于1小时之前的数据将被删除。<br>注意：如果被删除的数据没有被消费，则该被删除的数据不会被插入库中。所以，修改参数之前，确保数据已经消费过，并入库。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[创建分布式图数据库JanusGraph对象的两种方法]]></title>
      <url>/%E5%88%9B%E5%BB%BA%E5%88%86%E5%B8%83%E5%BC%8F%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93JanusGraph%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95.html</url>
      <content type="html"><![CDATA[<p>JanusGraph 是一个分布式图数据库，相对于neo4j可进行横向扩展，且存储和图引擎分离，架构优美，本文将介绍JanusGraph的两种创建方式。<br><a id="more"></a><br>1、添加Maven依赖<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.janusgraph<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>janusgraph-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">     </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.janusgraph<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>janusgraph-cassandra<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">     </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.janusgraph<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>janusgraph-es<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>有以下两种方式构建JanusGraph对象<br>1、通过配置文件构建图对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JanusGraph graph = JanusGraphFactory.open(<span class="string">"janusgraph/conf/janusgraph-cassandra-es.properties"</span>);</span><br><span class="line">graph.close();</span><br></pre></td></tr></table></figure></p>
<p>2、通过Configuration构建图对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.configuration.BaseConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.apache.tinkerpop.gremlin.process.traversal.dsl.graph.GraphTraversalSource;</span><br><span class="line"><span class="keyword">import</span> org.janusgraph.core.JanusGraph;</span><br><span class="line"><span class="keyword">import</span> org.janusgraph.core.JanusGraphFactory;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BaseConfiguration config = <span class="keyword">new</span> BaseConfiguration();</span><br><span class="line"></span><br><span class="line">        <span class="comment">////////////使用内存作为存储端</span></span><br><span class="line">        <span class="comment">//config.setProperty("storage.backend", "inmemory");</span></span><br><span class="line">        <span class="comment">//////////使用cassandra+es作为存储端</span></span><br><span class="line">        config.setProperty(<span class="string">"storage.backend"</span>, <span class="string">"cassandrathrift"</span>);</span><br><span class="line">        config.setProperty(<span class="string">"storage.cassandra.keyspace"</span>, <span class="string">"janus"</span>);</span><br><span class="line">        config.setProperty(<span class="string">"storage.hostname"</span>, <span class="string">"127.0.0.1"</span>);</span><br><span class="line">        config.setProperty(<span class="string">"index.search.backend"</span>, <span class="string">"elasticsearch"</span>);</span><br><span class="line">        config.setProperty(<span class="string">"index.search.hostname"</span>, <span class="string">"127.0.0.1"</span>);</span><br><span class="line"> </span><br><span class="line">        config.setProperty(<span class="string">"cache.db-cache"</span>, <span class="string">"true"</span>);</span><br><span class="line">        config.setProperty(<span class="string">"cache.db-cache-time"</span>, <span class="string">"300000"</span>);</span><br><span class="line">        config.setProperty(<span class="string">"cache.db-cache-size"</span>, <span class="string">"0.5"</span>);</span><br><span class="line">        ;</span><br><span class="line"></span><br><span class="line">        JanusGraph graph = JanusGraphFactory.open(config);</span><br><span class="line">        GraphTraversalSource g = graph.traversal();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//其它逻辑代码</span></span><br><span class="line"> </span><br><span class="line">        g.tx().rollback();</span><br><span class="line">        graph.close();</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 图数据库 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JanusGraph </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JanusGraph系统架构]]></title>
      <url>/JanusGraph%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84.html</url>
      <content type="html"><![CDATA[<p>JanusGraph是一个图形数据库引擎。 JanusGraph本身专注于压缩图序列化、丰富图数据建模、高效的查询执行。 此外，JanusGraph利用Hadoop进行图分析和批处理。JanusGraph为数据持久化，数据索引和客户端访问实现了强大的模块化接口。 JanusGraph的模块化架构使其能够与各种存储，索引和客户端技术进行互操作; 这也使得JanusGraph升级对应的组件过程变得更加简单。<br><a id="more"></a><br>在JanusGraph和磁盘之间有一个或多个存储和索引适配器。 JanusGraph标配以下适配器，但JanusGraph的模块化架构支持第三方适配器。</p>
<h3 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储:"></a>数据存储:</h3><p><span class="exturl" data-url="aHR0cHM6Ly9jYXNzYW5kcmEuYXBhY2hlLm9yZy8=" title="https://cassandra.apache.org/">Apache Cassandra<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9oYmFzZS5hcGFjaGUub3JnLw==" title="https://hbase.apache.org/">Apache HBase<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cub3JhY2xlLmNvbS90ZWNobmV0d29yay9kYXRhYmFzZS9iZXJrZWxleWRiL292ZXJ2aWV3L2luZGV4LTA5MzQwNS5odG1s" title="https://www.oracle.com/technetwork/database/berkeleydb/overview/index-093405.html">Oracle Berkeley DB Java企业版<i class="fa fa-external-link"></i></span></p>
<h3 id="索引，用于加快访问速度并支持更复杂的查询语句"><a href="#索引，用于加快访问速度并支持更复杂的查询语句" class="headerlink" title="索引，用于加快访问速度并支持更复杂的查询语句:"></a>索引，用于加快访问速度并支持更复杂的查询语句:</h3><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuZWxhc3RpYy5jby9jbi9wcm9kdWN0cy9lbGFzdGljc2VhcmNoLw==" title="https://www.elastic.co/cn/products/elasticsearch/">Elasticsearch<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9sdWNlbmUuYXBhY2hlLm9yZy9zb2xyLw==" title="https://lucene.apache.org/solr/">Apache Solr<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9sdWNlbmUuYXBhY2hlLm9yZy8=" title="https://lucene.apache.org/">Apache Lucene<i class="fa fa-external-link"></i></span><br>总体来讲，应用程序可以通过两种方式与JanusGraph进行交互：<br>嵌在应用程序中的JanusGraph在同一个JVM中执行Gremlin语句。 查询任务、JanusGraph缓存和事务处理都在同一个JVM中，而后端数据检索可能是在本地或远程。<br>通过向服务器提交Gremlin查询语句来与本地或远程JanusGraph实例交互。 JanusGraph本身支持Apache TinkerPop栈的Gremlin Server组件。</p>
<h3 id="图-2-1-高层JanusGraph架构和上下文"><a href="#图-2-1-高层JanusGraph架构和上下文" class="headerlink" title="图 2.1. 高层JanusGraph架构和上下文"></a>图 2.1. 高层JanusGraph架构和上下文</h3><p><img src="https://hexoblog-1254111960.cos.ap-guangzhou.myqcloud.com/520181017214825zz7z.png" alt=""></p>
]]></content>
      
        <categories>
            
            <category> 图数据库 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JanusGraph </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[多节点时间同步]]></title>
      <url>/%E5%A4%9A%E8%8A%82%E7%82%B9%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5.html</url>
      <content type="html"><![CDATA[<p>linux 系统有两个时钟：一个是硬件时钟，即BIOS时间；另一个是系统时钟，是linux系统Kernel（内核）时间。<br>系统开启时，系统会读取硬件时间，设置系统时间。因此，设置了系统时间，重启时会失效。要想永久更改时间，可以先同步系统时间（基于网络时间，准确性较高），再同步系统时间。<br><a id="more"></a></p>
<h2 id="第一种情况-：有网"><a href="#第一种情况-：有网" class="headerlink" title="第一种情况 ：有网"></a>第一种情况 ：有网</h2><p>以网络时间为准校验</p>
<h3 id="（1）查看时区"><a href="#（1）查看时区" class="headerlink" title="（1）查看时区"></a>（1）查看时区</h3><p>date    – 查看系统时间<br>[root@develop Asia]# date -R<br>Fri, 22 Mar 2019 14:11:10 +0800      – +0800  代表是东八区，如果不是，自行更改到东八区</p>
<h3 id="（2）安装ntpdate工具"><a href="#（2）安装ntpdate工具" class="headerlink" title="（2）安装ntpdate工具"></a>（2）安装ntpdate工具</h3><p>yum install ntpdate</p>
<h3 id="（3）同步时间，用的是阿里云的服务器"><a href="#（3）同步时间，用的是阿里云的服务器" class="headerlink" title="（3）同步时间，用的是阿里云的服务器"></a>（3）同步时间，用的是阿里云的服务器</h3><p>systemctl stop  ntpd         – 停掉ntpd 服务，使 ntpdate 可以运行<br>ntpdate ntp1.aliyun.com<br>或者 ntpdate time.windows.com<br>ntpdate asia.pool.ntp.org<br>ntpdate time.nuri.net</p>
<h3 id="（4）同步硬件时间"><a href="#（4）同步硬件时间" class="headerlink" title="（4）同步硬件时间"></a>（4）同步硬件时间</h3><p>hwclock  查看硬件时间<br>hwclock –systohc –localtime     – 同步硬件时间</p>
<h3 id="（5）永久生效"><a href="#（5）永久生效" class="headerlink" title="（5）永久生效"></a>（5）永久生效</h3><p>hwclock -w<br>systemctl start  ntpd    – 结束完之后 ，开启ntpd</p>
<h2 id="第二种情况-：没有网络"><a href="#第二种情况-：没有网络" class="headerlink" title="第二种情况 ：没有网络"></a>第二种情况 ：没有网络</h2><p>这种同步时间的方法，很适合在无网的情况下，同步机器集群时间<br>下面一起操作一遍。<br>如果  有两台机器，选择其中一台机器A，作为服务端，机器B，作为客户端</p>
<h3 id="（1）修改服务端A"><a href="#（1）修改服务端A" class="headerlink" title="（1）修改服务端A"></a>（1）修改服务端A</h3><h4 id="①-修改配置文件"><a href="#①-修改配置文件" class="headerlink" title="① 修改配置文件"></a>① 修改配置文件</h4><p>[root@hanadevelop Asia]# vi  /etc/ntp.conf</p>
<h4 id="②重启ntpd"><a href="#②重启ntpd" class="headerlink" title="②重启ntpd"></a>②重启ntpd</h4><p>systemctl restart ntpd   – 要保证ntpd 服务开启，不然其它机器不能同步该机器的时间</p>
<h3 id="（2）修改客户端机器B"><a href="#（2）修改客户端机器B" class="headerlink" title="（2）修改客户端机器B"></a>（2）修改客户端机器B</h3><h4 id="①修改配置"><a href="#①修改配置" class="headerlink" title="①修改配置"></a>①修改配置</h4><p>[root@develop Asia]# vi  /etc/ntp.conf</p>
<h4 id="②"><a href="#②" class="headerlink" title="②"></a>②</h4><p>[root@demo sysconfig]# systemctl restart ntpd<br>[root@demo sysconfig]# systemctl enable ntpd<br>[root@demo sysconfig]# systemctl stop  ntpd</p>
<h3 id="（3）测试"><a href="#（3）测试" class="headerlink" title="（3）测试"></a>（3）测试</h3><h4 id="①修改机器A的时间"><a href="#①修改机器A的时间" class="headerlink" title="①修改机器A的时间"></a>①修改机器A的时间</h4><p>[root@hanadevelop Asia]# date -s ‘2019-3-22 17:00:11’<br>2019年 03月 22日 星期五 17:00:11 CST</p>
<h4 id="②同步机器B的时间"><a href="#②同步机器B的时间" class="headerlink" title="②同步机器B的时间"></a>②同步机器B的时间</h4><p>查看同步完成</p>
<h4 id="③-同步硬件时间"><a href="#③-同步硬件时间" class="headerlink" title="③ 同步硬件时间"></a>③ 同步硬件时间</h4><p>hwclock –systohc –localtime     – 同步硬件时间<br>hwclock -w     – 永久生效</p>
]]></content>
      
        <categories>
            
            <category> 大数据 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hadoop </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[FastJson反序列化为什么用TypeReference]]></title>
      <url>/FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8TypeReference.html</url>
      <content type="html"><![CDATA[<p>泛型序列化非TypeReference code：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Person&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">    map.put(<span class="string">"one"</span>, <span class="keyword">new</span> Person(<span class="string">"zhangsan"</span>));</span><br><span class="line">    map.put(<span class="string">"two"</span>, <span class="keyword">new</span> Person(<span class="string">"lisi"</span>));</span><br><span class="line">    String jsonStr = JSON.toJSONString(map);</span><br><span class="line">    <span class="keyword">byte</span>[] bytes = jsonStr.getBytes();</span><br><span class="line">    String json = <span class="keyword">new</span> String(bytes);</span><br><span class="line">    Map&lt;String, Person&gt; res = JSON.parseObject(json, Map.class);</span><br><span class="line">    System.out.println(res.get(<span class="string">"one"</span>));</span><br><span class="line">    System.out.println(res.get(<span class="string">"one"</span>).getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>输出：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.lang.reflect.InvocationTargetException</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:<span class="number">62</span>)</span><br><span class="line">	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="number">43</span>)</span><br><span class="line">	at java.lang.reflect.Method.invoke(Method.java:<span class="number">498</span>)</span><br><span class="line">	at com.intellij.rt.execution.CommandLineWrapper.main(CommandLineWrapper.java:<span class="number">67</span>)</span><br><span class="line">Caused by: java.lang.ClassCastException: com.alibaba.fastjson.JSONObject cannot be cast to subtitle.io.Person</span><br><span class="line">	at subtitle.io.MyMain.main(MyMain.java:<span class="number">48</span>)</span><br><span class="line">	... <span class="number">5</span> more</span><br><span class="line">&#123;<span class="string">"name"</span>:<span class="string">"zhangsan"</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>泛型序列化TypeReference code：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Person&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">    map.put(<span class="string">"one"</span>, <span class="keyword">new</span> Person(<span class="string">"zhangsan"</span>));</span><br><span class="line">    map.put(<span class="string">"two"</span>, <span class="keyword">new</span> Person(<span class="string">"lisi"</span>));</span><br><span class="line">    String jsonStr = JSON.toJSONString(map);</span><br><span class="line">    <span class="keyword">byte</span>[] bytes = jsonStr.getBytes();</span><br><span class="line">    String json = <span class="keyword">new</span> String(bytes);</span><br><span class="line">    Map&lt;String, Person&gt; res = JSON.parseObject(json, <span class="keyword">new</span> TypeReference&lt;Map&lt;String, Person&gt;&gt;()&#123;&#125;);</span><br><span class="line">    System.out.println(res.get(<span class="string">"one"</span>));</span><br><span class="line">    System.out.println(res.get(<span class="string">"one"</span>).getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person&#123;name=<span class="string">'zhangsan'</span>&#125;</span><br><span class="line">zhangsan</span><br></pre></td></tr></table></figure></p>
<p>报错原因：<br>    反序列化时候，虽然添加Map.class，但是没有办法指定Person类型，导致反序列化后的对象为Map<string, map<string,="" string="">&gt;,而不是Map<string, person="">，所以针对泛型的反序列化，需要使用TypeReference<br><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MDAxNzc2L2FydGljbGUvZGV0YWlscy84MzY1Mzg2OA==" title="https://blog.csdn.net/qq_35001776/article/details/83653868">转载至CSDN<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly95cS5hbGl5dW4uY29tL2FydGljbGVzLzYwOTQ0MQ==" title="https://yq.aliyun.com/articles/609441">参考文章<i class="fa fa-external-link"></i></span></string,></string,></p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> fastjson </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[spark项目在IDEA运行正常，spark-submit提示没有合适驱动]]></title>
      <url>/driver.html</url>
      <content type="html"><![CDATA[<h2 id="java-sql-SQLException-No-suitable-driver-解决方案"><a href="#java-sql-SQLException-No-suitable-driver-解决方案" class="headerlink" title="java.sql.SQLException: No suitable driver 解决方案"></a>java.sql.SQLException: No suitable driver 解决方案</h2><p>报错代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.sql.SQLException: No suitable driver	at java.sql.DriverManager.getDriver(DriverManager.java:<span class="number">315</span>)	at org.apache.spark.sql.execution.datasources.jdbc.JDBCOptions$$anonfun$<span class="number">7</span>.apply(JDBCOptions.scala:<span class="number">85</span>)	at org.apache.spark.sql.execution.datasources.jdbc.JDBCOptions$$anonfun$<span class="number">7</span>.apply(JDBCOptions.scala:<span class="number">85</span>)	at scala.Option.getOrElse(Option.scala:<span class="number">121</span>)	at org.apache.spark.sql.execution.datasources.jdbc.JDBCOptions.&lt;init&gt;(JDBCOptions.scala:<span class="number">84</span>)	at org.apache.spark.sql.execution.datasources.jdbc.JDBCOptions.&lt;init&gt;(JDBCOptions.scala:<span class="number">35</span>)	at org.apache.spark.sql.execution.datasources.jdbc.JdbcRelationProvider.createRelation(JdbcRelationProvider.scala:<span class="number">60</span>)	at org.apache.spark.sql.execution.datasources.SaveIntoDataSourceCommand.run(SaveIntoDataSourceCommand.scala:<span class="number">45</span>)	at org.apache.spark.sql.execution.command.ExecutedCommandExec.sideEffectResult$lzycompute(commands.scala:<span class="number">70</span>)	at org.apache.spark.sql.execution.command.ExecutedCommandExec.sideEffectResult(commands.scala:<span class="number">68</span>)	at org.apache.spark.sql.execution.command.ExecutedCommandExec.doExecute(commands.scala:<span class="number">86</span>)	at org.apache.spark.sql.execution.SparkPlan$$anonfun$execute$<span class="number">1</span>.apply(SparkPlan.scala:<span class="number">131</span>)	at org.apache.spark.sql.execution.SparkPlan$$anonfun$execute$<span class="number">1</span>.apply(SparkPlan.scala:<span class="number">127</span>)	at org.apache.spark.sql.execution.SparkPlan$$anonfun$executeQuery$<span class="number">1</span>.apply(SparkPlan.scala:<span class="number">155</span>)	at org.apache.spark.rdd.RDDOperationScope$.withScope(RDDOperationScope.scala:<span class="number">151</span>)	at org.apache.spark.sql.execution.SparkPlan.executeQuery(SparkPlan.scala:<span class="number">152</span>)	at org.apache.spark.sql.execution.SparkPlan.execute(SparkPlan.scala:<span class="number">127</span>)	at org.apache.spark.sql.execution.QueryExecution.toRdd$lzycompute(QueryExecution.scala:<span class="number">80</span>)	at org.apache.spark.sql.execution.QueryExecution.toRdd(QueryExecution.scala:<span class="number">80</span>)	at org.apache.spark.sql.DataFrameWriter$$anonfun$runCommand$<span class="number">1</span>.apply(DataFrameWriter.scala:<span class="number">656</span>)	at org.apache.spark.sql.DataFrameWriter$$anonfun$runCommand$<span class="number">1</span>.apply(DataFrameWriter.scala:<span class="number">656</span>)	at org.apache.spark.sql.execution.SQLExecution$.withNewExecutionId(SQLExecution.scala:<span class="number">77</span>)	at org.apache.spark.sql.DataFrameWriter.runCommand(DataFrameWriter.scala:<span class="number">656</span>)	at org.apache.spark.sql.DataFrameWriter.saveToV1Source(DataFrameWriter.scala:<span class="number">273</span>)	at org.apache.spark.sql.DataFrameWriter.save(DataFrameWriter.scala:<span class="number">267</span>)	at org.apache.spark.sql.DataFrameWriter.jdbc(DataFrameWriter.scala:<span class="number">501</span>)	at com.xinyi.multiCollision.service.JobService$.dealWithMoreData(JobService.scala:<span class="number">406</span>)	at com.xinyi.multiCollision.sparkJob.MultiCollisionApp$.main(MultiCollisionApp.scala:<span class="number">70</span>)	at com.xinyi.multiCollision.sparkJob.MultiCollisionApp.main(MultiCollisionApp.scala)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:<span class="number">62</span>)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="number">43</span>)	at java.lang.reflect.Method.invoke(Method.java:<span class="number">498</span>)	at org.apache.spark.deploy.JavaMainApplication.start(SparkApplication.scala:<span class="number">52</span>)	at org.apache.spark.deploy.SparkSubmit$.org$apache$spark$deploy$SparkSubmit$$runMain(SparkSubmit.scala:<span class="number">904</span>)	at org.apache.spark.deploy.SparkSubmit$.doRunMain$<span class="number">1</span>(SparkSubmit.scala:<span class="number">198</span>)	at org.apache.spark.deploy.SparkSubmit$.submit(SparkSubmit.scala:<span class="number">228</span>)	at org.apache.spark.deploy.SparkSubmit$.main(SparkSubmit.scala:<span class="number">137</span>)	at org.apache.spark.deploy.SparkSubmit.main(SparkSubmit.scala)</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>一般情况下，此报错原因是因为缺少连接数据库的驱动。<br>正常情况下，连接参数，驱动都是能考虑到的。但是在连接参数，驱动已添加的情况下也会报错。本人spark项目在IDEA正常运行，但是spark-submit的时候出现此错误（之前是可以正常运行的，后面报错，怀疑跟集群环境有关）。提交脚本已经配置了参数–conf spark.yarn.jars （虽然已经配置，驱动，jar包有可能不加载进去）。此时的解决方案：<br>将mysql-connector-java-5.1.24-bin.jar的jar包加入集群JAVA_HOME\jre\lib\ext文件夹下，再次运行，问题得以解决。</p>
]]></content>
      
        <categories>
            
            <category> 大数据 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Spark </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[spark2.4.2编译（mac系统下）]]></title>
      <url>/spark2-4-2%E7%BC%96%E8%AF%91.html</url>
      <content type="html"><![CDATA[<h2 id="编译前所注意事项："><a href="#编译前所注意事项：" class="headerlink" title="编译前所注意事项："></a>编译前所注意事项：</h2><p>首先，尽可能阅读官网编译文档 <span class="exturl" data-url="aHR0cDovL3NwYXJrLmFwYWNoZS5vcmcvZG9jcy9sYXRlc3QvYnVpbGRpbmctc3BhcmsuaHRtbA==" title="http://spark.apache.org/docs/latest/building-spark.html">Building Apache Spark<i class="fa fa-external-link"></i></span><br>源码下载推荐git clone 或者 wget 。<br>编译前确保网络良好。</p>
<h2 id="下载所需要的软件（注意版本）"><a href="#下载所需要的软件（注意版本）" class="headerlink" title="下载所需要的软件（注意版本）"></a>下载所需要的软件（注意版本）</h2><p>· Spark-2.4.2.tgz<br>· Hadoop-2.7.6<br>· Scala-2.11.12<br>· jdk1.8.0_191<br>· apache-maven-3.6.x<br>· git<br>注意：其中spark是源码，其他是可运行包<br><a id="more"></a></p>
<h2 id="解压安装并配置环境变量（过程略）"><a href="#解压安装并配置环境变量（过程略）" class="headerlink" title="解压安装并配置环境变量（过程略）"></a>解压安装并配置环境变量（过程略）</h2><p>配置完，注意测试。其中，maven配置本地库，镜像地址设置为阿里云地址。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 创建本地仓库文件夹</span><br><span class="line">mkdir ~/maven_repo</span><br><span class="line"><span class="meta">#</span> 修改settings.xml文件</span><br><span class="line">vim $MAVEN_HOME/conf/settings.xml</span><br></pre></td></tr></table></figure></p>
<p>部分代码：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- localRepository</span></span><br><span class="line"><span class="comment">   | The path to the local repository maven will use to store artifacts.</span></span><br><span class="line"><span class="comment">   |</span></span><br><span class="line"><span class="comment">   | Default: $&#123;user.home&#125;/.m2/repository</span></span><br><span class="line"><span class="comment">  &lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt;</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>/home/max/maven_repo<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*,!cloudera<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus aliyun<span class="tag">&lt;/<span class="name">name</span>&gt;</span>                     </span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span></span><br><span class="line">      http://maven.aliyun.com/nexus/content/groups/public</span><br><span class="line">    <span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="修改脚本make-distribution-sh"><a href="#修改脚本make-distribution-sh" class="headerlink" title="修改脚本make-distribution.sh"></a>修改脚本make-distribution.sh</h2><p>编译不使用mvn这个命令,直接用make-distribution.sh脚本，但是需要修改该脚本<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>spark-2.4.2文件夹下</span><br><span class="line">vim ./dev/make-distribution.sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>将这些行注释掉    此处为最佳实践，为的是通过指定版本号减少编译时间</span><br><span class="line"><span class="meta">#</span>VERSION=$("$MVN" help:evaluate -Dexpression=project.version $@ 2&gt;/dev/null\</span><br><span class="line"><span class="meta">#</span>    | grep -v "INFO"\</span><br><span class="line"><span class="meta">#</span>    | grep -v "WARNING"\</span><br><span class="line"><span class="meta">#</span>    | tail -n 1)</span><br><span class="line"><span class="meta">#</span>SCALA_VERSION=$("$MVN" help:evaluate -Dexpression=scala.binary.version $@ 2&gt;/dev/null\</span><br><span class="line"><span class="meta">#</span>    | grep -v "INFO"\</span><br><span class="line"><span class="meta">#</span>    | grep -v "WARNING"\</span><br><span class="line"><span class="meta">#</span>    | tail -n 1)</span><br><span class="line"><span class="meta">#</span>SPARK_HADOOP_VERSION=$("$MVN" help:evaluate -Dexpression=hadoop.version $@ 2&gt;/dev/null\</span><br><span class="line"><span class="meta">#</span>    | grep -v "INFO"\</span><br><span class="line"><span class="meta">#</span>    | grep -v "WARNING"\</span><br><span class="line"><span class="meta">#</span>    | tail -n 1)</span><br><span class="line"><span class="meta">#</span>SPARK_HIVE=$("$MVN" help:evaluate -Dexpression=project.activeProfiles -pl sql/hive $@ 2&gt;/dev/null\</span><br><span class="line"><span class="meta">#</span>    | grep -v "INFO"\</span><br><span class="line"><span class="meta">#</span>    | grep -v "WARNING"\</span><br><span class="line"><span class="meta">#</span>    | fgrep --count "&lt;id&gt;hive&lt;/id&gt;";\</span><br><span class="line"><span class="meta">#</span>    # Reset exit status to 0, otherwise the script stops here if the last grep finds nothing\</span><br><span class="line"><span class="meta">#</span>    # because we use "set -o pipefail"</span><br><span class="line"><span class="meta">#</span>    echo -n)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>#添加一下参数，注意，版本号要对应自己想要的生产环境</span><br><span class="line">VERSION=2.4.2</span><br><span class="line">SCALA_VERSION=2.11</span><br><span class="line">SPARK_HADOOP_VERSION=hadoop-2.6.0-cdh5.14.0</span><br><span class="line">SPARK_HIVE=1</span><br></pre></td></tr></table></figure></p>
<h2 id="修改源码包spark-2-4-2下的pom-xml"><a href="#修改源码包spark-2-4-2下的pom-xml" class="headerlink" title="修改源码包spark-2.4.2下的pom.xml"></a>修改源码包spark-2.4.2下的pom.xml</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;repositories&gt;</span></span><br><span class="line"><span class="comment">     This should be at top, it makes maven try the central repo first and then others</span></span><br><span class="line"><span class="comment">and hence faster dep resolution</span></span><br><span class="line"><span class="comment">    &lt;repository&gt;</span></span><br><span class="line"><span class="comment">        &lt;id&gt;central&lt;/id&gt;</span></span><br><span class="line"><span class="comment">        &lt;name&gt;Maven Repository&lt;/name&gt;</span></span><br><span class="line"><span class="comment">        &lt;url&gt;https://repo.maven.apache.org/maven2&lt;/url&gt;</span></span><br><span class="line"><span class="comment">        &lt;releases&gt;</span></span><br><span class="line"><span class="comment">            &lt;enabled&gt;true&lt;/enabled&gt;</span></span><br><span class="line"><span class="comment">        &lt;/releases&gt;</span></span><br><span class="line"><span class="comment">        &lt;snapshots&gt;</span></span><br><span class="line"><span class="comment">            &lt;enabled&gt;false&lt;/enabled&gt;</span></span><br><span class="line"><span class="comment">        &lt;/snapshots&gt;</span></span><br><span class="line"><span class="comment">    &lt;/repository&gt;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>central<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public//<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">updatePolicy</span>&gt;</span>always<span class="tag">&lt;/<span class="name">updatePolicy</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">checksumPolicy</span>&gt;</span>fail<span class="tag">&lt;/<span class="name">checksumPolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>cloudera<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repository.cloudera.com/artifactory/cloudera-repos/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="开始编译"><a href="#开始编译" class="headerlink" title="开始编译"></a>开始编译</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">./dev/make-distribution.sh \</span><br><span class="line">--name hadoop-2.6.0-cdh5.14.0  \</span><br><span class="line">--tgz \</span><br><span class="line">-Phadoop-2.6 \</span><br><span class="line">-Dhadoop.version=2.6.0-cdh5.14.0 \</span><br><span class="line">-Phive -Phive-thriftserver  \</span><br><span class="line">-Pyarn \</span><br><span class="line">-Pkubernetes</span><br></pre></td></tr></table></figure>
<p>编译大概需要半小时以上，耐心等待就行。编译过程中如果报错，一般有error字样。<br>出现以下字样，代表编译完成：<br><img src="https://hexoblog-1254111960.cos.ap-guangzhou.myqcloud.com/spark%E7%BC%96%E8%AF%91%E6%88%90%E5%8A%9F.png" alt=""><br>编译后包所在位置，源码包spark-2.4.2根目录下：<br><img src="https://hexoblog-1254111960.cos.ap-guangzhou.myqcloud.com/spark%E7%AC%AC%E4%B8%80%E6%AC%A1%E7%BC%96%E8%AF%91%E5%8C%85%E5%9C%B0%E5%9D%80.png" alt=""><br>至此，编译完！</p>
]]></content>
      
        <categories>
            
            <category> 大数据 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Spark </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hadoop分布式文件系统：架构和设计]]></title>
      <url>/Hadoop%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%EF%BC%9A%E6%9E%B6%E6%9E%84%E5%92%8C%E8%AE%BE%E8%AE%A1.html</url>
      <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>Hadoop分布式文件系统(HDFS)被设计成适合运行在通用硬件(commodity hardware)上的分布式文件系统。它和现有的分布式文件系统有很多共同点。但同时，它和其他的分布式文件系统的区别也是很明显的。HDFS是一个高度容错性的系统，适合部署在廉价的机器上。HDFS能提供高吞吐量的数据访问，非常适合大规模数据集上的应用。HDFS放宽了一部分POSIX约束，来实现流式读取文件系统数据的目的。HDFS在最开始是作为Apache Nutch搜索引擎项目的基础架构而开发的。HDFS是Apache Hadoop Core项目的一部分。这个项目的地址是<span class="exturl" data-url="aHR0cDovL2hhZG9vcC5hcGFjaGUub3JnL2NvcmUv44CC" title="http://hadoop.apache.org/core/。">http://hadoop.apache.org/core/。<i class="fa fa-external-link"></i></span><br><a id="more"></a></p>
<h2 id="前提和设计目标"><a href="#前提和设计目标" class="headerlink" title="前提和设计目标"></a>前提和设计目标</h2><h3 id="硬件错误"><a href="#硬件错误" class="headerlink" title="硬件错误"></a>硬件错误</h3><p>硬件错误是常态而不是异常。HDFS可能由成百上千的服务器所构成，每个服务器上存储着文件系统的部分数据。我们面对的现实是构成系统的组件数目是巨大的，而且任一组件都有可能失效，这意味着总是有一部分HDFS的组件是不工作的。因此错误检测和快速、自动的恢复是HDFS最核心的架构目标。</p>
<h3 id="流式数据访问"><a href="#流式数据访问" class="headerlink" title="流式数据访问"></a>流式数据访问</h3><p>运行在HDFS上的应用和普通的应用不同，需要流式访问它们的数据集。HDFS的设计中更多的考虑到了数据批处理，而不是用户交互处理。比之数据访问的低延迟问题，更关键的在于数据访问的高吞吐量。POSIX标准设置的很多硬性约束对HDFS应用系统不是必需的。为了提高数据的吞吐量，在一些关键方面对POSIX的语义做了一些修改。</p>
<h3 id="大规模数据集"><a href="#大规模数据集" class="headerlink" title="大规模数据集"></a>大规模数据集</h3><p>运行在HDFS上的应用具有很大的数据集。HDFS上的一个典型文件大小一般都在G字节至T字节。因此，HDFS被调节以支持大文件存储。它应该能提供整体上高的数据传输带宽，能在一个集群里扩展到数百个节点。一个单一的HDFS实例应该能支撑数以千万计的文件。</p>
<h3 id="简单的一致性模型"><a href="#简单的一致性模型" class="headerlink" title="简单的一致性模型"></a>简单的一致性模型</h3><p>HDFS应用需要一个“一次写入多次读取”的文件访问模型。一个文件经过创建、写入和关闭之后就不需要改变。这一假设简化了数据一致性问题，并且使高吞吐量的数据访问成为可能。Map/Reduce应用或者网络爬虫应用都非常适合这个模型。目前还有计划在将来扩充这个模型，使之支持文件的附加写操作。</p>
<h3 id="“移动计算比移动数据更划算”"><a href="#“移动计算比移动数据更划算”" class="headerlink" title="“移动计算比移动数据更划算”"></a>“移动计算比移动数据更划算”</h3><p>一个应用请求的计算，离它操作的数据越近就越高效，在数据达到海量级别的时候更是如此。因为这样就能降低网络阻塞的影响，提高系统数据的吞吐量。将计算移动到数据附近，比之将数据移动到应用所在显然更好。HDFS为应用提供了将它们自己移动到数据附近的接口。</p>
<h3 id="异构软硬件平台间的可移植性"><a href="#异构软硬件平台间的可移植性" class="headerlink" title="异构软硬件平台间的可移植性"></a>异构软硬件平台间的可移植性</h3><p>HDFS在设计的时候就考虑到平台的可移植性。这种特性方便了HDFS作为大规模数据应用平台的推广。</p>
<h3 id="Namenode-和-Datanode"><a href="#Namenode-和-Datanode" class="headerlink" title="Namenode 和 Datanode"></a>Namenode 和 Datanode</h3><p>HDFS采用master/slave架构。一个HDFS集群是由一个Namenode和一定数目的Datanodes组成。Namenode是一个中心服务器，负责管理文件系统的名字空间(namespace)以及客户端对文件的访问。集群中的Datanode一般是一个节点一个，负责管理它所在节点上的存储。HDFS暴露了文件系统的名字空间，用户能够以文件的形式在上面存储数据。从内部看，一个文件其实被分成一个或多个数据块，这些块存储在一组Datanode上。Namenode执行文件系统的名字空间操作，比如打开、关闭、重命名文件或目录。它也负责确定数据块到具体Datanode节点的映射。Datanode负责处理文件系统客户端的读写请求。在Namenode的统一调度下进行数据块的创建、删除和复制。</p>
<h3 id="HDFS-架构"><a href="#HDFS-架构" class="headerlink" title="HDFS 架构"></a>HDFS 架构</h3><p>Namenode和Datanode被设计成可以在普通的商用机器上运行。这些机器一般运行着GNU/Linux操作系统(OS)。HDFS采用Java语言开发，因此任何支持Java的机器都可以部署Namenode或Datanode。由于采用了可移植性极强的Java语言，使得HDFS可以部署到多种类型的机器上。一个典型的部署场景是一台机器上只运行一个Namenode实例，而集群中的其它机器分别运行一个Datanode实例。这种架构并不排斥在一台机器上运行多个Datanode，只不过这样的情况比较少见。</p>
<p>集群中单一Namenode的结构大大简化了系统的架构。Namenode是所有HDFS元数据的仲裁者和管理者，这样，用户数据永远不会流过Namenode。</p>
<h3 id="文件系统的名字空间-namespace"><a href="#文件系统的名字空间-namespace" class="headerlink" title="文件系统的名字空间 (namespace)"></a>文件系统的名字空间 (namespace)</h3><p>HDFS支持传统的层次型文件组织结构。用户或者应用程序可以创建目录，然后将文件保存在这些目录里。文件系统名字空间的层次结构和大多数现有的文件系统类似：用户可以创建、删除、移动或重命名文件。当前，HDFS不支持用户磁盘配额和访问权限控制，也不支持硬链接和软链接。但是HDFS架构并不妨碍实现这些特性。</p>
<p>Namenode负责维护文件系统的名字空间，任何对文件系统名字空间或属性的修改都将被Namenode记录下来。应用程序可以设置HDFS保存的文件的副本数目。文件副本的数目称为文件的副本系数，这个信息也是由Namenode保存的。</p>
<h3 id="数据复制"><a href="#数据复制" class="headerlink" title="数据复制"></a>数据复制</h3><p>HDFS被设计成能够在一个大集群中跨机器可靠地存储超大文件。它将每个文件存储成一系列的数据块，除了最后一个，所有的数据块都是同样大小的。为了容错，文件的所有数据块都会有副本。每个文件的数据块大小和副本系数都是可配置的。应用程序可以指定某个文件的副本数目。副本系数可以在文件创建的时候指定，也可以在之后改变。HDFS中的文件都是一次性写入的，并且严格要求在任何时候只能有一个写入者。</p>
<p>Namenode全权管理数据块的复制，它周期性地从集群中的每个Datanode接收心跳信号和块状态报告(Blockreport)。接收到心跳信号意味着该Datanode节点工作正常。块状态报告包含了一个该Datanode上所有数据块的列表。</p>
<h2 id="HDFS-Datanodes"><a href="#HDFS-Datanodes" class="headerlink" title="HDFS Datanodes"></a>HDFS Datanodes</h2><h3 id="副本存放-最最开始的一步"><a href="#副本存放-最最开始的一步" class="headerlink" title="副本存放: 最最开始的一步"></a>副本存放: 最最开始的一步</h3><p>副本的存放是HDFS可靠性和性能的关键。优化的副本存放策略是HDFS区分于其他大部分分布式文件系统的重要特性。这种特性需要做大量的调优，并需要经验的积累。HDFS采用一种称为机架感知(rack-aware)的策略来改进数据的可靠性、可用性和网络带宽的利用率。目前实现的副本存放策略只是在这个方向上的第一步。实现这个策略的短期目标是验证它在生产环境下的有效性，观察它的行为，为实现更先进的策略打下测试和研究的基础。</p>
<p>大型HDFS实例一般运行在跨越多个机架的计算机组成的集群上，不同机架上的两台机器之间的通讯需要经过交换机。在大多数情况下，同一个机架内的两台机器间的带宽会比不同机架的两台机器间的带宽大。</p>
<p>通过一个机架感知的过程，Namenode可以确定每个Datanode所属的机架id。一个简单但没有优化的策略就是将副本存放在不同的机架上。这样可以有效防止当整个机架失效时数据的丢失，并且允许读数据的时候充分利用多个机架的带宽。这种策略设置可以将副本均匀分布在集群中，有利于当组件失效情况下的负载均衡。但是，因为这种策略的一个写操作需要传输数据块到多个机架，这增加了写的代价。</p>
<p>在大多数情况下，副本系数是3，HDFS的存放策略是将一个副本存放在本地机架的节点上，一个副本放在同一机架的另一个节点上，最后一个副本放在不同机架的节点上。这种策略减少了机架间的数据传输，这就提高了写操作的效率。机架的错误远远比节点的错误少，所以这个策略不会影响到数据的可靠性和可用性。于此同时，因为数据块只放在两个（不是三个）不同的机架上，所以此策略减少了读取数据时需要的网络传输总带宽。在这种策略下，副本并不是均匀分布在不同的机架上。三分之一的副本在一个节点上，三分之二的副本在一个机架上，其他副本均匀分布在剩下的机架中，这一策略在不损害数据可靠性和读取性能的情况下改进了写的性能。</p>
<p>当前，这里介绍的默认副本存放策略正在开发的过程中。</p>
<h3 id="副本选择"><a href="#副本选择" class="headerlink" title="副本选择"></a>副本选择</h3><p>为了降低整体的带宽消耗和读取延时，HDFS会尽量让读取程序读取离它最近的副本。如果在读取程序的同一个机架上有一个副本，那么就读取该副本。如果一个HDFS集群跨越多个数据中心，那么客户端也将首先读本地数据中心的副本。</p>
<h3 id="安全模式"><a href="#安全模式" class="headerlink" title="安全模式"></a>安全模式</h3><p>Namenode启动后会进入一个称为安全模式的特殊状态。处于安全模式的Namenode是不会进行数据块的复制的。Namenode从所有的 Datanode接收心跳信号和块状态报告。块状态报告包括了某个Datanode所有的数据块列表。每个数据块都有一个指定的最小副本数。当Namenode检测确认某个数据块的副本数目达到这个最小值，那么该数据块就会被认为是副本安全(safely replicated)的；在一定百分比（这个参数可配置）的数据块被Namenode检测确认是安全之后（加上一个额外的30秒等待时间），Namenode将退出安全模式状态。接下来它会确定还有哪些数据块的副本没有达到指定数目，并将这些数据块复制到其他Datanode上。</p>
<h3 id="文件系统元数据的持久化"><a href="#文件系统元数据的持久化" class="headerlink" title="文件系统元数据的持久化"></a>文件系统元数据的持久化</h3><p>Namenode上保存着HDFS的名字空间。对于任何对文件系统元数据产生修改的操作，Namenode都会使用一种称为EditLog的事务日志记录下来。例如，在HDFS中创建一个文件，Namenode就会在Editlog中插入一条记录来表示；同样地，修改文件的副本系数也将往Editlog插入一条记录。Namenode在本地操作系统的文件系统中存储这个Editlog。整个文件系统的名字空间，包括数据块到文件的映射、文件的属性等，都存储在一个称为FsImage的文件中，这个文件也是放在Namenode所在的本地文件系统上。</p>
<p>Namenode在内存中保存着整个文件系统的名字空间和文件数据块映射(Blockmap)的映像。这个关键的元数据结构设计得很紧凑，因而一个有4G内存的Namenode足够支撑大量的文件和目录。当Namenode启动时，它从硬盘中读取Editlog和FsImage，将所有Editlog中的事务作用在内存中的FsImage上，并将这个新版本的FsImage从内存中保存到本地磁盘上，然后删除旧的Editlog，因为这个旧的Editlog的事务都已经作用在FsImage上了。这个过程称为一个检查点(checkpoint)。在当前实现中，检查点只发生在Namenode启动时，在不久的将来将实现支持周期性的检查点。</p>
<p>Datanode将HDFS数据以文件的形式存储在本地的文件系统中，它并不知道有关HDFS文件的信息。它把每个HDFS数据块存储在本地文件系统的一个单独的文件中。Datanode并不在同一个目录创建所有的文件，实际上，它用试探的方法来确定每个目录的最佳文件数目，并且在适当的时候创建子目录。在同一个目录中创建所有的本地文件并不是最优的选择，这是因为本地文件系统可能无法高效地在单个目录中支持大量的文件。当一个Datanode启动时，它会扫描本地文件系统，产生一个这些本地文件对应的所有HDFS数据块的列表，然后作为报告发送到Namenode，这个报告就是块状态报告。</p>
<h3 id="通讯协议"><a href="#通讯协议" class="headerlink" title="通讯协议"></a>通讯协议</h3><p>所有的HDFS通讯协议都是建立在TCP/IP协议之上。客户端通过一个可配置的TCP端口连接到Namenode，通过ClientProtocol协议与Namenode交互。而Datanode使用DatanodeProtocol协议与Namenode交互。一个远程过程调用(RPC)模型被抽象出来封装ClientProtocol和Datanodeprotocol协议。在设计上，Namenode不会主动发起RPC，而是响应来自客户端或 Datanode 的RPC请求。</p>
<h3 id="健壮性"><a href="#健壮性" class="headerlink" title="健壮性"></a>健壮性</h3><p>HDFS的主要目标就是即使在出错的情况下也要保证数据存储的可靠性。常见的三种出错情况是：Namenode出错, Datanode出错和网络割裂(network partitions)。</p>
<h3 id="磁盘数据错误，心跳检测和重新复制"><a href="#磁盘数据错误，心跳检测和重新复制" class="headerlink" title="磁盘数据错误，心跳检测和重新复制"></a>磁盘数据错误，心跳检测和重新复制</h3><p>每个Datanode节点周期性地向Namenode发送心跳信号。网络割裂可能导致一部分Datanode跟Namenode失去联系。Namenode通过心跳信号的缺失来检测这一情况，并将这些近期不再发送心跳信号Datanode标记为宕机，不会再将新的IO请求发给它们。任何存储在宕机Datanode上的数据将不再有效。Datanode的宕机可能会引起一些数据块的副本系数低于指定值，Namenode不断地检测这些需要复制的数据块，一旦发现就启动复制操作。在下列情况下，可能需要重新复制：某个Datanode节点失效，某个副本遭到损坏，Datanode上的硬盘错误，或者文件的副本系数增大。</p>
<h3 id="集群均衡"><a href="#集群均衡" class="headerlink" title="集群均衡"></a>集群均衡</h3><p>HDFS的架构支持数据均衡策略。如果某个Datanode节点上的空闲空间低于特定的临界点，按照均衡策略系统就会自动地将数据从这个Datanode移动到其他空闲的Datanode。当对某个文件的请求突然增加，那么也可能启动一个计划创建该文件新的副本，并且同时重新平衡集群中的其他数据。这些均衡策略目前还没有实现。</p>
<h3 id="数据完整性"><a href="#数据完整性" class="headerlink" title="数据完整性"></a>数据完整性</h3><p>从某个Datanode获取的数据块有可能是损坏的，损坏可能是由Datanode的存储设备错误、网络错误或者软件bug造成的。HDFS客户端软件实现了对HDFS文件内容的校验和(checksum)检查。当客户端创建一个新的HDFS文件，会计算这个文件每个数据块的校验和，并将校验和作为一个单独的隐藏文件保存在同一个HDFS名字空间下。当客户端获取文件内容后，它会检验从Datanode获取的数据跟相应的校验和文件中的校验和是否匹配，如果不匹配，客户端可以选择从其他Datanode获取该数据块的副本。</p>
<h3 id="元数据磁盘错误"><a href="#元数据磁盘错误" class="headerlink" title="元数据磁盘错误"></a>元数据磁盘错误</h3><p>FsImage和Editlog是HDFS的核心数据结构。如果这些文件损坏了，整个HDFS实例都将失效。因而，Namenode可以配置成支持维护多个FsImage和Editlog的副本。任何对FsImage或者Editlog的修改，都将同步到它们的副本上。这种多副本的同步操作可能会降低Namenode每秒处理的名字空间事务数量。然而这个代价是可以接受的，因为即使HDFS的应用是数据密集的，它们也非元数据密集的。当Namenode重启的时候，它会选取最近的完整的FsImage和Editlog来使用。</p>
<p>Namenode是HDFS集群中的单点故障(single point of failure)所在。如果Namenode机器故障，是需要手工干预的。目前，自动重启或在另一台机器上做Namenode故障转移的功能还没实现。</p>
<h3 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h3><p>快照支持某一特定时刻的数据的复制备份。利用快照，可以让HDFS在数据损坏时恢复到过去一个已知正确的时间点。HDFS目前还不支持快照功能，但计划在将来的版本进行支持。</p>
<h2 id="数据组织"><a href="#数据组织" class="headerlink" title="数据组织"></a>数据组织</h2><h3 id="数据块"><a href="#数据块" class="headerlink" title="数据块"></a>数据块</h3><p>HDFS被设计成支持大文件，适用HDFS的是那些需要处理大规模的数据集的应用。这些应用都是只写入数据一次，但却读取一次或多次，并且读取速度应能满足流式读取的需要。HDFS支持文件的“一次写入多次读取”语义。一个典型的数据块大小是64MB。因而，HDFS中的文件总是按照64M被切分成不同的块，每个块尽可能地存储于不同的Datanode中。</p>
<h3 id="Staging"><a href="#Staging" class="headerlink" title="Staging"></a>Staging</h3><p>客户端创建文件的请求其实并没有立即发送给Namenode，事实上，在刚开始阶段HDFS客户端会先将文件数据缓存到本地的一个临时文件。应用程序的写操作被透明地重定向到这个临时文件。当这个临时文件累积的数据量超过一个数据块的大小，客户端才会联系Namenode。Namenode将文件名插入文件系统的层次结构中，并且分配一个数据块给它。然后返回Datanode的标识符和目标数据块给客户端。接着客户端将这块数据从本地临时文件上传到指定的Datanode上。当文件关闭时，在临时文件中剩余的没有上传的数据也会传输到指定的Datanode上。然后客户端告诉Namenode文件已经关闭。此时Namenode才将文件创建操作提交到日志里进行存储。如果Namenode在文件关闭前宕机了，则该文件将丢失。</p>
<p>上述方法是对在HDFS上运行的目标应用进行认真考虑后得到的结果。这些应用需要进行文件的流式写入。如果不采用客户端缓存，由于网络速度和网络堵塞会对吞估量造成比较大的影响。这种方法并不是没有先例的，早期的文件系统，比如AFS，就用客户端缓存来提高性能。为了达到更高的数据上传效率，已经放松了POSIX标准的要求。</p>
<h3 id="流水线复制"><a href="#流水线复制" class="headerlink" title="流水线复制"></a>流水线复制</h3><p>当客户端向HDFS文件写入数据的时候，一开始是写到本地临时文件中。假设该文件的副本系数设置为3，当本地临时文件累积到一个数据块的大小时，客户端会从Namenode获取一个Datanode列表用于存放副本。然后客户端开始向第一个Datanode传输数据，第一个Datanode一小部分一小部分(4 KB)地接收数据，将每一部分写入本地仓库，并同时传输该部分到列表中第二个Datanode节点。第二个Datanode也是这样，一小部分一小部分地接收数据，写入本地仓库，并同时传给第三个Datanode。最后，第三个Datanode接收数据并存储在本地。因此，Datanode能流水线式地从前一个节点接收数据，并在同时转发给下一个节点，数据以流水线的方式从前一个Datanode复制到下一个。</p>
<h3 id="可访问性"><a href="#可访问性" class="headerlink" title="可访问性"></a>可访问性</h3><p>HDFS给应用提供了多种访问方式。用户可以通过Java API接口访问，也可以通过C语言的封装API访问，还可以通过浏览器的方式访问HDFS中的文件。通过WebDAV协议访问的方式正在开发中。</p>
<h3 id="DFSShell"><a href="#DFSShell" class="headerlink" title="DFSShell"></a>DFSShell</h3><p>HDFS以文件和目录的形式组织用户数据。它提供了一个命令行的接口(DFSShell)让用户与HDFS中的数据进行交互。命令的语法和用户熟悉的其他shell(例如 bash, csh)工具类似。下面是一些动作/命令的示例：</p>
<h3 id="动作命令"><a href="#动作命令" class="headerlink" title="动作命令"></a>动作命令</h3><p>创建一个名为 /foodir 的目录    bin/hadoop dfs -mkdir /foodir<br>创建一个名为 /foodir 的目录    bin/hadoop dfs -mkdir /foodir<br>查看名为 /foodir/myfile.txt 的文件内容    bin/hadoop dfs -cat /foodir/myfile.txt<br>DFSShell 可以用在那些通过脚本语言和文件系统进行交互的应用程序上。</p>
<h3 id="DFSAdmin"><a href="#DFSAdmin" class="headerlink" title="DFSAdmin"></a>DFSAdmin</h3><p>DFSAdmin 命令用来管理HDFS集群。这些命令只有HDSF的管理员才能使用。下面是一些动作/命令的示例：</p>
<h3 id="动作命令-1"><a href="#动作命令-1" class="headerlink" title="动作命令"></a>动作命令</h3><p>将集群置于安全模式    bin/hadoop dfsadmin -safemode enter<br>显示Datanode列表    bin/hadoop dfsadmin -report<br>使Datanode节点 datanodename退役    bin/hadoop dfsadmin -decommission datanodename</p>
<h3 id="浏览器接口"><a href="#浏览器接口" class="headerlink" title="浏览器接口"></a>浏览器接口</h3><p>一个典型的HDFS安装会在一个可配置的TCP端口开启一个Web服务器用于暴露HDFS的名字空间。用户可以用浏览器来浏览HDFS的名字空间和查看文件的内容。</p>
<h2 id="存储空间回收"><a href="#存储空间回收" class="headerlink" title="存储空间回收"></a>存储空间回收</h2><h3 id="文件的删除和恢复"><a href="#文件的删除和恢复" class="headerlink" title="文件的删除和恢复"></a>文件的删除和恢复</h3><p>当用户或应用程序删除某个文件时，这个文件并没有立刻从HDFS中删除。实际上，HDFS会将这个文件重命名转移到/trash目录。只要文件还在/trash目录中，该文件就可以被迅速地恢复。文件在/trash中保存的时间是可配置的，当超过这个时间时，Namenode就会将该文件从名字空间中删除。删除文件会使得该文件相关的数据块被释放。注意，从用户删除文件到HDFS空闲空间的增加之间会有一定时间的延迟。</p>
<p>只要被删除的文件还在/trash目录中，用户就可以恢复这个文件。如果用户想恢复被删除的文件，他/她可以浏览/trash目录找回该文件。/trash目录仅仅保存被删除文件的最后副本。/trash目录与其他的目录没有什么区别，除了一点：在该目录上HDFS会应用一个特殊策略来自动删除文件。目前的默认策略是删除/trash中保留时间超过6小时的文件。将来，这个策略可以通过一个被良好定义的接口配置。</p>
<h3 id="减少副本系数"><a href="#减少副本系数" class="headerlink" title="减少副本系数"></a>减少副本系数</h3><p>当一个文件的副本系数被减小后，Namenode会选择过剩的副本删除。下次心跳检测时会将该信息传递给Datanode。Datanode遂即移除相应的数据块，集群中的空闲空间加大。同样，在调用setReplication API结束和集群中空闲空间增加间会有一定的延迟。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><span class="exturl" data-url="aHR0cDovL2hhZG9vcC5hcGFjaGUub3JnL2NvcmUvZG9jcy9jdXJyZW50L2FwaS8=" title="http://hadoop.apache.org/core/docs/current/api/">HDFS Java API<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cDovL2hhZG9vcC5hcGFjaGUub3JnL2NvcmUvdmVyc2lvbl9jb250cm9sLmh0bWw=" title="http://hadoop.apache.org/core/version_control.html">HDFS 源代码<i class="fa fa-external-link"></i></span></p>
]]></content>
      
        <categories>
            
            <category> 大数据 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hadoop </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hadoop2.7.5HA集群搭建]]></title>
      <url>/Hadoop2-7-5HA%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA.html</url>
      <content type="html"><![CDATA[<h2 id="hadoop-HA原理概述"><a href="#hadoop-HA原理概述" class="headerlink" title="hadoop HA原理概述"></a>hadoop HA原理概述</h2><h3 id="为什么会有-hadoop-HA-机制呢？"><a href="#为什么会有-hadoop-HA-机制呢？" class="headerlink" title="为什么会有 hadoop HA 机制呢？"></a>为什么会有 hadoop HA 机制呢？</h3><ol>
<li>HA：High Available，高可用<br>在Hadoop 2.0之前,在HDFS 集群中NameNode 存在单点故障 (SPOF：A Single Point of Failure)。对于只有一个 NameNode 的集群，如果 NameNode 机器出现故障(比如宕机或是软件、硬件升级)，那么整个集群将无法使用，直到 NameNode 重新启动。</li>
<li>那如何解决呢？HDFS 的 HA 功能通过配置 Active/Standby 两个 NameNodes 实现在集群中对 NameNode 的热备来解决上述问题。如果出现故障，如机器崩溃或机器需要升级维护，这时可通过此种方式将 NameNode 很快的切换到另外一台机器。</li>
<li>在一个典型的 HDFS(HA) 集群中，使用两台单独的机器配置为 NameNodes 。在任何时间点，确保 NameNodes 中只有一个处于 Active 状态，其他的处在 Standby 状态。其中ActiveNameNode 负责集群中的所有客户端操作，StandbyNameNode 仅仅充当备机，保证一旦 ActiveNameNode 出现问题能够快速切换。<a id="more"></a></li>
<li>为了能够实时同步 Active 和 Standby 两个 NameNode 的元数据信息（实际上 editlog），需提供一个共享存储系统，可以是 NFS、QJM（Quorum Journal Manager）或者 Zookeeper，ActiveNamenode 将数据写入共享存储系统，而 Standby 监听该系统，一旦发现有新数据写入，则读取这些数据，并加载到自己内存中，以保证自己内存状态与 Active NameNode 保持基本一致，如此这般，在紧急情况下 standby 便可快速切为 active namenode。为了实现快速切换，Standby 节点获取集群的最新文件块信息也是很有必要的。为了实现这一目标，DataNode 需要配置 NameNodes 的位置，并同时给他们发送文件块信息以及心跳检测。</li>
</ol>
<p><img src="https://img-blog.csdn.net/20180324172504472?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2R1ZGVmdTAxMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<h2 id="SecondaryNameNode-和-Standby-Namenode-的区别？"><a href="#SecondaryNameNode-和-Standby-Namenode-的区别？" class="headerlink" title="SecondaryNameNode 和 Standby Namenode 的区别？"></a>SecondaryNameNode 和 Standby Namenode 的区别？</h2><p>在1.x版本中，SecondaryNameNode将fsimage跟edits进行合并，生成新的fsimage文件用http post传回NameNode节点。SecondaryNameNode不能做NameNode的备份。<br>在hadoop 2.x版本中才引入StandbyNameNode，从journalNode上拷贝的。StandbyNameNode是可以做namenode的备份。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phcnRoL2FydGljbGUvZGV0YWlscy81MjgzOTg2NA==" title="https://blog.csdn.net/jarth/article/details/52839864">Hadoop2的高可用并取代SecondaryNamenode<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L28zNDAxNzY2MzUvYXJ0aWNsZS9kZXRhaWxzLzQ2OTMxOTIx" title="https://blog.csdn.net/o340176635/article/details/46931921">在hadoop2实际生产环境中，为什么还需要SecondeNamenode<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vY2hlbnlhbGluZy9wLzU1MjE0NjQuaHRtbA==" title="https://www.cnblogs.com/chenyaling/p/5521464.html">secondary namenode和namenode的区别 <i class="fa fa-external-link"></i></span></p>
<h2 id="集群规划"><a href="#集群规划" class="headerlink" title="集群规划"></a>集群规划</h2><p>描述：hadoop HA 集群的搭建依赖于 zookeeper，所以选取三台当做 zookeeper 集群我总共准备了四台主机，分别是 hadoop02，hadoop03，hadoop04，hadoop05其中 hadoop02 和 hadoop03 做 namenode 的主备切换，hadoop04 和 hadoop05 做resourcemanager 的主备切换</p>
<p><img src="https://img-blog.csdn.net/20180324174153453?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2R1ZGVmdTAxMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<p><img src="https://img-blog.csdn.net/2018032417421737?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2R1ZGVmdTAxMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<h2 id="集群服务器准备"><a href="#集群服务器准备" class="headerlink" title="集群服务器准备"></a>集群服务器准备</h2><p>1、 修改主机名<br>2、 修改 IP 地址<br>3、 添加主机名和 IP 映射<br>4、 添加普通用户 hadoop 用户并配置 sudoer 权限<br>5、 设置系统启动级别<br>6、 关闭防火墙/关闭 Selinux<br>7、 安装 JDK<br>两种准备方式：<br>1、 每个节点都单独设置，这样比较麻烦。线上环境可以编写脚本实现<br>2、 虚拟机环境可是在做完以上 7 步之后，就进行克隆<br>3、 然后接着再给你的集群配置 SSH 免密登陆和搭建时间同步服务<br>8、 配置 SSH 免密登录<br>9、 同步服务器时间</p>
<h2 id="集群安装"><a href="#集群安装" class="headerlink" title="集群安装"></a>集群安装</h2><p>1、安装 Zookeeper 集群（略）<br>2、 安装 hadoop 集群</p>
<h4 id="修改配置文件："><a href="#修改配置文件：" class="headerlink" title="修改配置文件："></a>修改配置文件：</h4><p>core-site.xml :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">	&lt;!-- 指定hdfs的nameservice为myha01 --&gt;</span><br><span class="line">	&lt;property&gt;</span><br><span class="line">		&lt;name&gt;fs.defaultFS&lt;/name&gt;</span><br><span class="line">		&lt;value&gt;hdfs://myha01/&lt;/value&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">	&lt;!-- 指定hadoop临时目录 --&gt;</span><br><span class="line">	&lt;property&gt;</span><br><span class="line">		&lt;name&gt;hadoop.tmp.dir&lt;/name&gt;</span><br><span class="line">		&lt;value&gt;/home/hadoop/data1/hadoopdata/&lt;/value&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">	&lt;!-- 指定zookeeper地址 --&gt;</span><br><span class="line">	&lt;property&gt;</span><br><span class="line">		&lt;name&gt;ha.zookeeper.quorum&lt;/name&gt;</span><br><span class="line">		&lt;value&gt;hadoop01:2181,hadoop02:2181,hadoop03:2181,hadoop04:2181,hadoop05:2181&lt;/value&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">	&lt;!-- hadoop链接zookeeper的超时时长设置 --&gt;</span><br><span class="line">	&lt;property&gt;</span><br><span class="line">		&lt;name&gt;ha.zookeeper.session-timeout.ms&lt;/name&gt;</span><br><span class="line">		&lt;value&gt;1000&lt;/value&gt;</span><br><span class="line">		&lt;description&gt;ms&lt;/description&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></p>
<p>hdfs-site.xml:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line"></span><br><span class="line">	&lt;!-- 指定副本数--&gt;</span><br><span class="line">	&lt;property&gt;</span><br><span class="line">		&lt;name&gt;dfs.replication&lt;/name&gt;</span><br><span class="line">		&lt;value&gt;2&lt;/value&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;!-- 配置namenode和datanode的工作目录-数据存储目录--&gt;</span><br><span class="line">	&lt;property&gt;</span><br><span class="line">		&lt;name&gt;dfs.namenode.name.dir&lt;/name&gt;</span><br><span class="line">		&lt;value&gt;/home/hadoop/data1/hadoopdata/dfs/name&lt;/value&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;property&gt;</span><br><span class="line">		&lt;name&gt;dfs.datanode.data.dir&lt;/name&gt;</span><br><span class="line">		&lt;value&gt;/home/hadoop/data1/hadoopdata/dfs/data&lt;/value&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;!-- 启用webhdfs--&gt;</span><br><span class="line">	&lt;property&gt;</span><br><span class="line">		&lt;name&gt;dfs.webhdfs.enabled&lt;/name&gt;</span><br><span class="line">		&lt;value&gt;true&lt;/value&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;!--指定hdfs的nameservice为myha01，需要和core-site.xml中的保持一致 </span><br><span class="line">	     		dfs.ha.namenodes.[nameservice id]为在nameservice中的每一个NameNode设置唯一标示符。 </span><br><span class="line">		配置一个逗号分隔的NameNode ID列表。这将是被DataNode识别为所有的NameNode。 </span><br><span class="line">		例如，如果使用&quot;myha01&quot;作为nameservice ID，并且使用&quot;nn1&quot;和&quot;nn2&quot;作为NameNodes标示符 </span><br><span class="line">	--&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;property&gt;</span><br><span class="line">		&lt;name&gt;dfs.nameservices&lt;/name&gt;</span><br><span class="line">		&lt;value&gt;myha01&lt;/value&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;!-- myha01下面有两个NameNode,分别是nn1,nn2--&gt;</span><br><span class="line">	&lt;property&gt;</span><br><span class="line">		&lt;name&gt;dfs.ha.namenodes.myha01&lt;/name&gt;</span><br><span class="line">		&lt;value&gt;nn1,nn2&lt;/value&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;!-- nn1的RPC通信地址--&gt;</span><br><span class="line">	&lt;property&gt;</span><br><span class="line">		&lt;name&gt;dfs.namenode.rpc-address.myha01.nn1&lt;/name&gt;</span><br><span class="line">		&lt;value&gt;hadoop01:9000&lt;/value&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;!-- nn1的http通信地址--&gt;</span><br><span class="line">	&lt;property&gt;</span><br><span class="line">		&lt;name&gt;dfs.namenode.http-address.myha01.nn1&lt;/name&gt;</span><br><span class="line">		&lt;value&gt;hadoop01:50070&lt;/value&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;!-- nn2的RPC通信地址--&gt;</span><br><span class="line">	&lt;property&gt;</span><br><span class="line">		&lt;name&gt;dfs.namenode.rpc-address.myha01.nn2&lt;/name&gt;</span><br><span class="line">		&lt;value&gt;hadoop02:9000&lt;/value&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;!-- nn2的http通信地址 --&gt;</span><br><span class="line">	&lt;property&gt;</span><br><span class="line">		&lt;name&gt;dfs.namenode.http-address.myha01.nn2&lt;/name&gt;</span><br><span class="line">		&lt;value&gt;hadoop02:50070&lt;/value&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;!-- 指定NameNode的edits元数据的共享存储位置。也就是JournalNode列表 </span><br><span class="line">			该url的配置格式：qjournal://host1:port1;host2:port2;host3:port3/journalId </span><br><span class="line">	journalId推荐使用nameservice，默认端口号是：8485 --&gt;</span><br><span class="line">	&lt;property&gt;</span><br><span class="line">		&lt;name&gt;dfs.namenode.shared.edits.dir&lt;/name&gt;</span><br><span class="line">		&lt;value&gt;qjournal://hadoop02:8485;hadoop03:8485;hadoop04:8485/myha01&lt;/value&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;!-- 指定JournalNode在本地磁盘存放数据的位置--&gt;</span><br><span class="line">	&lt;property&gt;</span><br><span class="line">		&lt;name&gt;dfs.journalnode.edits.dir&lt;/name&gt;</span><br><span class="line">		&lt;value&gt;/home/hadoop/data1/journaldata&lt;/value&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;!-- 开启NameNode失败自动切换--&gt;</span><br><span class="line">	&lt;property&gt;</span><br><span class="line">		&lt;name&gt;dfs.ha.automatic-failover.enabled&lt;/name&gt;</span><br><span class="line">		&lt;value&gt;true&lt;/value&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;!-- 配置失败自动切换实现方式--&gt;</span><br><span class="line">	&lt;property&gt;</span><br><span class="line">		&lt;name&gt;dfs.client.failover.proxy.provider.myha01&lt;/name&gt;</span><br><span class="line">		&lt;value&gt;org.apache.hadoop.hdfs.server.namenode.ha.ConfiguredFailoverProxyProvider&lt;/value&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;!-- 配置隔离机制方法，多个机制用换行分割，即每个机制暂用一行--&gt;</span><br><span class="line">	&lt;property&gt;</span><br><span class="line">		&lt;name&gt;dfs.ha.fencing.methods&lt;/name&gt;</span><br><span class="line">		&lt;value&gt;</span><br><span class="line">			sshfence</span><br><span class="line">			shell(/bin/true)</span><br><span class="line">		&lt;/value&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;!-- 使用sshfence隔离机制时需要ssh免密登陆--&gt;</span><br><span class="line">	&lt;property&gt;</span><br><span class="line">		&lt;name&gt;dfs.ha.fencing.ssh.private-key-files&lt;/name&gt;</span><br><span class="line">		&lt;value&gt;/home/hadoop/.ssh/id_rsa&lt;/value&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;!-- 配置sshfence隔离机制赶超时间--&gt;</span><br><span class="line">	&lt;property&gt;</span><br><span class="line">		&lt;name&gt;dfs.ha.fencing.ssh.connect-timeout&lt;/name&gt;</span><br><span class="line">		&lt;value&gt;30000&lt;/value&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;property&gt;</span><br><span class="line">		&lt;name&gt;ha.failover-controller.cli-check.rpc-timeout.ms&lt;/name&gt;</span><br><span class="line">		&lt;value&gt;60000&lt;/value&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>
<p>mapred-site.xml:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">	&lt;!--指定mr框架为yarn方式--&gt;</span><br><span class="line">	&lt;property&gt;</span><br><span class="line">		&lt;name&gt;mapreduce.framework.name&lt;/name&gt;</span><br><span class="line">		&lt;value&gt;yarn&lt;/value&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;!--指定mapreduce jobhistory--&gt;</span><br><span class="line">	&lt;property&gt;</span><br><span class="line">		&lt;name&gt;mapreduce.jobhistory.address&lt;/name&gt;</span><br><span class="line">		&lt;value&gt;hadoop01:10020&lt;/value&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;!--任务历史服务器的web地址--&gt;</span><br><span class="line">	&lt;property&gt;</span><br><span class="line">		&lt;name&gt;mapreduce.jobhistory.webapp.address&lt;/name&gt;</span><br><span class="line">		&lt;value&gt;hadoop01:19888&lt;/value&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>
<p>yarn-site.xml</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line"></span><br><span class="line">	&lt;!-- 开启RM高可用--&gt;</span><br><span class="line">	&lt;property&gt;</span><br><span class="line">		&lt;name&gt;yarn.resourcemanager.ha.enabled&lt;/name&gt;</span><br><span class="line">		&lt;value&gt;true&lt;/value&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;!-- 指定RM的cluster id--&gt;</span><br><span class="line">	&lt;property&gt;</span><br><span class="line">		&lt;name&gt;yarn.resourcemanager.cluster-id&lt;/name&gt;</span><br><span class="line">		&lt;value&gt;yrc&lt;/value&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;!-- 指定RM的名字--&gt;</span><br><span class="line">	&lt;property&gt;</span><br><span class="line">		&lt;name&gt;yarn.resourcemanager.ha.rm-ids&lt;/name&gt;</span><br><span class="line">		&lt;value&gt;rm1,rm2&lt;/value&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;!--分别指定RM的地址--&gt;</span><br><span class="line">	&lt;property&gt;</span><br><span class="line">		&lt;name&gt;yarn.resourcemanager.hostname.rm1&lt;/name&gt;</span><br><span class="line">		&lt;value&gt;hadoop03&lt;/value&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;property&gt;</span><br><span class="line">		&lt;name&gt;yarn.resourcemanager.hostname.rm2&lt;/name&gt;</span><br><span class="line">		&lt;value&gt;hadoop04&lt;/value&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;!-- 指定zk集群地址--&gt;</span><br><span class="line">	&lt;property&gt;</span><br><span class="line">		&lt;name&gt;yarn.resourcemanager.zk-address&lt;/name&gt;</span><br><span class="line">		&lt;value&gt;hadoop01:2181,hadoop02:2181,hadoop03:2181,hadoop04:2181,hadoop05:2181&lt;/value&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;property&gt;</span><br><span class="line">		&lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;</span><br><span class="line">		&lt;value&gt;mapreduce_shuffle&lt;/value&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;property&gt;</span><br><span class="line">		&lt;name&gt;yarn.log-aggregation-enable&lt;/name&gt;</span><br><span class="line">		&lt;value&gt;true&lt;/value&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;property&gt;</span><br><span class="line">		&lt;name&gt;yarn.log-aggregation.retain-seconds&lt;/name&gt;</span><br><span class="line">		&lt;value&gt;86400&lt;/value&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;!--启用自动恢复--&gt;</span><br><span class="line">	&lt;property&gt;</span><br><span class="line">		&lt;name&gt;yarn.resourcemanager.recovery.enabled&lt;/name&gt;</span><br><span class="line">		&lt;value&gt;true&lt;/value&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;!-- 制定resourcemanager的状态信息存储在zookeeper集群上 --&gt;</span><br><span class="line">	&lt;property&gt;</span><br><span class="line">		&lt;name&gt;yarn.resourcemanager.store.class&lt;/name&gt;</span><br><span class="line">		&lt;value&gt;org.apache.hadoop.yarn.server.resourcemanager.recovery.ZKRMStateStore&lt;/value&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>
<p>hadoop-env.sh: 修改JAVA_HOME<br>slaves文件：修改映射</p>
<p>#注意：配置文件是最容易出错的地方，建议复制，不建议手写，容易出错。格式化namenode之后，如果出错了，建议删除临时文件日志目录，每台机器都要删除，重新格式化，注意顺序步骤。</p>
<p>如果DFSZKFailoverController自动死掉，则有可能是因为以下配置问题：<br>错误配置，会导致DFSZKFailoverController死掉：<br><img src="https://img-blog.csdn.net/20180324192833687?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2R1ZGVmdTAxMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>正确写法，注意sshfence不能换行：<br><img src="https://img-blog.csdn.net/20180324192845271?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2R1ZGVmdTAxMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<h2 id="分发安装包到其他机器"><a href="#分发安装包到其他机器" class="headerlink" title="分发安装包到其他机器"></a>分发安装包到其他机器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scp -r hadoop-2.7.5 hadoop@hadoop02:$PWD</span><br><span class="line">scp -r hadoop-2.7.5 hadoop@hadoop03:$PWD</span><br><span class="line">scp -r hadoop-2.7.5 hadoop@hadoop04:$PWD</span><br><span class="line">scp -r hadoop-2.7.5 hadoop@hadoop05:$PWD</span><br></pre></td></tr></table></figure>
<h2 id="并分别配置环境变量"><a href="#并分别配置环境变量" class="headerlink" title="并分别配置环境变量"></a>并分别配置环境变量</h2><p>vi ~/.bashrc<br>添加两行：<br>export HADOOP_HOME=/home/hadoop/apps/hadoop-2.6.5<br>export PATH=$PATH:$HADOOP_HOME/bin:$HADOOP_HOME/sbin<br>保存退出</p>
<h2 id="集群初始化操作：（注意：严格按照以下步骤执行）"><a href="#集群初始化操作：（注意：严格按照以下步骤执行）" class="headerlink" title="集群初始化操作：（注意：严格按照以下步骤执行）"></a>集群初始化操作：（注意：严格按照以下步骤执行）</h2><p>1、 先启动 zookeeper 集群<br>启动：zkServer.sh start<br>检查启动是否正常：zkServer.sh status<br>2、 分别在每个 zookeeper（也就是规划的三个 journalnode 节点，不一定跟 zookeeper<br>节点一样）节点上启动 journalnode 进程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@hadoop01 ~]$ hadoop-daemon.sh start journalnode</span><br><span class="line">[hadoop@hadoop02 ~]$ hadoop-daemon.sh start journalnode</span><br><span class="line">[hadoop@hadoop03 ~]$ hadoop-daemon.sh start journalnode</span><br><span class="line">[hadoop@hadoop04 ~]$ hadoop-daemon.sh start journalnode</span><br><span class="line">[hadoop@hadoop05 ~]$ hadoop-daemon.sh start journalnode</span><br></pre></td></tr></table></figure>
<p>然后用 jps 命令查看是否各个 datanode 节点上都启动了 journalnode 进程<br>如果报错，根据错误提示改进<br>3、在第一个 namenode 上执行格式化操作<br>然后会在 core-site.xml 中配置的临时目录中生成一些集群的信息<br>把他拷贝的第二个 namenode 的相同目录下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;name&gt;hadoop.tmp.dir&lt;/name&gt;</span><br><span class="line">&lt;value&gt;/home/hadoop/data/hadoopdata/&lt;/value&gt;</span><br></pre></td></tr></table></figure></p>
<p>这个目录下，千万记住：两个 namenode 节点该目录中的数据结构是一致的<br>[hadoop@hadoop02 ~]$ scp -r ~/data/hadoopdata/ hadoop03:~/data<br>或者也可以在另一个 namenode 上执行：hadoop namenode -bootstrapStandby</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@hadoop02 ~]$ hadoop namenode -format</span><br></pre></td></tr></table></figure>
<p>4、格式化 ZKFC</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@hadoop02 ~]$ hdfs zkfc -formatZK</span><br></pre></td></tr></table></figure>
<p>在第一台机器上即可<br>5、启动 HDFS</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@hadoop02 ~]$ start-dfs.sh</span><br></pre></td></tr></table></figure>
<p>查看各节点进程是否启动正常：依次为 2345 四台机器的进程</p>
<h2 id="最终效果："><a href="#最终效果：" class="headerlink" title="最终效果："></a>最终效果：</h2><p>访问 web 页面 <span class="exturl" data-url="aHR0cDovL2hhZG9vcDAxOjUwMDcw" title="http://hadoop01:50070">http://hadoop01:50070<i class="fa fa-external-link"></i></span><br><img src="https://img-blog.csdn.net/20180324181322961?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2R1ZGVmdTAxMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="http://hadoop02:50070"><br>访问 web 页面 <span class="exturl" data-url="aHR0cDovL2hhZG9vcDAyOjUwMDcw" title="http://hadoop02:50070">http://hadoop02:50070<i class="fa fa-external-link"></i></span><br><img src="https://img-blog.csdn.net/20180324181415193?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2R1ZGVmdTAxMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><img src="https://img-blog.csdn.net/20180324181335196?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2R1ZGVmdTAxMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><img src="https://img-blog.csdn.net/20180324181353110?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2R1ZGVmdTAxMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<h2 id="启动-YARN"><a href="#启动-YARN" class="headerlink" title="启动 YARN"></a>启动 YARN</h2><p>[hadoop@hadoop04 ~]$ start-yarn.sh<br>在主备 resourcemanager 中随便选择一台进行启动，正常启动之后，检查各节点的进程：<br>若备用节点的 resourcemanager 没有启动起来，则手动启动起来<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@hadoop04 ~]$ yarn-daemon.sh start resourcemanager</span><br></pre></td></tr></table></figure></p>
<p>访问页面：<span class="exturl" data-url="aHR0cDovL2hhZG9vcDAzOjgwODg=" title="http://hadoop03:8088">http://hadoop03:8088<i class="fa fa-external-link"></i></span><br><img src="https://img-blog.csdn.net/20180324181845442?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2R1ZGVmdTAxMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>访问页面：<span class="exturl" data-url="aHR0cDovL2hhZG9vcDA0OjgwODg=" title="http://hadoop04:8088">http://hadoop04:8088<i class="fa fa-external-link"></i></span> 自动跳转至hadoop03机器<br><img src="https://img-blog.csdn.net/20180324181852559?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2R1ZGVmdTAxMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<h2 id="查看各主节点的状态"><a href="#查看各主节点的状态" class="headerlink" title="查看各主节点的状态"></a>查看各主节点的状态</h2><p>HDFS:<br>hdfs haadmin -getServiceState nn1<br>hdfs haadmin -getServiceState nn2<br><img src="https://img-blog.csdn.net/20180324182718707?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2R1ZGVmdTAxMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>YARN:<br>yarn rmadmin -getServiceState rm1<br>yarn rmadmin -getServiceState rm2<br><img src="https://img-blog.csdn.net/20180324182811489?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2R1ZGVmdTAxMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<h2 id="启动-mapreduce-任务历史服务器"><a href="#启动-mapreduce-任务历史服务器" class="headerlink" title="启动 mapreduce 任务历史服务器"></a>启动 mapreduce 任务历史服务器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@hadoop01 ~]$ mr-jobhistory-daemon.sh start historyserver</span><br></pre></td></tr></table></figure>
<p>按照配置文件配置的历史服务器的 web 访问地址去访问：<br><span class="exturl" data-url="aHR0cDovL2hhZG9vcDAxOjE5ODg4" title="http://hadoop01:19888">http://hadoop01:19888<i class="fa fa-external-link"></i></span><br><img src="https://img-blog.csdn.net/20180324183754653?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2R1ZGVmdTAxMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<h2 id="集群启动测试"><a href="#集群启动测试" class="headerlink" title="集群启动测试"></a>集群启动测试</h2><p>1、干掉 active namenode， 看看集群有什么变化<br>      干掉active namenode，standby namenode瞬间转为active状态；重新启动刚才那台干掉的节点后，该节点变为standby 状态。<br>2、在上传文件的时候干掉 active namenode， 看看有什么变化<br>        会报错，但是可以上传成功。<br>3、干掉 active resourcemanager， 看看集群有什么变化<br>    hadoop03上的yarn节点就不能访问，hadoop05上的yarn节点可以正常访问。<br>4、在执行任务的时候干掉 active resourcemanager，看看集群<br>    执行wordcount程序，执行的时候，在hadoop03节点上杀死ResourceManager，最终能够成功执行。</p>
]]></content>
      
        <categories>
            
            <category> 大数据 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hadoop </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[在大数据环境中执行情感分析]]></title>
      <url>/%E5%9C%A8%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%8E%AF%E5%A2%83%E4%B8%AD%E6%89%A7%E8%A1%8C%E6%83%85%E6%84%9F%E5%88%86%E6%9E%90.html</url>
      <content type="html"><![CDATA[<h2 id="情感分析"><a href="#情感分析" class="headerlink" title="情感分析"></a>情感分析</h2><p>情感分析是利用文本分析来挖掘各种观点的数据来源的过程。通常情况下，情感分析是在从互联网和各种社交媒体平台收集的数据上执行的。政治家和政府经常利用情感分析来了解人们如何看待他们和他们的政策。<br>随着社交媒体的出现，人们可以从各种不同来源（比如移动设备和 Web 浏览器）捕获数据，并用不同的数据格式存储这些数据。由于社交媒体内容对于传统存储系统（比如 RDBMS、关系数据库管理系统）是非结构化的，所以我们需要一些可以处理和分析各种不同数据的工具。不过，大数据技术旨在处理不同来源、不同格式的结构化和非结构化数据。在本文中，我将介绍如何利用大数据工具来捕获数据，以便存储和处理用于情感分析的数据。<br><a id="more"></a></p>
<h2 id="处理大数据"><a href="#处理大数据" class="headerlink" title="处理大数据"></a>处理大数据</h2><p>无论何时从采用多种格式（结构化、半结构化或非结构化的）的多个来源收集数据，都需要考虑建立一个 Hadoop 集群和一个 Hadoop 分布式文件系统（HDFS）来存储数据。HDFS 提供了一种管理大数据的灵活方式：</p>
<ul>
<li>可以将您的一些分析数据移动到现有的关系数据库管理系统（RDBMS）中，比如 Oracle 或 MySQL，这样您就可以利用现有的 BI 和报告工具。</li>
<li>可以将数据存储在 HDFS 中，供将来分析使用，例如，通过执行像 ANOVA.T 这样的测试来比较旧数据与新数据。</li>
<li>如果只需要分析数据的影响，那么可以删除这些数据。<br>要了解如何设置 Hadoop 集群，请将数据导入 HDFS，然后在您的 Hadoop 环境中分析这些数据，请参阅我的其他 developerWorks 文章， “<span class="exturl" data-url="aHR0cHM6Ly93d3cuaWJtLmNvbS9kZXZlbG9wZXJ3b3Jrcy9jbi9kYXRhL2xpYnJhcnkvYmEvYmEtaGFkb29wLXJkYm1zLw==" title="https://www.ibm.com/developerworks/cn/data/library/ba/ba-hadoop-rdbms/">将 Hadoop 与现有的 RDBMS 相集成<i class="fa fa-external-link"></i></span>“。<h2 id="检索数据并将数据存储在-HDFS-中"><a href="#检索数据并将数据存储在-HDFS-中" class="headerlink" title="检索数据并将数据存储在 HDFS 中"></a>检索数据并将数据存储在 HDFS 中</h2>最好的情感分析包括来自多个来源的数据。在本文中，我将介绍如何从这些来源中检索数据：</li>
<li>Twitter 提要</li>
<li>RSS 提要</li>
<li>移动应用程序<br>我还将解释如何将来自不同来源的数据存储在 HDFS 中（存储在您的 Hadoop 集群中）。<h2 id="从-Twitter-提要中检索数据"><a href="#从-Twitter-提要中检索数据" class="headerlink" title="从 Twitter 提要中检索数据"></a>从 Twitter 提要中检索数据</h2>Twitter（一种流行的微博网站）有一组 API，它们使得我们能够检索和操作 tweet。但是首先，我们需要实现 Twitter 的 OAuth 框架。简单地讲，有了这个框架，应用程序就可以代表您登录到 Twitter，无需您登录到 Twitter 网站。查看 <span class="exturl" data-url="aHR0cHM6Ly9kZXYudHdpdHRlci5jb20vb2F1dGgvb3ZlcnZpZXcvaW50cm9kdWN0aW9u" title="https://dev.twitter.com/oauth/overview/introduction">Twitter 开发人员站点的设置过程<i class="fa fa-external-link"></i></span>，其中解释了如何指派实现此操作的应用程序。在这个过程中，会为您分配一个密钥和一个密钥令牌，您的应用程序将使用它们来代表您执行身份验证。在您的应用程序完成身份验证后，您就可以使用 Twitter API 来获取 tweet。<br>您可以通过使用 R 或通过使用 Jaql 获取来自 Twitter 提要的数据。因为 Jaql 被设计用于处理 JSON 数据，所以它是适用于 tweet 的默认数据格式，使用 Jaql 可能更简单一些。有人可能会决定使用 R，这样做可能纯粹是因为他们自己的 R 技能。<h3 id="通过使用-Jaql-检索来自-Twitter-的数据"><a href="#通过使用-Jaql-检索来自-Twitter-的数据" class="headerlink" title="通过使用 Jaql 检索来自 Twitter 的数据"></a>通过使用 Jaql 检索来自 Twitter 的数据</h3>在您的应用程序完成身份验证后，我们就可以使用 Twitter API 来获取 tweet。<br>因为我们想要在流化模式下，所以我们的 Twitter URL 是：<br>url = “<span class="exturl" data-url="aHR0cHM6Ly9zdHJlYW0udHdpdHRlci5jb20vMS4xL3N0YXR1c2VzL2ZpbHRlci5qc29uP3RyYWNrPWdvdmVybm1lbnRUb3BpYw==" title="https://stream.twitter.com/1.1/statuses/filter.json?track=governmentTopic">https://stream.twitter.com/1.1/statuses/filter.json?track=governmentTopic<i class="fa fa-external-link"></i></span>“;<br>使用我们正在挖掘的政府主题的名称来替换 governmentTopic。通过使用与以下代码类似的代码，我们可以用一个变量来获取 tweet：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jsonResultTweets = read(http(url));</span><br><span class="line">jsonResultTweets;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>在运行 Jaql 脚本时，它会提取与政府主题相关的 tweet。这些 tweet 是以 JSON 格式返回的。<br>如果我们想通过位置知道关于我们的政府主题的讨论范围，可以使用下面的代码片段来获取 tweet：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">governmentTopicDiscussionByLocation = jsonResultTweets -&gt; transform</span><br><span class="line">&#123;location: $.location,user_id: $.from_user_id_str,date_created:</span><br><span class="line">$.created_at,comment:$text&#125; -&gt; group by key = $.location</span><br></pre></td></tr></table></figure></p>
<p>然后，我们可以使用下面的代码片段将此信息存储到您的 HDFS 中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">governmentTopicDiscussionByLocation Cnt -&gt;</span><br><span class="line">write(del(&quot;/user/governmentTopics/governmentTopic_1Tweets.del&quot;, schema =</span><br><span class="line">schema &#123; list_of_comma_seperated_json_fields&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中的 list_of_comma_seperated_json_fields 是一些逗号分隔的字段：location、from_user_id_str 和 created_at。<br>这样就可以通过 Oozie 工作流来运行整个 Jaql 脚本，代码可能类似于以下代码示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">url = &quot;https://stream.twitter.com/1.1/statuses/filter.json?track=governmentTopic&quot;; </span><br><span class="line"> jsonResultTweets = read(http(url));</span><br><span class="line">jsonResultTweets;</span><br><span class="line">governmentTopicDiscussionByLocation = jsonResultTweets -&gt; </span><br><span class="line">transform &#123;location: $.location,user_id: $.from_user_id_str,user_name:</span><br><span class="line">  $.user.name,user_location: $.user.location,date_created: $.created_at,comment: $.text&#125; -&gt; </span><br><span class="line">group by key = $.location </span><br><span class="line">governmentTopicDiscussionByLocation -&gt; </span><br><span class="line">write(del(&quot;/user/governmentTopics/governmentTopic_1Tweets.del&quot;, </span><br><span class="line">  schema = schema &#123;location,user_id,user_name,user_location,date_created,comment&#125;</span><br></pre></td></tr></table></figure></p>
<p>transform 方法将会清除数据，而 write 方法会将数据保存到 HDFS。要处理流数据或动态数据，需要将此脚本与 Flume 整合，Flume 是 Apache Hadoop 生态系统中的另一个大数据工具。（您可以通过阅读了解有关此 developerWorks 文章中的 Flume 的更多信息，”使用 Flume 部署和管理可扩展的 Web 服务”。）<br>通过使用 R 从 Twitter 中检索数据<br>要使用 R 检索 tweet，需要在您的系统上安装某些软件包。虽然我们可以使用 RStudio，但下面这些步骤显示了如何设置和使用 R 控制台。<br>在 Ubuntu 电脑上，我完成了下面这些步骤来安装必要的 R 软件包：<br>安装这些软件包：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">libcurl4-gnutls-dev </span><br><span class="line">libcurl4-nss-dev </span><br><span class="line">libcurl4-openssl-dev </span><br><span class="line">r-base r-base-dev</span><br><span class="line">r-cran-rjson</span><br></pre></td></tr></table></figure></p>
<p>打开 R 控制台，并运行这些命令来安装这些包来访问 Twitter：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">install.packages(“twitteR”)</span><br><span class="line">install.packages(“ROAuth”)</span><br><span class="line">install.packages(“RCurl”)</span><br></pre></td></tr></table></figure></p>
<p>将这些库加载到您的 R 工作区中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rm(list=ls())</span><br><span class="line">library(twitteR)</span><br><span class="line">library(ROAuth)</span><br><span class="line">library(RCurl)</span><br></pre></td></tr></table></figure></p>
<p>现在，我们可以用下面的 R 脚本对 Twitter 进行身份验证：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">download.file(url=&quot;http://curl.haxx.se/ca/cacert.pem&quot;,destfile=&quot;cacert.pem&quot;)</span><br><span class="line">requestURL &lt;- &quot;https://api.twitter.com/oauth/request_token&quot;</span><br><span class="line">accessURL &lt;- &quot;https://api.twitter.com/oauth/access_token&quot;</span><br><span class="line">authURL &lt;- &quot;https://api.twitter.com/oauth/authorize&quot;</span><br><span class="line">consumerKey &lt;- myConsumerKeyFromTwitter</span><br><span class="line">consumerSecret &lt;- myConsumerSeccretFromTwitter</span><br><span class="line">myCred &lt;- OAuthFactory$new(consumerKey=consumerKey,</span><br><span class="line">                             consumerSecret=consumerSecret,</span><br><span class="line">                             requestURL=requestURL,</span><br><span class="line">                             accessURL=accessURL,</span><br><span class="line">                             authURL=authURL)</span><br><span class="line"> </span><br><span class="line">accessToken &lt;- myAccessTokenFromTwitter</span><br><span class="line">accessSecret &lt;- myAccessSecretFromTwitter</span><br><span class="line"> </span><br><span class="line">setup_twitter_oauth(consumerKey,consumerSecret,accessToken,accessSecret)</span><br></pre></td></tr></table></figure></p>
<p>然后，我们可以使用下面的代码片段来获取 tweet：<br>govt_sentiment_data &lt;- searchTwitter(“#keyWord”,since={last_date_pulled}<br>keyWord 是您要分析的政府主题，last_date_pulled 是您最后一次获取 tweet 的日期。<br>如果您想要按固定时间间隔自动流化 Twitter 数据和拉取数据，可以使用以下代码片段替换前面的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">govt_sentiment_data &lt;- filterStream( file=&quot;tweets_rstats.json&quot;,</span><br><span class="line">track=&quot;#keyWord&quot;, timeout=3600, oauth=myCred)</span><br></pre></td></tr></table></figure></p>
<p>我们可以用下面的 R 脚本来清理数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">govt_sentiment_data_txt = govt_sentiment_data$text</span><br><span class="line"># remove retweet entities</span><br><span class="line">govt_sentiment_data_txt = gsub(“(RT|via)((?:\\b\\W*@\\w+)+)”, “”, tweet_txt)</span><br><span class="line"># remove at people</span><br><span class="line">govt_sentiment_data_txt = gsub(“@\\w+”, “”, tweet_txt)</span><br><span class="line"># remove punctuation</span><br><span class="line">govt_sentiment_data_txt = gsub(“[[:punct:]]”, “”, tweet_txt)</span><br><span class="line"># remove numbers</span><br><span class="line">govt_sentiment_data_txt = gsub(“[[:digit:]]”, “”, tweet_txt)</span><br><span class="line"># remove html links</span><br><span class="line">govt_sentiment_data_txt = gsub(“http\\w+”, “”, tweet_txt)</span><br><span class="line"># remove unnecessary spaces</span><br><span class="line">govt_sentiment_data_txt = gsub(“[ \t]&#123;2,&#125;”, “”, tweet_txt)</span><br><span class="line">govt_sentiment_data_txt = gsub(“^\\s+|\\s+$”, “”, tweet_txt)</span><br><span class="line">govt_sentiment_data_txt=gsub(“[^0-9a-zA-Z ,./?&gt;&lt;:;’~`!@#&amp;*’]”,””, tweet_txt)</span><br></pre></td></tr></table></figure></p>
<p>最后，要将已清理的数据保存到您的 HDFS，可以使用下面的代码片段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hdfsFile &lt;- hdfs.file(&quot;/tmp/govt_sentiment_data.txt&quot;, &quot;w&quot;)</span><br><span class="line">hdfs.write(govt_sentiment_data_txt, hdfsFile)</span><br><span class="line">hdfs.close(hdfsFile)</span><br><span class="line">write(govt_sentiment_data, &quot;govt_sentiment_data.txt&quot;)</span><br></pre></td></tr></table></figure></p>
<p>从 RSS 提要检索数据<br>除了 tweet 之外，我们还想从新闻文章中收集个人意见或观点。对于这种类型的数据，建议您组合使用 Java 和 Rome 工具从 RSS 提要中获取数据。Rome 是一个 Java 库，用于访问和操纵网络上的新闻提要。<br>在本示例中，我们获得了有关新闻文章的以下信息：标题、链接和描述。然后，我们从这些数据点提取我们所需的信息。<br>要确定将要使用的新闻提要，需要使用某种形式的网页排名 技术。该技术被用在搜索算法中，用于确定某一事项在其引用和普及方面的相关性。基本原理是，被外部实体点击或引用的几率越高，优先级就越高，因此就会出现在搜索结果的顶部。<br>下面的 Java 代码标识了一些新闻提要和使用网页排名，以确定它们与我们的数据相关：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">private static void getFeeds(String newsFeedUrlLink)&#123;</span><br><span class="line"> </span><br><span class="line">File f = new File(“newsFeeds.txt”);</span><br><span class="line">        boolean ok = false;</span><br><span class="line">            try &#123;</span><br><span class="line">                URL feedUrl = new URL(newsFeedUrlLink);</span><br><span class="line">                SyndFeedInput input = new SyndFeedInput();</span><br><span class="line">                InputSource source = new InputSource(feedUrl.openStream());</span><br><span class="line">                SyndFeed feed = input.build(source);</span><br><span class="line">                for (Iterator i = feed.getEntries().iterator(); i.hasNext();) &#123;</span><br><span class="line">                   SyndEntry entry = (SyndEntry) i.next();</span><br><span class="line">         writeToFile(f,entry);</span><br><span class="line">                       &#125;</span><br><span class="line">                ok = true;</span><br><span class="line"> </span><br><span class="line">            &#125;</span><br><span class="line">            catch (Exception ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">                System.out.println(&quot;ERROR: &quot;+ex.getMessage());</span><br><span class="line"> </span><br><span class="line">            &#125;</span><br><span class="line">        if (!ok) &#123;</span><br><span class="line">            System.out.println();</span><br><span class="line">            System.out.println(&quot;FeedReader reads and prints any RSS/Atom feed type.&quot;);</span><br><span class="line">            System.out.println(&quot;The first parameter must be the URL of the feed to read.&quot;);</span><br><span class="line">            System.out.println();</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">private static void writeToFile(File f, SyndEntry entry) throws IOException &#123;</span><br><span class="line">        FileWriter fw = new FileWriter(f.getName(),true);</span><br><span class="line">           BufferedWriter bw = new BufferedWriter(fw);</span><br><span class="line">           bw.write(entry.getTitle()+”\n”);</span><br><span class="line">           bw.close();</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来，我们可以使用下面的代码片段将数据存储在我们使用 Twitter 数据创建的 HDFS 文件中。要将此数据添加到我们使用 Twitter 数据创建的 HDFS 文件中，必须修改 hdfs-site.xml 文件中的 dfs.support.append 属性值，因为 HDFS 默认情况下不允许将数据添加到文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mydata &lt;- readLines(&quot;newsFeeds.txt&quot;)</span><br><span class="line">myfile &lt;-  hdfs.file(&quot;/tmp/govt_sentiment_data.txt&quot;, &quot;r&quot;)</span><br><span class="line">dfserialized &lt;- hdfs.read(myfile)</span><br><span class="line">df &lt;- unserialize(dfserialized)</span><br><span class="line">hdfs.close(myfile)</span><br><span class="line"> </span><br><span class="line">//write(mydata, file = &quot;/tmp/govt_sentiment_data.txt&quot;,append = TRUE)</span><br><span class="line">hdfs.write(mydata, file = &quot;/tmp/govt_sentiment_data.txt&quot;,append = TRUE)</span><br><span class="line">government_sentiment_data &lt;- read.hdfs(“/tmp/govt_sentiment_data.txt”)</span><br></pre></td></tr></table></figure></p>
<p>从移动应用程序中检索数据<br>除了 Twitter 数据和 RSS 提要数据之外，我们还可以从包含个人意见和观点的移动应用程序中收集数据。在本示例中，我假设您创建了一个简单的移动应用程序，该应用程序已安装在允许用户提供关于政府主题或政策的意见的移动设备上。可以将 J2ME 应用程序上传到某个 WAP 服务器，移动设备（甚至是像诺基亚 3310 这样的老款设备）可以从该服务器下载和安装应用程序。用户提供的信息被发送回一个 RDBMS 并进行储存，以供将来分析使用。<br>您可以使用 Sqoop 将数据从 RDBMS 服务器移动到我们的 Hadoop 集群。在 Hadoop 集群上运行 sqoop 脚本的以下行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sqoop import --options-file dbCredentials.txt --connect</span><br><span class="line">jdbc:mysql://217.8.156.117/govt_policy_app --table opinions –-target-dir /tmp \ --append</span><br></pre></td></tr></table></figure></p>
<p>–append 标记告诉 Sqoop 将导入的数据添加到我们已经从以前的数据来源获得的数据集中，该数据集通过 –target-dir 标记来指示。<br>将已收集的数据合并成一个数据源<br>在收集了来自 Twitter 的数据（通过使用 Jaql 或 R）、来自 RSS 提要的数据（通过使用 Java）和来自移动应用程序的数据（通过使用 Sqoop）后，我们会将数据添加到单个 HDFS 文件中。可以通过实现了 Oozie 工作流引擎来自动化这些脚本，并设置命令来按照某个时间间隔运行脚本，或者作为触发事件发生的结果。有关如何设置 Sqoop 和 Oozie 的更多信息，请参阅我的其他 developerWorks 文章，”将 Hadoop 与现有的 RDBMS 相集成”。<br>您可以增强您的 Oozie 工作流程，以便实现减少重复数据的限制，重复数据是整合来自不同来源的数据所导致的。例如，您可能会限制每个话题一个 Twitter 句柄，在您的数据集中，每个观点一个移动号码。<br>在组合数据上执行情感分析<br>在组合数据之后，我们就可以在单个数据源上完成情感分析，这使我们可以获得分析的统一性、一致性和准确性。您可以使用 R、Jaql、Pig 或 Hive 来执行这些分析。Pig 和 Hive 是具有类似 SQL 的语法的语言，运行在 Hadoop 平台上。本例中，我决定用 R 来分析检索数据，因为 R 具有用于图形表示的丰富的内置模型函数和库，比如 ggplot2。<br>要完成情感分析，需要有一个词典或单词列表。字典包括一组描述某一范围内的积极词和消极词的标准单词。词典确定了社交媒体中常常使用的嘲讽词、影射词、俚语、新词汇、字符和表情。这些词汇列表可从互联网上获得，定期更新，并整合到我们的情感分析逻辑中。<br>以下代码利用了检索到的数据，并将它们与我们的单词列表相匹配，以获得积极词和消极词的数量。积极词和消极词的总数差距为我们提供了一个得分，该得分指示了我们的数据对于我们要分析的政府主题是积极的还是消极的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sentiment.pos=scan(&apos;/Users/charles/Downloads/r/positive-words.txt&apos;,what=&apos;character&apos;,comment.char=&apos;;&apos;)</span><br><span class="line">sentiment.neg=scan(&apos;/Users/charles/Downloads/r/negative-words.txt&apos;,what=&apos;character&apos;,comment.char=&apos;;&apos;)</span><br><span class="line">pos.words=c(sentiment.pos,&apos;good&apos;,&apos;reelect&apos;,&apos;accountable&apos;,&apos;stable&apos;)</span><br><span class="line">neg.words=c(sentiment.neg,&apos;bad&apos;,&apos;corrupt&apos;,&apos;greedy&apos;,&apos;unstable&apos;)</span><br></pre></td></tr></table></figure></p>
<p>此外，以下代码表示了情感评分算法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">require(plyr)</span><br><span class="line">require(stringr)</span><br><span class="line">score.sentiment = function(sentences, pos.words, neg.words, .progress=&apos;none&apos;)</span><br><span class="line">&#123;</span><br><span class="line">sentence = tolower(sentence)</span><br><span class="line">word.list = str_split(sentence, &apos;\\s+&apos;)</span><br><span class="line">words = unlist(word.list)</span><br><span class="line">pos.matches = match(words, pos.words)</span><br><span class="line">neg.matches = match(words, neg.words)</span><br><span class="line">pos.matches = !is.na(pos.matches)</span><br><span class="line">neg.matches = !is.na(neg.matches)</span><br><span class="line">score = sum(pos.matches) - sum(neg.matches)</span><br><span class="line">return(score)</span><br><span class="line">&#125;, pos.words, neg.words, .progress=.progress )</span><br><span class="line">scores.df = data.frame(score=scores, text=sentences)</span><br><span class="line">return(scores.df)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后，我们可以通过使用下面的代码片段，调用情感得分算法函数来计算数据的得分：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">require(plyr)</span><br><span class="line">opinion.score &lt;- score.sentiment(opinion.txt,pos.words,neg.words,progress=&apos;text&apos;)</span><br></pre></td></tr></table></figure></p>
<p>最后，我们可以通过使用 R 的内置图表和图形功能，对得分数据执行进一步分析，并通过使用下面的代码片段，绘制一幅图表来显示分数条：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">library(&quot;ggplot2&quot;)</span><br><span class="line">hist(opinion.scores$score)</span><br><span class="line">qplot(opinion.scores$score)</span><br></pre></td></tr></table></figure></p>
<p>您可以通过使用 BigSheets 进一步地分析数据，BigSheets 由 IBM InfoSphere BigInsights 提供。该工具使得非技术用户可以进行各种分析，并用图表查看数据。有关如何使用 BigSheets 工具的更多信息，请阅读 developerWorks 文章 “适用于普通人的 BigSheets”。<br>结束语<br>大数据工具可以根据来自任何来源或空间的数据，提供不带偏见的洞察，从而制定正确的、准确的决策，并实施这些决策。通过采用大数据工具，比如本文中所描述的那些工具，您可以轻松地实现自己的投资回报。</p>
]]></content>
      
        <categories>
            
            <category> 大数据 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 情感数据分析 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[金融行业大数据用户画像实践]]></title>
      <url>/%E9%87%91%E8%9E%8D%E8%A1%8C%E4%B8%9A%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%94%A8%E6%88%B7%E7%94%BB%E5%83%8F%E5%AE%9E%E8%B7%B5.html</url>
      <content type="html"><![CDATA[<p><strong>金融消费者逐渐年轻化，80、90后成为客户主力，他们的消费意识和金融意识正在增强。金融服务正在从以产品为中心，转向以消费者为中心。所有金融行业面对的最大挑战是消费者的消费行为和消费需求的转变，金融企业迫切需要为产品寻找目标客户和为客户定制产品。</strong><br>进入移动互联网时代之后，金融业务地域限制被打破。金融企业没有固定业务区域，金融服务面对所有用户是平的。<br>金融消费者逐渐年轻化，80、90后成为客户主力，他们的消费意识和金融意识正在增强。金融服务正在从以产品为中心，转向以消费者为中心。所有金融行业面对的最大挑战是消费者的消费行为和消费需求的转变，金融企业迫切需要为产品寻找目标客户和为客户定制产品。<br><a id="more"></a></p>
<h2 id="一、用户画像背后的原因"><a href="#一、用户画像背后的原因" class="headerlink" title="一、用户画像背后的原因"></a>一、用户画像背后的原因</h2><h3 id="1、金融消费行为的改变，企业无法接触到客户"><a href="#1、金融消费行为的改变，企业无法接触到客户" class="headerlink" title="1、金融消费行为的改变，企业无法接触到客户"></a>1、金融消费行为的改变，企业无法接触到客户</h3><p>80后、90后总计共有3.4亿人口，并日益成为金融企业主要的消费者，但是他们的金融消费习惯正在改变，他们不愿意到金融网点办理业务，不喜欢被动接受金融产品和服务。年轻人将主要的时间都消费在移动互联网，消费在智能手机上。平均每个人，每天使用智能手机的时间超过了3小时，年轻人可能会超过4个小时。浏览手机已经成为工作和睡觉之后的，人类第三大生活习惯，移动APP也成为所有金融企业的客户入口、服务入口、消费入口、数据入口。<br>金融企业越来越难面对面接触到年轻人，无法像过去一样，从对话中了解年轻人的想法，了解年轻人金融产品的需求。</p>
<h3 id="2、消费者需求出现分化，需要寻找目标客户"><a href="#2、消费者需求出现分化，需要寻找目标客户" class="headerlink" title="2、消费者需求出现分化，需要寻找目标客户"></a>2、消费者需求出现分化，需要寻找目标客户</h3><p>客户群体正在出现分化，市场上很少有一种产品和一种金融服务可以满足所有用户的需求。金融产品也需要进行细化，为不同客户提供不同产品。<br>金融企业面对的客户群体基数很大，有的客户高风险偏好高，希望高风险高收益;有的客户风险偏好低，希望稳健收益;有的客户金融理财意识低，只需服务较好即可;有的客户完全没有主意，你说是啥就是啥;有的客户注重体验，有的客户注重实惠，有的客户注重品牌，有的客户注重风险等等。不同年龄，不同收入，不同职业，不同资产的客户对金融产品的需求都不尽相同。金融企业需要为不同的客户定制产品，满足不同客户的需要。对于金融企业，理财和消费是主要的业务需求。<br>客户消费习惯的改变，企业无法接触到客户，无法了解客户需求;<br>客户需求的分化，企业需要细分客户，为目标客户开发设计产品。<br>金融企业需要借助于户画像，来了解客户，找到目标客户，触达客户。</p>
<h2 id="二、用户画像的目的"><a href="#二、用户画像的目的" class="headerlink" title="二、用户画像的目的"></a>二、用户画像的目的</h2><p>用户画像是在解客户需求和消费能力，以及客户信用额度的基础上，寻找潜在产品的目标客户，并利用画像信息为客户开发产品。<br>提到用户画像，很多厂商都会提到360度用户画像，其实经常360度客户画像是一个广告宣传用语，根本不存数据可以全面描述客户，透彻了解客户。人是非常复杂的动物，信息纬度非常复杂，仅仅依靠外部信息来刻画客户内心需要根本不可能。<br>用户画像一词具有很重的场景因素，不同企业对于用户画像有着不同对理解和需求。举个例子，金融行业和汽车行业对于用户画像需求的信息完全不一样，信息纬度也不同，对画像结果要求也不同。每个行业都有一套适合自己行业的用户画像方法，但是其核心都是为客户服务，为业务场景服务。<br>用户画像本质就是从业务角度出发对用户进行分析，了解用户需求，寻找目标客户。另外一个方面就是，金融企业利用统计的信息，开发出适合目标客户的产品。<br>从商业角度出发的用户画像对企业具有很大的价值，用户画像目的有两个。<br>一个是业务场景出发，寻找目标客户。另外一个就是，参考用户画像的信息，为用户设计产品或开展营销活动。</p>
<h2 id="三、用户画像工作坚持的原则"><a href="#三、用户画像工作坚持的原则" class="headerlink" title="三、用户画像工作坚持的原则"></a>三、用户画像工作坚持的原则</h2><p>市场上用户画像的方法很多，许多企业也提供用户画像服务，将用户画像提升到很有逼格一件事。金融企业是最早开始用户画像的行业，由于拥有丰富的数据，金融企业在进行用户画像时，对众多纬度的数据无从下手，总是认为用户画像数据纬度越多越好，画像数据越丰富越好，某些输入的数据还设定了权重甚至建立了模型，搞的用户画像是一个巨大而负责的工程。但是费力很大力气进行了画像之后，却发现只剩下了用户画像，和业务相聚甚远，没有办法直接支持业务运营，投入精力巨大但是回报微小，可以说是得不偿失，无法向领导交代。<br>事实上，用户画像涉及数据的纬度需要业务场景结合，既要简单干练又要和业务强相关，既要筛选便捷又要方便进一步操作。用户画像需要坚持三个原则，分别是人口属性和信用信息为主，强相关信息为主，定性数据为主。下面就分别展开进行解释和分析。</p>
<h3 id="1、信用信息和人口属性为主"><a href="#1、信用信息和人口属性为主" class="headerlink" title="1、信用信息和人口属性为主"></a>1、信用信息和人口属性为主</h3><p>描述一个用户的信息很多，信用信息是用户画像中重要的信息，信用信息是描述一个人在社会中的消费能力信息。任何企业进行用户画像的目的是寻找目标客户，其必须是具有潜在消费能力的用户。信用信息可以直接证明客户的消费能力，是用户画像中最重要和基础的信息。一句戏言，所有的信息都是信用信息就是这个道理。其包含消费者工作、收入、学历、财产等信息。<br>定位完目标客户之后，金融企业需要触达客户，人口属性信息就是起到触达客户的作用，人口属性信息包含姓名、性别，电话号码，邮件地址，家庭住址等信息。这些信息可以帮助金融企业联系客户，将产品和服务推销给客户。</p>
<h3 id="2、采用强相关信息，忽略弱相关信息"><a href="#2、采用强相关信息，忽略弱相关信息" class="headerlink" title="2、采用强相关信息，忽略弱相关信息"></a>2、采用强相关信息，忽略弱相关信息</h3><p>我们需要介绍一下强相关信息和弱相关信息。强相关信息就是同场景需求直接相关的信息，其可以是因果信息，也可以是相关程度很高的信息。<br>如果定义采用0到1作为相关系数取值范围的化，0.6以上的相关系数就应该定义为强相关信息。例如在其他条件相同的前提下，35岁左右人的平均工资高于平均年龄为30岁的人，计算机专业毕业的学生平均工资高于哲学专业学生，从事金融行业工作的平均工资高于从事纺织行业的平均工资，上海的平均工资超过海南省平均工资。从这些信息可以看出来人的年龄、学历、职业、地点对收入的影响较大，同收入高低是强相关关系。简单的将，对信用信息影响较大的信息就是强相关信息，反之则是弱相关信息。<br>用户其他的信息，例如用户的身高、体重、姓名、星座等信息，很难从概率上分析出其对消费能力的影响，这些弱相关信息，这些信息就不应该放到用户画像中进行分析，对用户的信用消费能力影响很小，不具有较大的商业价值。<br>用户画像和用户分析时，需要考虑强相关信息，不要考虑弱相关信息，这是用户画像的一个原则。</p>
<h3 id="3、将定量的信息归类为定性的信息"><a href="#3、将定量的信息归类为定性的信息" class="headerlink" title="3、将定量的信息归类为定性的信息"></a>3、将定量的信息归类为定性的信息</h3><p>用户画像的目的是为产品筛选出目标客户，定量的信息不利于对客户进行筛选，需要将定量信息转化为定性信息，通过信息类别来筛选人群。<br>例如可以将年龄段对客户进行划分，18岁-25岁定义为年轻人，25岁-35岁定义为中青年，36-45定义为中年人等。可以参考个人收入信息，将人群定义为高收入人群，中等收入人群，低收入人群。参考资产信息也可以将客户定义为高、中、低级别。定性信息的类别和方式方法，金融可以从自身业务出发，没有固定的模式。<br>将金融企业各类定量信息，集中在一起，对定性信息进行分类，并进行定性化，有利与对用户进行筛选，快速定位目标客户，是用户画像的另外一个原则。</p>
<h2 id="四、用户画像的方法介绍，不要太复杂"><a href="#四、用户画像的方法介绍，不要太复杂" class="headerlink" title="四、用户画像的方法介绍，不要太复杂"></a>四、用户画像的方法介绍，不要太复杂</h2><p>金融企业需要结合业务需求进行用户画像，从实用角度出发，我们可以将用户画像信息分成五类信息。分别是人口属性，信用属性，消费特征，兴趣爱好，社交属性。它们基本覆盖了业务需求所需要的强相关信息，结合外部场景数据将会产生巨大的商业价值。我们先了解下用户画像的五大类信息的作用，以及涉及的强相关信息。特别复杂的用户画像纬度例如八个纬度，十个纬度信息都不利于商业应用，不建议金融企业进行采用，其他具有价值的信息，基本上都可以归纳到这五个纬度。金融企业达到其商业需求，从这五个纬度信息进行应用就可以了，不需要过于复杂用户画像这个工作，同时商业意义也不太大。</p>
<h3 id="1、人口属性："><a href="#1、人口属性：" class="headerlink" title="1、人口属性："></a>1、人口属性：</h3><p>用于描述一个人基本特征的信息，主要作用是帮助金融企业知道客户是谁，如何触达用户。姓名，性别，年龄，电话号码，邮箱，家庭住址都属于人口属性信息。</p>
<h3 id="2、信用属性："><a href="#2、信用属性：" class="headerlink" title="2、信用属性："></a>2、信用属性：</h3><p>用于描述用户收入潜力和收入情况，支付能力。帮助企业了解客户资产情况和信用情况，有利于定位目标客户。客户职业、收入、资产、负债、学历、信用评分等都属于信用信息。</p>
<h3 id="3、消费特征："><a href="#3、消费特征：" class="headerlink" title="3、消费特征："></a>3、消费特征：</h3><p>用于描述客户主要消费习惯和消费偏好，用于寻找高频和高价值客户。帮助企业依据客户消费特点推荐相关金融产品和服务，转化率将非常高。为了便于筛选客户，可以参考客户的消费记录将客户直接定性为某些消费特征人群，例如差旅人群，境外游人群，旅游人群，餐饮用户，汽车用户，母婴用户，理财人群等。</p>
<h3 id="4、兴趣爱好："><a href="#4、兴趣爱好：" class="headerlink" title="4、兴趣爱好："></a>4、兴趣爱好：</h3><p>用于描述客户具有哪方面的兴趣爱好，在这些兴趣方面可能消费偏好比较高。帮助企业了解客户兴趣和消费倾向，定向进行活动营销。兴趣爱好的信息可能会和消费特征中部分信息有重复，区别在于数据来源不同。消费特征来源于已有的消费记录，但是购买的物品和服务不一定是自己享用，但是兴趣爱好代表本人的真实兴趣。例如户外运动爱好者，旅游爱好者，电影爱好者，科技发烧友，健身爱好者，奢侈品爱好者等。兴趣爱好的信息可能来源于社交信息和客户位置信息。</p>
<h3 id="5、社交信息："><a href="#5、社交信息：" class="headerlink" title="5、社交信息："></a>5、社交信息：</h3><p>用于描述用户在社交媒体的评论，这些信息往往代表用户内心的想法和需求，具有实时性高，转化率高的特点。例如客户询问上海哪里好玩?澳大利亚墨尔本的交通?房屋贷款哪家优惠多?那个理财产品好?这些社交信息都是代表客户多需求，如果企业可以及时了解到，将会有助于产品推广。<br>这些用户画像信息归类基本覆盖了业务需求和产品开发所需要的信息，需要对这些信息进行进行整理和处理。根据业务场景，将定量的数据转化为定性的数据，并将强相关数据进行整理。</p>
<h2 id="五、金融企业用户画像的基本步骤如下"><a href="#五、金融企业用户画像的基本步骤如下" class="headerlink" title="五、金融企业用户画像的基本步骤如下"></a>五、金融企业用户画像的基本步骤如下</h2><p>参考金融企业的数据类型和业务需求，可以将金融企业用户画像工作进行细化。基本上从数据集中到数据处理，从强相关数据到定性分类数据，从引入外部数据到依据业务场景进行筛选目标用户。</p>
<h3 id="1-画像相关数据的整理和集中"><a href="#1-画像相关数据的整理和集中" class="headerlink" title="1)画像相关数据的整理和集中"></a>1)画像相关数据的整理和集中</h3><p>金融企业内部的信息分布在不同的系统中，一般情况下，人口属性信息主要集中在客户关系管理系统，信用信息主要集中在交易系统和产品系统之中，也集中在客户关系管理系统中，消费特征主要集中在渠道和产品系统中。<br>兴趣爱好和社交信息需要从外部引入，例如客户的行为轨迹可以代表其兴趣爱好和品牌爱好，移动设备到位置信息可以提供较为准确的兴趣爱好信息。社交信息，可以借助于金融行业自身的文本挖掘能力进行采集和分析，也是可以借助于厂商的技术能力在社交网站上直接获得。社交信息往往是实时信息，商业价值较高，转化率也较高，是大数据预测方面的主要信息来源。例如用用户在社交网站上提出罗马哪里好玩的问题，就代表用户未来可能有出国旅游的需求;如果客户在对比两款汽车的优良，客户购买汽车的可能性就较大。金融企业可以及时介入，为客户提供金融服务。<br>客户画像数据主要分为五类，人口属性、信用信息、消费特征、兴趣爱好、社交信息。这些数据都分布在不同的信息系统，金融企业都上线了数据仓库(DW)，所有画像相关的强相关信息都可以从数据仓库里面整理和集中，并且依据画像商业需求，利用跑批作业，加工数据，生成用户画像的原始数据。<br>数据仓库成为用户画像数据的主要处理工具，依据业务场景和画像需求将原始数据进行分类、筛选、归纳、加工等，生成用户画像需要的原始数据。<br>用户画像的纬度信息不是越多越好，只需要找到可五大类画像信息强相关信息，同业务场景强相关信息，同产品和目标客户强相关信息即可。根本不存在360度的用户画像信息，也不存在丰富的信息可以完全了解客户，另外数据的实效性也要重点考虑。</p>
<h3 id="2-找到同业务场景强相关数据"><a href="#2-找到同业务场景强相关数据" class="headerlink" title="2)找到同业务场景强相关数据"></a>2)找到同业务场景强相关数据</h3><p>依据用户画像的原则，所有画像信息应该是5大分类的强相关信息。强相关信息是指同业务场景强相关信息，可以帮助金融行业定位目标客户，了解客户潜在需求，开发需求产品。<br>只有强相关信息才能帮助金融企业有效结合业务需求，创造商业价值。例如姓名、手机号、家庭地址就是能够触达客户的强人口属性信息，收入、学历、职业、资产就是客户信用信息的强相关信息。差旅人群、境外游人群、汽车用户、旅游人群、母婴人群就是消费特征的强相关信息。摄影爱好者、游戏爱好者、健身爱好者、电影人群、户外爱好者就是客户兴趣爱好的强相关信息。社交媒体上发表的旅游需求，旅游攻略，理财咨询，汽车需求，房产需求等信息代表了用户的内心需求，是社交信息场景应用的强相关信息。<br>金融企业内部信息较多，在用户画像阶段不需要对所有信息都采用，只需要采用同业务场景和目标客户强相关的信息即可，这样有助于提高产品转化率，降低ROI，有利于简单找到业务应用场景，在数据变现过程中也容易实现。<br>千万不要将用户画像工作搞的过于复杂，同业务场景关系不大，这样就让很多金融企业特别是领导失去用户画像的兴趣，看不到用户画像的商业，不愿意在大数据领域投资。为企业带来商业价值才是用户画像工作的主要动力和主要目的。</p>
<h3 id="3-对数据进行分类和标签化-定量to定性"><a href="#3-对数据进行分类和标签化-定量to定性" class="headerlink" title="3)对数据进行分类和标签化(定量to定性)"></a>3)对数据进行分类和标签化(定量to定性)</h3><p>金融企业集中了所有信息之后，依据业务需求，对信息进行加工整理，需要对定量的信息进行定性，方便信息分类和筛选。这部分工作建议在数据仓库进行，不建议在大数据管理平台(DMP)里进行加工。<br>定性信息进行定量分类是用户画像的一个重要工作环节，具有较高的业务场景要求，考验用户画像商业需求的转化。其主要目的是帮助企业将复杂数据简单化，将交易数据定性进行归类，并且融入商业分析的要求，对数据进行商业加工。<br>例如可以将客户按照年龄区间分为学生，青年，中青年，中年，中老年，老年等人生阶段。源于各人生阶段的金融服务需求不同，在寻找目标客户时，可以通过人生阶段进行目标客户定位。企业可以利用客户的收入、学历、资产等情况将客户分为低、中、高端客户，并依据其金融服务需求，提供不同的金融服务。可以参考其金融消费记录和资产信息，以及交易产品，购买的产品，将客户消费特征进行定性描述，区分出电商客户，理财客户，保险客户，稳健投资客户，激进投资客户，餐饮客户，旅游客户，高端客户，公务员客户等。<br>利用外部的数据可以将定性客户的兴趣爱好，例如户外爱好者，奢侈品爱好者，科技产品发烧友，摄影爱好者，高端汽车需求者等信息。<br>将定量信息归纳为定性信息，并依据业务需求进行标签化，有助于金融企业找到目标客户，并且了解客户的潜在需求，为金融行业的产品找到目标客户，进行精准营销，降低营销成本，提高产品转化率。另外金融企业还可以依据客户的消费特征、兴趣爱好、社交信息及时为客户推荐产品，设计产品，优化产品流程。提高产品销售的活跃率，帮助金融企业更好地为客户设计产品。</p>
<h3 id="4-依据业务需求引入外部数据"><a href="#4-依据业务需求引入外部数据" class="headerlink" title="4)依据业务需求引入外部数据"></a>4)依据业务需求引入外部数据</h3><p>利用数据进行画像目的主要时为业务场景提供数据支持，包括寻找到产品的目标客户和触达客户。金融企业自身的数据不足以了解客户的消费特征、兴趣爱好、社交信息。<br>金融企业可以引入外部信息来丰富客户画像信息，例如引入银联和电商的信息来丰富消费特征信息，引入移动大数据的位置信息来丰富客户的兴趣爱好信息，引入外部厂商的数据来丰富社交信息等。<br>外部信息的纬度较多，内容也很丰富，但是如何引入外部信息是一项具有挑战的工作。外部信息在引入时需要考虑几个问题，分别是外部数据的覆盖里，如何和内部数据打通，和内部信息的匹配率，以及信息的相关程度，还有数据的鲜活度，这些都是引入外部信息的主要考虑纬度。<br>外部数据鱼龙混杂，数据的合规性也是金融企业在引入外部数据时的一个重要考虑，敏感的信息例如手机号、家庭住址、身份证号在引入或匹配时都应该注意隐私问题，基本的原则是不进行数据交换，可以进行数据匹配和验证。<br>外部数据不会集中在某一家，需要金融企业花费大量时间进行寻找。外部数据和内部数据的打通是个很复杂的问题，手机号/设备号/身份证号的MD5数值匹配是一种好的方法，不涉及隐私数据的交换，可以进行唯一匹配。依据行业内部的经验，没有一家企业外部数据可以满足企业要求，外部数据的引入需要多方面数据。一般情况下，数据覆盖率达到70%以上，就是一个非常高的覆盖率。覆盖率达到20%以上就可以进行商业应用了。<br>金融行业外部数据源较好合作方有银联、芝麻信用、运营商、中航信、腾云天下、腾讯、微博、前海征信，各大电商平台等。市场上数据提供商已经很多，并且数据质量都不错，需要金融行业一家一家去挖掘，或者委托一个厂商代理引入也可以。独立第三方帮助金融行业引入外部数据可以降低数据交易成本，同时也可以降低数据合规风险，是一个不错得尝试。另外各大城市和区域的大数据交易平台，也是一个较好的外部数据引入方式。</p>
<h3 id="5-按照业务需求进行筛选客户-DMP的作用"><a href="#5-按照业务需求进行筛选客户-DMP的作用" class="headerlink" title="5)按照业务需求进行筛选客户(DMP的作用)"></a>5)按照业务需求进行筛选客户(DMP的作用)</h3><p>用户画像主要目的是让金融企业挖掘已有的数据价值，利用数据画像技术寻找到目标客户和客户到潜在需求，进行产品推销和设计改良产品。<br>用户画像从业务场景出发，实现数据商业变现重要方式。用户画像是数据思维运营过程中到一个重要闭环，帮助金融企业利用数据进行精细化运营和市场营销，以及产品设计。用户画像就是一切以数据商业化运营为中心，以商业场景为中，帮助金融企业深度分析客户，找到目标客户。<br>DMP(大数据管理平台)在整个用户画像过程中起到了一个数据变现的作用。从技术角度来讲，DMP将画像数据进行标签化，利用机器学习算法来找到相似人群，同业务场景深度结合，筛选出具有价值的数据和客户，定位目标客户，触达客户，对营销效果进行记录和反馈。大数据管理平台DMP过去主要应用在广告行业，在金融行业应用不多，未来会成为数据商业应用的主要平台。<br>DMP可以帮助信用卡公司筛选出未来一个月可能进行分期付款的客户，电子产品重度购买客户，筛选出金融理财客户，筛选出高端客户(在本行资产很少，但是在他行资产很多)，筛选出保障险种，寿险，教育险，车险等客户，筛选出稳健投资人，激进投资人，财富管理等方面等客户，并且可以触达这些客户，提高产品转化率，利用数据进行价值变现。DMP还可以了解客户的消费习惯、兴趣爱好、以及近期需求，为客户定制金融产品和服务，进行跨界营销。利用客户的消费偏好，提高产品转化率，提高用户黏度。<br>DMP还作为引入外部数据的平台，将外部具有价值的数据引入到金融企业内部，补充用户画像数据，创建不同业务应用场景和商业需求，特别是移动大数据、电商数据、社交数据的应用，可以帮助金融企业来进行数据价值变现，让用户画像离商业应用更加近一些，体现用户画像的商业价值。<br>用户画像的关键不是360度分析客户，而是为企业带来商业价值，离开了商业价值谈用户画像就是耍流氓。金融企业用户画像项目出发点一定要从业务需求出发，从强相关数据出发，从业务场景应用出发。用户画像的本质就是深度分析客户，掌握具有价值数据，找到目标客户，按照客户需求来定制产品，利用数据实现价值变现。</p>
<h2 id="六、金融行业用户画像实践"><a href="#六、金融行业用户画像实践" class="headerlink" title="六、金融行业用户画像实践"></a>六、金融行业用户画像实践</h2><h3 id="1-银行用户画像实践介绍"><a href="#1-银行用户画像实践介绍" class="headerlink" title="1)银行用户画像实践介绍"></a>1)银行用户画像实践介绍</h3><p>银行具有丰富的交易数据、个人属性数据、消费数据、信用数据和客户数据，用户画像的需求较大。但是缺少社交信息和兴趣爱好信息。<br>到银行网点来办业务的人年纪偏大，未来消费者主要在网上进行业务办理。银行接触不到客户，无法了解客户需求，缺少触达客户的手段。分析客户、了解客户、找到目标客户、为客户设计其需要的产品，成了银行进行用户画像的主要目的。银行的主要业务需求集中在消费金融、财富管理、融资服务，用户画像要从这几个角度出发，寻找目标客户。<br>银行的客户数据很丰富，数据类型和总量较多，系统也很多。可以严格遵循用户画像的五大步骤。<br>先利用数据仓库进行数据集中，筛选出强相关信息，对定量信息定性化，生成DMP需要的数据。<br>利用DMP进行基础标签和应用定制，结合业务场景需求，进行目标客户筛选或对用户进行深度分析。<br>同时利用DMP引入外部数据，完善数据场景设计，提高目标客户精准度。<br>找到触达客户的方式，对客户进行营销，并对营销效果进行反馈，衡量数据产品的商业价值。<br>利用反馈数据来修正营销活动和提高ROI。形成市场营销的闭环，实现数据商业价值变现的闭环。<br>另外DMP还可以深度分析客户，依据客户的消费特征、兴趣爱好、社交需求、信用信息来开发设计产品，为金融企业的产品开发提供数据支撑，并为产品销售方式提供场景数据。<br>简单介绍一些DMP可以做到的数据场景变现。<br>A：寻找分期客户<br>利用银联数据+自身数据+信用卡数据，发现信用卡消费超过其月收入的用户，推荐其进行消费分期。<br>B：寻找高端资产客户<br>利用银联数据+移动位置数据(别墅/高档小区)+物业费代扣数据+银行自身数据+汽车型号数据，发现在银行资产较少，在其他行资产较多的用户，为其提供高端资产管理服务<br>C：需找理财客户<br>利用自身数据(交易+工资)+移动端理财客户端/电商活跃数据。发现客户将工资/资产转到外部，但是电商消费不活跃客户，其互联网理财可能性较大，可以为其提供理财服务，将资金留在本行。<br>D：寻找境外游客户<br>利用自身卡消费数据+移动设备位置信息+社交好境外强相关数据(攻略，航线，景点，费用)，寻找境外游客户为其提供金融服务。<br>E：寻找贷款客户：<br>利用自身数据(人口属性+信用信息)+移动设备位置信息+社交购房/消费强相关信息，寻找即将购车/购房的目标客户，为其提供金融服务(抵押贷款/消费贷款)。</p>
<h3 id="2-保险行业用户画像实践"><a href="#2-保险行业用户画像实践" class="headerlink" title="2)保险行业用户画像实践"></a>2)保险行业用户画像实践</h3><p>保险行业的产品是一个长周期产品，保险客户再次购买保险产品的转化率很高，经营好老客户是保险公司一项重要任务。保险公司内部的交易系统不多，交易方式不是很复杂，数据主要集中在产品系统和交易系统之中，客户关系管理系统中也包含丰富了信息，但是数据集中在很多保险公司还没有完成，数据仓库建设可能需要在用户画像建设前完成。<br>保险公司主要数据有人口属性信息，信用信息，产品销售信息，客户家人信息。缺少兴趣爱好、消费特征、社交信息等信息。保险产品主要有寿险，车险，保障，财产险，意外险，养老险，旅游险。<br>保险行业DMP用户画像的业务场景都是围绕保险产品进行的，简单的应用场景可以是。<br>A：依据自身数据(个人属性)+外部养车App活跃情况，为保险公司找到车险客户<br>B：依据自身数据(个人属性)+移动设备位置信息—户外运动人群，为保险企业找到商旅人群，推销意外险和保障险。<br>C：依据自身数据(家人数据)+人生阶段信息，为用户推荐理财保险，寿险，保障保险，养老险，教育险<br>D：依据自身数据+外部数据，为高端人士提供财产险和寿险</p>
<h3 id="3-证券行业用户画像"><a href="#3-证券行业用户画像" class="headerlink" title="3)证券行业用户画像"></a>3)证券行业用户画像</h3><p>2015年4月13日，一码通实施之后，证券行业面临了互联网证券平台的强力竞争，依据TalkingData发布的金融App排行榜，移动互联网证券App，排名前5位的证券类App，只有一家传统券商华泰证券。排名第一的互联网券商同化顺覆装机量是排名第一传统券商的6倍，前三名的互联券商总体覆盖用户接近6000万用户。用户总数还在不断增加。传统证券行业现在面临的主要挑战是用户交易账户的争夺，证券行业如何增加新用户?如何留住用户?如何提高证券行业用户的活跃?如何提高单个客户的收入?是证券行业主要的业务需求。<br>证券行业拥有的数据类型有个人属性信息例如用户名称，手机号码，家庭地址，邮件地址等。证券公司还拥有交易用户的资产和交易纪录，同时还拥有用户收益数据，利用这些数据和外部数据，证券公司可以利用数据建立业务场景，筛选目标客户，为用户提供适合的产品，同时提高单个客户收入。<br>证券公司可以利用用户画像数据来进行产品设计，下面举几个例子，看看用户画像和用户分析来帮助证券公司创造商业价值。</p>
<h2 id="七、外部数据介绍"><a href="#七、外部数据介绍" class="headerlink" title="七、外部数据介绍"></a>七、外部数据介绍</h2><p>金融企业内部数据主要集中在个人属性，信用属性和消费特征上，缺少社交属性和兴趣偏好等信息，这些信息可以通过第三方获得。<br>社交数据就是客户在社交媒体上发表的言论和行为，可以是评论，文章，图片，甚至可以是表情符号，音频和视频。社交数据可以依靠第三方平台，在社交网站上利用爬虫技术进行获得(Spider)。社交数据的打通是一个挑战，如果能够客户的授权最好，金融企业就可以将社交数据纳入到用户画像之中。社交数据具有实时和反映内心需要的特点，富国银行已经将社交数据作为分析客户需求的一个重要数据纬度。例如如果某一个客户在社交媒体上发表了一个问题，罗马有哪些好玩的地方，金融企业就会推测客户可能近期会有出境游的计划，就会向客户推销一些旅游相关产品。<br>社交媒体数据正在成为金融企业积极争取获得的数据，除了利用网络爬虫技术到微博上进行数据采集之外，金融企业自身网站上到文本数据采集和呼叫中心(callcenter)纪录的信息都可以进行文本挖掘。通过客户编号，进行打通，将其补充到客户画像之中。社交数据需要通过数据挖掘将其定义为结构化数据，并且同业务场景、客户需求向结合，清晰进行分类。例如将母婴论坛发言活跃的用户定义为潜在教育需求客户，将学生论坛活跃的客户定义为学区房需要客户，将境外自助游论坛上活跃的客户定义为境外旅游客户，将雪球上活跃的客户定义为理财客户等。金融企业完全可以从社交数据中挖掘出客户近期的消费需求，及时进行市场营销和定制产品。<br>兴趣爱好数据可以借助于移动大数据位置信息获得，客户手机设备的位置轨迹信息可以揭示客户喜欢何种品牌，喜欢吃辣还是吃火锅，客户喜欢旅游还是喜欢宅在家里，客户喜欢看电影还是喜欢运动。客户喜欢中档品牌还是高档品牌，客户喜欢喝茶还是喝咖啡。移动手机上App的安装情况和活动频次一样可以揭示客户的兴趣和爱好。同时移动大数据进行加工之后还可以告诉金融企业，客户近期的需求是买车还是买房。<br>外部数据引入过程中，金融企业面临的巨大挑战是外部数据的覆盖率，如何打通内外部数据，外部数据同内部客户的匹配率，外部数据同业务的相关度，外部数据的活跃程度等。用户画像平台(DMP)可以通过技术手段将外部数据引入到金融企业内部，建立标准的标签体系，提供灵活的用户画像方式，按照业务场景进行筛选客户。</p>
<h2 id="八、移动大数据的商业价值"><a href="#八、移动大数据的商业价值" class="headerlink" title="八、移动大数据的商业价值"></a>八、移动大数据的商业价值</h2><p>移动互联网时代，移动大数据具有较高的商业价值。如果一个用户不喜欢一个App，其不会装在手机上。客户经常使用的App可以推测用户的兴趣爱好和消费偏好。另外移动设备的位置信息可以帮助金融企业了解客户行为轨迹、兴趣爱好、品牌偏好和消费需求。</p>
<h3 id="1-移动App提供一切服务，App可以反映用户喜好"><a href="#1-移动App提供一切服务，App可以反映用户喜好" class="headerlink" title="1)移动App提供一切服务，App可以反映用户喜好"></a>1)移动App提供一切服务，App可以反映用户喜好</h3><p>智能手机上安装的App正在代替PC互联网为所有客户提供服务，清晨起床可以看看墨迹天气，了解一下今天的天气情况。出门时可以通过嘀嘀打车来预定出租车，安排出行。或者通过百度地图来了解路况信息，决定进行从哪条路到公司。<br>快到中午时，可以通过饿了吗或者百度外卖预定午餐，如果想出去吃饭可以利用大众点评订餐和买单。中午可以利用携程App预定家庭旅行机票和酒店，还可以将通过App看看理财产品。如果需要看电影，可以通过格瓦拉来预定要电影票，如果需要看医生，可以通过微医网预约医生。晚上可以通过淘宝来购物，通过学习宝来监督子女教育等。可以看出移动App已经可以满足人们大部分生活需要，提供了人们的衣食住行、教育、医疗、旅游、金融等服务。移动App包围了人们的日常生活，成为人们消费的主要场所。<br>智能手机上App使用的频率，可以代表用户的喜好。例如喜欢理财的客户，其智能手机上一定会安装理财App，并经常使用;母婴人群也会安装和母婴相关的App，频繁使用;商旅人群使用商旅App的频率一定会高于其他移动用户。80后、90后的消费行为将会以移动互联网为主，App的安装和活跃数据更加能够反应出年轻人的消费偏好。</p>
<h3 id="2-智能设备的位置信息，商业价值广大"><a href="#2-智能设备的位置信息，商业价值广大" class="headerlink" title="2)智能设备的位置信息，商业价值广大"></a>2)智能设备的位置信息，商业价值广大</h3><p>智能手机设备的位置信息代表了消费者的位置轨迹，这个轨迹可以推测出消费者的消费偏好和习惯。在美国，移动设备位置信息的商业化较为成熟，GPS数据正在帮助很多企业进行数据变现，提高社会运营效率。在中国，移动大数据的商业应用刚刚开始，在房地产业、零售行业、金融行业、市场分析等领域取得了一些效果。移动大数据中的位置信息代表了用户轨迹，商业应用较早。2014年，美国移动设备位置信息的市场规模接近1000亿美金。但中国移动设备位置信息的商业应用才刚刚开始。目前主要的应用在互联网金融的反欺诈领域。<br>线上的欺诈行为具有较高的隐蔽性，很难识别和侦测。P2P贷款用户很大一部分来源于线上，因此恶意欺诈事件发生在线上的风险远远大于线下。中国的很多数据处于封闭状态，P2P公司在客户真实信息验证方面面临较大的挑战。<br>移动大数据可以验证P2P客户的居住地点，例如某个客户在利用手机申请贷款时，填写自己居住地是上海。但是P2P企业依据其提供的手机设备信息，发现其过去三个月从来没有居住在上海，这个人提交的信息可能是假信息，发生恶意欺诈的风险较高。移动设备的位置信息可以辨识出设备持有人的居住地点，帮助P2P公司验证贷款申请人的居住地。<br>借款用户的工作单位是用户还款能力的强相关信息，具有高薪工作的用户，其贷款信用违约率较低。这些客户成为很多贷款平台积极争取的客户，也是恶意欺诈团伙主要假冒的客户。<br>某个用户在申请贷款时，如果声明自己是工作在上海陆家嘴金融企业的高薪人士，其贷款审批会很快并且额度也会较高。但是P2P公司利用移动大数据，发现这个用户在过去的三个月里面，从来没有出现在陆家嘴，大多数时间在城乡结合处活动，那么这个用户恶意欺诈的可能性就较大。<br>移动大数据可以帮助P2P公司在一定程度上来验证贷款用户真实工作地点，降低犯罪分子利用高薪工作进行恶意欺诈的风险。<br>P2P企业可以利用移动设备的位置信息，了解过去3个月用户的行为轨迹。如果某个用户经常在半夜2点出现在酒吧等危险区域，并且经常有飙车行为，这个客户定义成高风险客户的概率就较高。移动App的使用习惯和某些高风险App也可以帮助P2P企业识别出用户的高风险行为。如果用户经常在半夜2点频繁使用App，其成为高风险客户的概率就较大。<br>移动大数据在预防互联网恶意欺诈和高风险客户识别方面，已经有了成熟的应用场景。前海征信、宜信、聚信立、闪银已经开始利用TalkingData的数据，预防互联网恶意欺诈和识别高风险客户，并取得了较好的效果。移动大数据应用场景正在被逐步挖掘出来，未来移动大数商业应用将更加广阔。<br>用户画像是大数据商业应用的重要领域，其实并没有多么复杂，只要掌握用户画像的原则和方法，以及实施步骤。结合金融企业的业务场景，用户画像可以帮助金融企业创造商业价值，实现大数据直接变现。<br><span class="exturl" data-url="aHR0cDovL3d3dy5yYWluY2VudC5jb20vY29udGVudC0xMC03ODY3LTEuaHRtbA==" title="http://www.raincent.com/content-10-7867-1.html">文章来源<i class="fa fa-external-link"></i></span></p>
]]></content>
      
        <categories>
            
            <category> 大数据 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 用户画像 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[RDD转DataFrame的一道面试题]]></title>
      <url>/RDD%E8%BD%ACDataFrame%E7%9A%84%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98.html</url>
      <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>现在在我们HDFS文件系统上面 存了一个文件，该文件格式是 .txt文件格式，要求把这个文件格式转换成为parquet文件格式 :<br>解题思路:<br>1）先读取文件生成一个RDD<br>2）把RDD转换成为一个DataFrame，RDD[Person].toDF<br>3) 写数据，指定文件格式就可以了！！<br><a id="more"></a><br>代码实现 :<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local"</span>).setAppName(<span class="string">"DataFrameReflection"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line">    <span class="keyword">val</span> sqlContext = <span class="keyword">new</span> <span class="type">SQLContext</span>(sc)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">import</span> sqlContext.implicits._</span><br><span class="line">    <span class="keyword">val</span> peopelRDD: <span class="type">RDD</span>[<span class="type">People</span>] = sc.textFile(<span class="string">"hdfs://hadoop01:9000/resources/people.txt"</span>)</span><br><span class="line">      .map(line =&gt; <span class="type">People</span>(line.split(<span class="string">","</span>)(<span class="number">0</span>),line.split(<span class="string">","</span>)(<span class="number">1</span>).trim.toInt))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> df = peopelRDD.toDF()</span><br><span class="line">    df.write.format(<span class="string">"parquet"</span>).save(<span class="string">"hdfs://hadoop01:9000/test/"</span>)</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 大数据 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> RDD </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[RDD转DataFrame的两种方法]]></title>
      <url>/RDD%E8%BD%ACDataFrame%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95.html</url>
      <content type="html"><![CDATA[<p>介绍一下Spark将RDD转换成DataFrame的两种方式。 </p>
<ol>
<li>通过是使用case class的方式，不过在scala 2.10中最大支持22个字段的case class,这点需要注意 </li>
<li>是通过spark内部的StructType方式，将普通的RDD转换成DataFrame 装换成DataFrame后，就可以使用SparkSQL来进行数据筛选过滤等操作 <a id="more"></a>
</li>
</ol>
<h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.spark.rdd.<span class="type">RDD</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.<span class="type">SQLContext</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//需要提前知道列名及类型</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span>(<span class="params">var name: <span class="type">String</span>,var age:<span class="type">Int</span></span>)</span></span><br><span class="line"><span class="class"><span class="title">object</span> <span class="title">DataFrameReflection</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args:<span class="type">Array</span>[<span class="type">String</span>]):<span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local"</span>).setAppName(<span class="string">"DataFrameReflection"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line">    <span class="keyword">val</span> sqlContext = <span class="keyword">new</span> <span class="type">SQLContext</span>(sc)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">import</span> sqlContext.implicits._</span><br><span class="line">    <span class="keyword">val</span> peopelRDD: <span class="type">RDD</span>[<span class="type">People</span>] = sc.textFile(<span class="string">"people.txt"</span>)</span><br><span class="line">      .map(line =&gt; <span class="type">People</span>(line.split(<span class="string">","</span>)(<span class="number">0</span>),line.split(<span class="string">","</span>)(<span class="number">1</span>).trim.toInt))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> df = peopelRDD.toDF()</span><br><span class="line">    df.createOrReplaceTempView(<span class="string">"people"</span>)</span><br><span class="line">    sqlContext.sql(<span class="string">"select * from people"</span>).show()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.spark.rdd.<span class="type">RDD</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.types.&#123;<span class="type">IntegerType</span>, <span class="type">StringType</span>, <span class="type">StructField</span>, <span class="type">StructType</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.&#123;<span class="type">DataFrame</span>, <span class="type">Row</span>, <span class="type">SQLContext</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">DataFrameProgrammatically</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args:<span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local"</span>).setAppName(<span class="string">"DataFrameProgrammatically"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line">    <span class="keyword">val</span> sqlContext = <span class="keyword">new</span> <span class="type">SQLContext</span>(sc)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取文件</span></span><br><span class="line">    <span class="keyword">val</span> rdd: <span class="type">RDD</span>[<span class="type">String</span>] = sc.textFile(<span class="string">"people.txt"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 得到 rowRDD</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="keyword">val</span> rowRDD: <span class="type">RDD</span>[<span class="type">Row</span>] = rdd.map(line =&gt; &#123;</span><br><span class="line">      <span class="keyword">val</span> fields = line.split(<span class="string">","</span>)</span><br><span class="line">      <span class="type">Row</span>(fields(<span class="number">0</span>), fields(<span class="number">1</span>).trim.toInt)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 得到structType</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="keyword">val</span> structType = <span class="type">StructType</span>(</span><br><span class="line">      <span class="type">StructField</span>(<span class="string">"name"</span>,<span class="type">StringType</span>,<span class="literal">true</span>) ::</span><br><span class="line">      <span class="type">StructField</span>(<span class="string">"age"</span>,<span class="type">IntegerType</span>,<span class="literal">true</span>) :: <span class="type">Nil</span></span><br><span class="line">    )</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * rowRDD:RDD[Row]</span></span><br><span class="line"><span class="comment">      * schema: StructType</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="keyword">val</span> df: <span class="type">DataFrame</span> = sqlContext.createDataFrame(rowRDD,structType)</span><br><span class="line">    df.createOrReplaceTempView(<span class="string">"people"</span>)</span><br><span class="line">    sqlContext.sql(<span class="string">"select * from people"</span>).show()</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    /**</span></span><br><span class="line"><span class="comment">//      * 官网schema实现方法</span></span><br><span class="line"><span class="comment">//      */</span></span><br><span class="line"><span class="comment">//    val schemaString = "name age"</span></span><br><span class="line"><span class="comment">//    val fields = schemaString.split(" ")</span></span><br><span class="line"><span class="comment">//      .map(fieldName =&gt; StructField(</span></span><br><span class="line"><span class="comment">//        fieldName,StringType,nullable = true</span></span><br><span class="line"><span class="comment">//      ))</span></span><br><span class="line"><span class="comment">//    val schema = StructType(fields)</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 大数据 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> RDD </tag>
            
            <tag> DataFrame </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java单例模式]]></title>
      <url>/Java%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html</url>
      <content type="html"><![CDATA[<ol>
<li>饿汉式<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//饿汉式单例类，在类初始化时，已经自行实例化</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton1</span> </span>&#123;</span><br><span class="line">    <span class="comment">//私有的默认构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">//已经自行实例化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton1 single = <span class="keyword">new</span> Singleton1() ;</span><br><span class="line">    <span class="comment">//静态工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Singleton1 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> single ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<a id="more"></a>
<ol>
<li><p>懒汉式单例类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//懒汉式单例类，在第一次调用的时候实例化</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton2</span> </span>&#123;</span><br><span class="line">    <span class="comment">//私有的默认构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">//注意，这里没有final</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton2 single = <span class="keyword">null</span> ;</span><br><span class="line">    <span class="comment">//静态工厂方法，如果不加synchronized线程不安全</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> Singleton2 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(single == <span class="keyword">null</span> )&#123;</span><br><span class="line">            single = <span class="keyword">new</span> Singleton2() ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> single ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>登记式单例类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegistSingleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">//用ConcurrentHashMap来维护映射关系，这是线程安全的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String,Object&gt; REGIST=<span class="keyword">new</span> ConcurrentHashMap&lt;String, Object&gt;();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">//把RegistSingleton自己也纳入容器管理</span></span><br><span class="line">        RegistSingleton registSingleton=<span class="keyword">new</span> RegistSingleton();</span><br><span class="line">        REGIST.put(registSingleton.getClass().getName(),registSingleton);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">RegistSingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getInstance</span><span class="params">(String className)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果传入的类名为空，就返回RegistSingleton实例</span></span><br><span class="line">        <span class="keyword">if</span>(className==<span class="keyword">null</span>)</span><br><span class="line">            className=RegistSingleton.class.getName();</span><br><span class="line">            <span class="comment">//如果没有登记就用反射new一个</span></span><br><span class="line">        <span class="keyword">if</span> (!REGIST.containsKey(className))&#123;</span><br><span class="line">            <span class="comment">//没有登记就进入同步块</span></span><br><span class="line">            <span class="keyword">synchronized</span> (RegistSingleton.class)&#123;</span><br><span class="line">            <span class="comment">//再次检测是否登记</span></span><br><span class="line">                <span class="keyword">if</span> (!REGIST.containsKey(className))&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//实例化对象</span></span><br><span class="line">                        REGIST.put(className,Class.forName(className).newInstance());</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回单例</span></span><br><span class="line">        <span class="keyword">return</span> REGIST.get(className);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>java中单例模式是一种常见的设计模式，单例模式分三种：懒汉式单例、饿汉式单例、登记式单例三种。<br>单例模式有一下特点：<br>1、单例类只能有一个实例。<br>2、单例类必须自己自己创建自己的唯一实例。<br>3、单例类必须给所有其他对象提供这一实例。<br>单例模式确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例。在计算机系统中，线程池、缓存、日志对象、对话框、打印机、显卡的驱动程序对象常被设计成单例。这些应用都或多或少具有资源管理器的功能。每台计算机可以有若干个打印机，但只能有一个Printer Spooler，以避免两个打印作业同时输出到打印机中。每台计算机可以有若干通信端口，系统应当集中管理这些通信端口，以避免一个通信端口同时被两个请求同时调用。总之，选择单例模式就是为了避免不一致状态，避免政出多头。</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[经验之谈]]></title>
      <url>/%E7%BB%8F%E9%AA%8C%E4%B9%8B%E8%B0%88.html</url>
      <content type="html"><![CDATA[<p>1、重构是程序员的主力技能。<br>2、工作日志能提升脑容量。<br>3、先用profiler调查，才有脸谈优化。<br>4、注释贵精不贵多。杜绝大姨妈般的“例注”。漫山遍野的碎碎念注释，实际就是背景噪音。<br>5、普通程序员+google=超级程序员。<br><a id="more"></a><br>6、单元测试总是合算的。<br>7、不要先写框架再写实现。最好反过来，从原型中提炼框架。<br>8、代码结构清晰，其它问题都不算事儿。<br>9、好的项目作风硬派，一键测试，一键发布，一键部署；烂的项目生性猥琐，口口相传，不立文字，神神秘秘。<br>10、编码不要畏惧变化，要拥抱变化。<br>11、常充电。程序员只有一种死法：土死的。<br>12、编程之事，隔离是方向，起名是关键，测试是主角，调试是补充，版本控制是后悔药。<br>13、一行代码一个兵。形成建制才能有战斗力。单位规模不宜过大，千人班，万人排易成万人坑。<br>14、重构/优化/修复Bug，同时只能做一件。<br>15、简单模块注意封装，复杂模块注意分层。<br>16、人脑性能有限，整洁胜于杂乱。读不懂的代码，尝试整理下格式；不好用的接口，尝试重新封装下。<br>17、迭代速度决定工作强度。想多快好省，就从简化开发流程，加快迭代速度开始。<br>18、忘掉优化写代码。过早优化等同恶意破坏；忘掉代码做优化。优化要基于性能测试，而不是纠结于字里行间。<br>19、最好的工具是纸笔；其次好的是markdown。<br>20、Leader问任务时间，若答不上来，可能是任务拆分还不够细。<br>21、宁可多算一周，不可少估一天。过于“乐观”容易让boss受惊吓。<br>22、最有用的语言是English。其次的可能是Python。<br>23、百闻不如一见。画出结果，一目了然。调试耗时将大大缩短。<br>24、资源、代码应一道受版本管理。资源匹配错误远比代码匹配错误更难排查。<br>25、不要基于想象开发， 要基于原型开发。原型的价值是快速验证想法，帮大家节省时间。<br>26、序列化首选明文文本 。诸如二进制、混淆、加密、压缩等等有需要时再加。<br>27、编译器永远比你懂微观优化。只能向它不擅长的方向努力。<br>28、不要定过大、过远、过细的计划。即使定了也没有用。<br>29、至少半数时间将花在集成上。时间，时间，时间总是不够。<br>30、与主流意见/方法/风格/习惯相悖时，先检讨自己最可靠。<br>31、出现bug主动查，不管是不是你的。这能让你业务能力猛涨、个人形象飙升；如果你的bug被别人揪出来…..呵呵，那你会很被动～≧﹏≦<br>32、不知怎么选技术书时就挑薄的。起码不会太贵，且你能看完。<br>33、git是最棒的。简单，可靠，免费。<br>34、仅对“可预测的非理性”抛断言。<br>35、Log要写时间与分类。并且要能重定向输出。<br>36、注释是稍差的文档。更好的是清晰的命名。让代码讲自己的故事。<br>37、造轮子是很好的锻炼方法。前提是你见过别的轮子。<br>38、code review最好以小组/结对的形式。对业务有一定了解，建议会更有价值（但不绝对）。而且不会成为负担。管理员个人review则很容易成team的瓶颈。<br>39、提问前先做调研。问不到点上既被鄙视，又浪费自己的时间。<br><span class="exturl" data-url="aHR0cDovL3d3dy56aGlodS5jb20vcXVlc3Rpb24vMzY0MjYwNTEvYW5zd2VyLzc2MDMxNzQz" title="http://www.zhihu.com/question/36426051/answer/76031743">原文地址<i class="fa fa-external-link"></i></span></p>
]]></content>
      
        <categories>
            
            <category> 干货 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 经验之谈 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JVM常见面试题]]></title>
      <url>/JVM%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98.html</url>
      <content type="html"><![CDATA[<h2 id="简单说说JVM的架构"><a href="#简单说说JVM的架构" class="headerlink" title="简单说说JVM的架构"></a>简单说说JVM的架构</h2><h3 id="运行时区"><a href="#运行时区" class="headerlink" title="运行时区"></a>运行时区</h3><ul>
<li>堆</li>
<li>栈</li>
<li>方法区</li>
<li>程序计数器</li>
<li>本地方法<a id="more"></a>
<h2 id="描述一下垃圾回收的过程-常见"><a href="#描述一下垃圾回收的过程-常见" class="headerlink" title="描述一下垃圾回收的过程(常见)"></a>描述一下垃圾回收的过程(常见)</h2><h3 id="垃圾回收主要发生在堆中"><a href="#垃圾回收主要发生在堆中" class="headerlink" title="垃圾回收主要发生在堆中"></a>垃圾回收主要发生在堆中</h3></li>
<li>年轻代</li>
</ul>
<ol>
<li>eden区</li>
<li>s1</li>
<li>s2</li>
</ol>
<ul>
<li>年老代<h2 id="常见的垃圾回收的算法"><a href="#常见的垃圾回收的算法" class="headerlink" title="常见的垃圾回收的算法"></a>常见的垃圾回收的算法</h2></li>
</ul>
<ol>
<li>标记清除法</li>
<li>复制算法</li>
<li>标记整理算法<h2 id="说说常见的垃圾回收器"><a href="#说说常见的垃圾回收器" class="headerlink" title="说说常见的垃圾回收器"></a>说说常见的垃圾回收器</h2></li>
<li>串行—Serial</li>
<li>并行—Parallel</li>
<li>并发—CMS<h2 id="写一段代码，让它报堆内存溢出"><a href="#写一段代码，让它报堆内存溢出" class="headerlink" title="写一段代码，让它报堆内存溢出"></a>写一段代码，让它报堆内存溢出</h2></li>
<li>不断的创建对象</li>
<li>你要去用这些对象<h2 id="写一段代码，让它报栈内存溢出"><a href="#写一段代码，让它报栈内存溢出" class="headerlink" title="写一段代码，让它报栈内存溢出"></a>写一段代码，让它报栈内存溢出</h2></li>
<li>递归一直调用即可<h2 id="设置堆或栈的参数"><a href="#设置堆或栈的参数" class="headerlink" title="设置堆或栈的参数"></a>设置堆或栈的参数</h2></li>
<li>-Xms</li>
<li>-Xmx</li>
<li>-Xss364k</li>
</ol>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 面试题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入理解java虚拟机精华总结]]></title>
      <url>/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B2%BE%E5%8D%8E%E6%80%BB%E7%BB%93%EF%BC%88%E9%9D%A2%E8%AF%95%EF%BC%89.html</url>
      <content type="html"><![CDATA[<h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><p>Java虚拟机管理的内存包括几个运行时数据内存：<strong>方法区、虚拟机栈、本地方法栈、堆、程序计数器</strong>，其中方法区和堆是由线程共享的数据区，其他几个是线程隔离的数据区</p>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>程序计数器是一块较小的内存，他可以看做是当前线程所执行的行号指示器。</p>
<p>字节码解释器工作的时候就是通过改变这个计数器的值来选取下一条需要执行的字节码的指令，<strong>分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成</strong>。如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器则为空。<br><a id="more"></a><br><strong>此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemotyError情况的区域</strong></p>
<h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><p>虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于储存局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用直至完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p>
<p>栈内存就是虚拟机栈，或者说是虚拟机栈中局部变量表的部分</p>
<p>局部变量表存放了编辑期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（refrence）类型和returnAddress类型（指向了一条字节码指令的地址）</p>
<p>其中64位长度的long和double类型的数据会占用两个局部变量空间，其余的数据类型只占用1个。</p>
<p>Java虚拟机规范对这个区域规定了两种异常状况：<strong>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。如果虚拟机扩展时无法申请到足够的内存，就会跑出OutOfMemoryError异常</strong></p>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>本地方法栈和虚拟机栈发挥的作用是非常类似的，他们的区别是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务<br>本地方法栈区域也会抛出StackOverflowError和OutOfMemoryErroy异常</p>
<h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><ul>
<li>堆是Java虚拟机所管理的内存中最大的一块。</li>
<li>Java堆是被所有线程共享的一块内存区域，在虚拟机启动的时候创建，此内存区域的唯一目的是存放对象实例，几乎所有的对象实例都在这里分配内存。所有的对象实例和数组都在堆上分配。</li>
<li>Java堆是垃圾收集器管理的主要区域。<strong>Java堆细分为新生代和老年代</strong>。</li>
</ul>
<p>不管怎样，划分的目的都是为了更好的回收内存，或者更快地分配内存。Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。如果在堆中没有完成实例分配，并且堆也无法在扩展时将会抛出OutOfMemoryError异常</p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>方法区它用于储存已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据，除了Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载。当方法区无法满足内存分配需求时，将抛出OutOfMemoryErroy异常。</p>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>它是方法区的一部分。Class文件中除了有关的版本、字段、方法、接口等描述信息外、还有一项信息是常量池，用于存放编辑期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放<br>Java语言并不要求常量一定只有编辑期才能产生，也就是可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法<br>当常量池无法再申请到内存时会抛出OutOfMemoryError异常</p>
<h2 id="hotspot虚拟机对象"><a href="#hotspot虚拟机对象" class="headerlink" title="hotspot虚拟机对象"></a>hotspot虚拟机对象</h2><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><ol>
<li><p>检查<br>虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程</p>
</li>
<li><p>分配内存<br>接下来将为新生对象分配内存，为对象分配内存空间的任务等同于把一块确定的大小的内存从Java堆中划分出来。<br>假设Java堆中内存是绝对规整的，所有用过的内存放在一遍，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针指向空闲空间那边挪动一段与对象大小相等的距离，这个分配方式叫做“指针碰撞”</p>
</li>
</ol>
<p>如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式成为“空闲列表”<br>选择那种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</p>
<ol>
<li>Init<br>执行new指令之后会接着执行Init方法，进行初始化，这样一个对象才算产生出来</li>
</ol>
<h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>在HotSpot虚拟机中，对象在内存中储存的布局可以分为3块区域：<strong>对象头、实例数据和对齐填充</strong></p>
<p>对象头包括两部分：<br>a) 储存对象自身的运行时数据，如哈希码、GC分带年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳<br>b) 另一部分是指类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例</p>
<h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><ol>
<li><p>使用句柄访问<br>Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址<br>优势:reference中存储的是稳点的句柄地址,在对象被移动(垃圾收集时移动对象是非常普遍的行为)时只会改变句柄中的实例数据指针，而reference本身不需要修改</p>
</li>
<li><p>使用直接指针访问<br>Java堆对象的布局就必须考虑如何访问类型数据的相关信息,而refreence中存储的直接就是对象的地址</p>
</li>
</ol>
<p>优势：速度更快，节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本</p>
<h2 id="OutOfMemoryError-异常"><a href="#OutOfMemoryError-异常" class="headerlink" title="OutOfMemoryError 异常"></a>OutOfMemoryError 异常</h2><h3 id="Java堆溢出"><a href="#Java堆溢出" class="headerlink" title="Java堆溢出"></a>Java堆溢出</h3><p>Java堆用于存储对象实例，只要不断的创建对象，并且保证GCRoots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么在数量到达最大堆的容量限制后就会产生内存溢出异常，如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄露对象是通过怎样的路径与GC</p>
<p>Roots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息及GC Roots引用链的信息，就可以比较准确地定位出泄漏代码的位置<br>如果不存在泄露，换句话说，就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（-Xmx与-Xms），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗</p>
<h3 id="虚拟机栈和本地方法栈溢出"><a href="#虚拟机栈和本地方法栈溢出" class="headerlink" title="虚拟机栈和本地方法栈溢出"></a>虚拟机栈和本地方法栈溢出</h3><p>对于HotSpot来说，虽然-Xoss参数（设置本地方法栈大小）存在，但实际上是无效的，栈容量只由-Xss参数设定。关于虚拟机栈和本地方法栈，在Java虚拟机规范中描述了两种异常：</p>
<p>如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError<br>如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常<br>在单线程下，无论由于栈帧太大还是虚拟机栈容量太小，当内存无法分配的时候，虚拟机抛出的都是StackOverflowError异常<br>如果是多线程导致的内存溢出，与栈空间是否足够大并不存在任何联系，这个时候每个线程的栈分配的内存越大，反而越容易产生内存溢出异常。解决的时候是在不能减少线程数或更换64为的虚拟机的情况下，就只能通过减少最大堆和减少栈容量来换取更多的线程</p>
<h3 id="方法区和运行时常量池溢出"><a href="#方法区和运行时常量池溢出" class="headerlink" title="方法区和运行时常量池溢出"></a>方法区和运行时常量池溢出</h3><p>String.intern()是一个Native方法，它的作用是：如果字符串常量池中已经包含一个等于此String对象的字符串，则返回代表池中这个字符串的String对象；否则，将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用</p>
<p>由于常量池分配在永久代中，可以通过-XX:PermSize和-XX:MaxPermSize限制方法区大小，从而间接限制其中常量池的容量。</p>
<p>Intern():</p>
<p>JDK1.6 intern方法会把首次遇到的字符串实例复制到永久代，返回的也是永久代中这个字符串实例的引用，而由StringBuilder创建的字符串实例在Java堆上，所以必然不是一个引用</p>
<p>JDK1.7 intern()方法的实现不会再复制实例，只是在常量池中记录首次出现的实例引用，因此intern()返回的引用和由StringBuilder创建的那个字符串实例是同一个</p>
<h2 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h2><p>程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭，在这几个区域内就不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了</p>
<h3 id="判断对象存活"><a href="#判断对象存活" class="headerlink" title="判断对象存活"></a>判断对象存活</h3><h4 id="引用计数器法"><a href="#引用计数器法" class="headerlink" title="引用计数器法"></a>引用计数器法</h4><p>给对象添加一个引用计数器，每当由一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的</p>
<h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>通过一系列的成为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径成为引用链，当一个对象到GC<br>ROOTS没有任何引用链相连时，则证明此对象时不可用的</p>
<p>Java语言中GC Roots的对象包括下面几种：</p>
<ol>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈JNI（Native方法）引用的对象</li>
</ol>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>强引用就是在程序代码之中普遍存在的，类似Object obj = new Object() 这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象<br>软引用用来描述一些还有用但并非必须的元素。对于它在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存才会抛出内存溢出异常</p>
<p>弱引用用来描述非必须对象的，但是它的强度比软引用更弱一些，被引用关联的对象只能生存到下一次垃圾收集发生之前，当垃圾收集器工作时，无论当前内存是否足够都会回收掉只被弱引用关联的对象</p>
<p>虚引用的唯一目的就是能在这个对象被收集器回收时收到一个系统通知</p>
<h3 id="Finalize方法"><a href="#Finalize方法" class="headerlink" title="Finalize方法"></a>Finalize方法</h3><p>任何一个对象的finalize()方法都只会被系统自动调用一次，如果对象面临下一次回收，它的finalize()方法不会被再次执行，因此第二段代码的自救行动失败了</p>
<h3 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h3><p>永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类</p>
<p>废弃常量：假如一个字符串abc已经进入了常量池中，如果当前系统没有任何一个String对象abc，也就是没有任何Stirng对象引用常量池的abc常量，也没有其他地方引用的这个字面量，这个时候发生内存回收这个常量就会被清理出常量池</p>
<p>无用的类：</p>
<ol>
<li>该类所有的实例都已经被回收，就是Java堆中不存在该类的任何实例</li>
<li>加载该类的ClassLoader已经被回收</li>
<li>该类对用的java.lang.Class对象没有在任何地方被引用，无法再任何地方通过反射访问该类的方法</li>
<li>垃圾收集算法</li>
</ol>
<ul>
<li><p>标记—清除算法</p>
<p>  算法分为标记和清除两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象、<br>不足:一个是效率问题，标记和清除两个过程的效率都不高；另一个是空间问题，标记清楚之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后再程序运行过程中需要分配较大的对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作</p>
</li>
<li><p>复制算法<br>  他将可用内存按照容量划分为大小相等的两块，每次只使用其中的一块。当这块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可</p>
<p>  不足：将内存缩小为了原来的一半</p>
<p>  实际中我们并不需要按照1:1比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor<br>  当另一个Survivor空间没有足够空间存放上一次新生代收集下来的存活对象时，这些对象将直接通过分配担保机制进入老年代</p>
</li>
<li><p>标记整理算法<br>  让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存</p>
</li>
<li><p>分代收集算法<br>  只是根据对象存活周期的不同将内存划分为几块。一般是把java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用标记清理或者标记整理算法来进行回收</p>
</li>
</ul>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><ul>
<li>Serial收集器：<br>  这个收集器是一个单线程的收集器，但它的单线程的意义不仅仅说明它会只使用一个COU或一条收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集时，必须暂停其他所有的工作线程，直到它手机结束</li>
<li><p>ParNew 收集器：<br>  Serial收集器的多线程版本，除了使用了多线程进行收集之外，其余行为和Serial收集器一样</p>
<p>  并行：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态</p>
<p>  并发：指用户线程与垃圾收集线程同时执行（不一定是并行的，可能会交替执行），用户程序在继续执行，而垃圾收集程序运行于另一个CPU上</p>
</li>
<li><p>Parallel Scavenge<br>  收集器是一个新生代收集器，它是使用复制算法的收集器，又是并行的多线程收集器。</p>
<p>  吞吐量：就是CPU用于运行用户代码的时间与CPU总消耗时间的比值。即吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）</p>
</li>
<li>Serial Old 收集器：<br>  是Serial收集器的老年代版本,是一个单线程收集器，使用标记整理算法</li>
<li>Parallel Old 收集器：<br>  Parallel Old是Paraller Seavenge收集器的老年代版本，使用多线程和标记整理算法</li>
<li><p>CMS收集器：<br>  CMS收集器是基于标记清除算法实现的，整个过程分为4个步骤：</p>
<p>  1.初始标记2.并发标记3.重新标记4.并发清除</p>
<p>  优点：并发收集、低停顿<br>  缺点：</p>
<ol>
<li>CMS收集器对CPU资源非常敏感，CMS默认启动的回收线程数是（CPU数量+3）/4，</li>
<li>CMS收集器无法处理浮动垃圾，可能出现Failure失败而导致一次Full G场地产生</li>
<li>CMS是基于标记清除算法实现的</li>
</ol>
</li>
<li>G1收集器：<br>  它是一款面向服务器应用的垃圾收集器<ol>
<li>并行与并发：利用多CPU缩短STOP-The-World停顿的时间</li>
<li>分代收集</li>
<li>空间整合：不会产生内存碎片</li>
<li>可预测的停顿<br> 运作方式：初始标记，并发标记，最终标记，筛选回收<br>6.内存分配与回收策略<h4 id="对象优先在Eden分配："><a href="#对象优先在Eden分配：" class="headerlink" title="对象优先在Eden分配："></a>对象优先在Eden分配：</h4>大多数情况对象在新生代Eden区分配，当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC</li>
</ol>
</li>
</ul>
<h4 id="大对象直接进入老年代："><a href="#大对象直接进入老年代：" class="headerlink" title="大对象直接进入老年代："></a>大对象直接进入老年代：</h4><p>所谓大对象就是指需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组。这样做的目的是避免Eden区及两个Servivor之间发生大量的内存复制</p>
<h4 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h4><p>如果对象在Eden区出生并且尽力过一次Minor GC后仍然存活，并且能够被Servivor容纳，将被移动到Servivor空间中，并且把对象年龄设置成为1.对象在Servivor区中每熬过一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认15岁），就将会被晋级到老年代中</p>
<h4 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h4><p>为了更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋级到老年代，如果在Servivor空间中相同年龄所有对象的大小总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入到老年代，无须登到MaxTenuringThreshold中要求的年龄</p>
<h4 id="空间分配担保："><a href="#空间分配担保：" class="headerlink" title="空间分配担保："></a>空间分配担保：</h4><p>在发生Minor GC 之前，虚拟机会检查老年代最大可 用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor DC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许那么会继续检查老年代最大可用的连续空间是否大于晋级到老年代对象的平均大小，如果大于，将尝试进行一次Minor GC，尽管这次MinorGC 是有风险的：如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC</p>
<h2 id="虚拟机类加载机制"><a href="#虚拟机类加载机制" class="headerlink" title="虚拟机类加载机制"></a>虚拟机类加载机制</h2><p>虚拟机吧描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制<br>在Java语言里面，类型的加载。连接和初始化过程都是在程序运行期间完成的</p>
<h3 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h3><p>类被加载到虚拟机内存中开始，到卸载为止，整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载7个阶段</p>
<p>加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以再初始化阶段之后再开始，这个是为了支持Java语言运行时绑定（也成为动态绑定或晚期绑定）</p>
<p>虚拟机规范规定有且只有5种情况必须立即对类进行初始化：</p>
<ol>
<li>遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要触发其初始化。生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候、读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候</li>
<li>使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化</li>
<li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化</li>
<li>当虚拟机启动时候，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类</li>
<li>当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化<br>被动引用：</li>
</ol>
<ul>
<li>通过子类引用父类的静态字段，不会导致子类初始化</li>
<li>通过数组定义来引用类，不会触发此类的初始化</li>
<li>常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化<br>接口的初始化：接口在初始化时，并不要求其父接口全部完成类初始化，只有在正整使用到父接口的时候（如引用接口中定义的常量）才会初始化<h2 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h2><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3></li>
<li>通过一个类的全限定名类获取定义此类的二进制字节流</li>
<li>将这字节流所代表的静态存储结构转化为方法区运行时数据结构</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</li>
</ul>
<p>怎么获取二进制字节流？</p>
<ul>
<li>从ZIP包中读取，这很常见，最终成为日后JAR、EAR、WAR格式的基础</li>
<li>从网络中获取，这种场景最典型的应用就是Applet</li>
<li>运行时计算生成，这种常见使用得最多的就是动态代理技术</li>
<li>由其他文件生成，典型场景就是JSP应用</li>
<li><p>从数据库中读取，这种场景相对少一些（中间件服务器）<br>数组类本身不通过类加载器创建，它是由Java虚拟机直接创建的<br>数组类的创建过程遵循以下规则：</p>
</li>
<li><p>如果数组的组件类型(指的是数组去掉一个维度的类型)是引用类型，那就递归采用上面的加载过程去加载这个组件类型，数组C将在加载该组件类型的类加载器的类名称空间上被标识</p>
</li>
<li>如果数组的组件类型不是引用类型(列如int[]组数)，Java虚拟机将会把数组C标识为与引导类加载器关联</li>
<li>数组类的可见性与它的组件类型的可见性一致，如果组件类型不是引用类型，那数组类的可见性将默认为public</li>
</ul>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>验证阶段会完成下面4个阶段的检验动作：文件格式验证，元数据验证，字节码验证，符号引用验证</p>
<h3 id="文件格式验证"><a href="#文件格式验证" class="headerlink" title="文件格式验证"></a>文件格式验证</h3><p>第一阶段要验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。这一阶段可能包括：</p>
<ol>
<li>是否以魔数oxCAFEBABE开头</li>
<li>主、次版本号是否在当前虚拟机处理范围之内</li>
<li>常量池的常量中是否有不被支持的常量类型(检查常量tag标志)</li>
<li>指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量</li>
<li>CONSTANT_Itf8_info 型的常量中是否有不符合UTF8编码的数据</li>
<li>Class文件中各个部分及文件本身是否有被删除的或附加的其他信息<br>这个阶段的验证时基于二进制字节流进行的，只有通过类这个阶段的验证后，字节流才会进入内存的方法区进行存储，所以后面的3个验证阶段全部是基于方法区的存储结构进行的，不会再直接操作字节流<h3 id="元数据验证"><a href="#元数据验证" class="headerlink" title="元数据验证"></a>元数据验证</h3></li>
<li>这个类是否有父类(除了java.lang.Object之外,所有的类都应当有父类)</li>
<li>这个类的父类是否继承了不允许被继承的类（被final修饰的类）</li>
<li>如果这个类不是抽象类，是否实现类其父类或接口之中要求实现的所有方法</li>
<li>类中的字段、方法是否与父类产生矛盾(列如覆盖类父类的final字段,或者出现不符合规则的方法重载，列如方法参数都一致，但返回值类型却不同等)<br>第二阶段的主要目的是对类元数据信息进行语义校验，保证不存在不符合Java语言规范的元数据信息<h3 id="字节码验证"><a href="#字节码验证" class="headerlink" title="字节码验证"></a>字节码验证</h3>第三阶段是整个验证过程中最复杂的一个阶段，主要目的似乎通过数据流和控制流分析，确定程序语言是合法的、符合逻辑的。在第二阶段对元数据信息中的数据类型做完校验后，这个阶段将对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件。</li>
<li>保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，列如，列如在操作数栈放置类一个int类型的数据，使用时却按long类型来加载入本地变量表中</li>
<li>保证跳转指令不会跳转到方法体以外的字节码指令上</li>
<li>保证方法体中的类型转换时有效的，列如可以把一个子类对象赋值给父类数据类型，这个是安全的，但是吧父类对象赋值给子类数据类型，甚至把对象赋值给与它毫无继承关系、完全不相干的一个数据类型，则是危险和不合法的<h3 id="符号引用验证"><a href="#符号引用验证" class="headerlink" title="符号引用验证"></a>符号引用验证</h3>发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。</li>
<li>符号引用中通过字符串描述的全限定名是否能找到相对应的类</li>
<li>在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段</li>
<li>符号引用中的类、字段、方法的访问性是否可被当前类访问</li>
</ol>
<p>对于虚拟机的类加载机制来说，验证阶段是非常重要的，但是不一定必要（因为对程序运行期没有影响）的阶段。如果全部代码都已经被反复使用和验证过，那么在实施阶段就可以考虑使用Xverify：none参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间</p>
<h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量都在方法区中进行分配。这个时候进行内存分配的仅包括类变量(被static修饰的变量)，而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。其次，这里说的初始值通常下是数据类型的零值。<br>假设public static int value = 123；<br>那变量value在准备阶段过后的初始值为0而不是123，因为这时候尚未开始执行任何Java方法，而把value赋值为123的putstatic指令是程序被编译后，存放于类构造器<clinit>()方法之中，所以把value赋值为123的动作将在初始化阶段才会执行，但是如果使用final修饰，则在这个阶段其初始值设置为123</clinit></p>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>解析阶段是虚拟机将常量池内符号引用替换为直接引用的过</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>类的初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才正真开始执行类中定义的Java程序代码(或者说是字节码)</p>
<h2 id="类的加载器"><a href="#类的加载器" class="headerlink" title="类的加载器"></a>类的加载器</h2><h4 id="双亲委派模型："><a href="#双亲委派模型：" class="headerlink" title="双亲委派模型："></a>双亲委派模型：</h4><p>只存在两种不同的类加载器：启动类加载器（Bootstrap ClassLoader），使用C++实现，是虚拟机自身的一部分。另一种是所有其他的类加载器，使用JAVA实现，独立于JVM，并且全部继承自抽象类java.lang.ClassLoader.</p>
<p>启动类加载器（Bootstrap ClassLoader），负责将存放在<java+home>\lib目录中的，或者被-Xbootclasspath参数所制定的路径中的，并且是JVM识别的（仅按照文件名识别，如rt.jar，如果名字不符合，即使放在lib目录中也不会被加载），加载到虚拟机内存中，启动类加载器无法被JAVA程序直接引用。</java+home></p>
<p>扩展类加载器，由sun.misc.Launcher$ExtClassLoader实现，负责加载<java_home>\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。</java_home></p>
<p>应用程序类加载器（Application ClassLoader），由sun.misc.Launcher$AppClassLoader来实现。由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，所以一般称它为系统类加载器。负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p>
<p>这张图表示类加载器的双亲委派模型（Parents Delegation model）. 双亲委派模型要求除了顶层的启动加载类外，其余的类加载器都应当有自己的父类加载器。，这里类加载器之间的父子关系一般不会以继承的关系来实现，而是使用组合关系来复用父类加载器的代码。</p>
<h4 id="双亲委派模型的工作过程是："><a href="#双亲委派模型的工作过程是：" class="headerlink" title="双亲委派模型的工作过程是："></a>双亲委派模型的工作过程是：</h4><p>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都是应该传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。</p>
<h4 id="这样做的好处就是："><a href="#这样做的好处就是：" class="headerlink" title="这样做的好处就是："></a>这样做的好处就是：</h4><p>Java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object,它存放在rt.jar中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为java.lang.object的类，并放在程序的ClassPath中，那系统中将会出现多个不同的Object类，Java类型体系中最基础的行为也就无法保证，应用程序也将会变得一片混乱<br>就是保证某个范围的类一定是被某个类加载器所加载的，这就保证在程序中同 一个类不会被不同的类加载器加载。这样做的一个主要的考量，就是从安全层 面上，杜绝通过使用和JRE相同的类名冒充现有JRE的类达到替换的攻击方式</p>
<h2 id="Java内存模型与线程"><a href="#Java内存模型与线程" class="headerlink" title="Java内存模型与线程"></a>Java内存模型与线程</h2><h3 id="内存间的交互操作"><a href="#内存间的交互操作" class="headerlink" title="内存间的交互操作"></a>内存间的交互操作</h3><p>关于主内存与工作内存之间的具体交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步到主内存之间的实现细节，Java内存模型定义了以下八种操作来完成：</p>
<ul>
<li>lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态。</li>
<li>unlock（解锁）：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li>
<li>read（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用</li>
<li>load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</li>
<li>use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。</li>
<li>assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。<br>store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。</li>
<li>write（写入）：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。<br>　　如果要把一个变量从主内存中复制到工作内存，就需要按顺寻地执行read和load操作， 如果把变量从工作内存中同步回主内存中，就要按顺序地执行store和write操作。Java内存 模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。也就是read和load之间， store和write之间是可以插入其他指令的，如对主内存中的变量a、b进行访问时，可能的顺 序是read a，read b，load b， load a。</li>
</ul>
<p>Java内存模型还规定了在执行上述八种基本操作时，必须满足如下规则：</p>
<ul>
<li>不允许read和load、store和write操作之一单独出现</li>
<li>不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中。</li>
<li>不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中。</li>
<li>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。</li>
<li>一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。lock和unlock必须成对出现<br>如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值<br>如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。<br>对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）。</li>
</ul>
<h3 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h3><p>在执行程序时为了提高性能，编译器和处理器经常会对指令进行重排序。重排序分成三种类型：</p>
<ol>
<li>编译器优化的重排序。编译器在不改变单线程程序语义放入前提下，可以重新安排语句的执行顺序。</li>
<li>指令级并行的重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li>
<li>内存系统的重排序。由于处理器使用缓存和读写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li>
</ol>
<p>从Java源代码到最终实际执行的指令序列，会经过下面三种重排序：</p>
<p>为了保证内存的可见性，Java编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。Java内存模型把内存屏障分为LoadLoad、LoadStore、StoreLoad和StoreStore四种：</p>
<h3 id="对于volatile型变量的特殊规则"><a href="#对于volatile型变量的特殊规则" class="headerlink" title="对于volatile型变量的特殊规则"></a>对于volatile型变量的特殊规则</h3><p>当一个变量定义为volatile之后，它将具备两种特性：</p>
<p>第一：保证此变量对所有线程的可见性，这里的可见性是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。普通变量的值在线程间传递需要通过主内存来完成<br>由于valatile只能保证可见性，在不符合一下两条规则的运算场景中，我们仍要通过加锁来保证原子性</p>
<ol>
<li>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。</li>
<li>变量不需要与其他的状态变量共同参与不变约束</li>
<li>第二：禁止指令重排序，普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中执行顺序一致，这个就是所谓的线程内表现为串行的语义</li>
</ol>
<p>Java内存模型中对volatile变量定义的特殊规则。假定T表示一个线程，V和W分别表示两个volatile变量，那么在进行read、load、use、assign、store、write操作时需要满足如下的规则：</p>
<ol>
<li>只有当线程T对变量V执行的前一个动作是load的时候，线程T才能对变量V执行use动作；并且，只有当线程T对变量V执行的后一个动作是use的时候，线程T才能对变量V执行load操作。线程T对变量V的use操作可以认为是与线程T对变量V的load和read操作相关联的，必须一起连续出现。这条规则要求在工作内存中，每次使用变量V之前都必须先从主内存刷新最新值，用于保证能看到其它线程对变量V所作的修改后的值。</li>
<li>只有当线程T对变量V执行的前一个动是assign的时候，线程T才能对变量V执行store操作；并且，只有当线程T对变量V执行的后一个动作是store操作的时候，线程T才能对变量V执行assign操作。线程T对变量V的assign操作可以认为是与线程T对变量V的store和write操作相关联的，必须一起连续出现。这一条规则要求在工作内存中，每次修改V后都必须立即同步回主内存中，用于保证其它线程可以看到自己对变量V的修改。</li>
<li>假定操作A是线程T对变量V实施的use或assign动作，假定操作F是操作A相关联的load或store操作，假定操作P是与操作F相应的对变量V的read或write操作；类型地，假定动作B是线程T对变量W实施的use或assign动作，假定操作G是操作B相关联的load或store操作，假定操作Q是与操作G相应的对变量V的read或write操作。如果A先于B，那么P先于Q。这条规则要求valitile修改的变量不会被指令重排序优化，保证代码的执行顺序与程序的顺序相同。<h3 id="对于long和double型变量的特殊规则"><a href="#对于long和double型变量的特殊规则" class="headerlink" title="对于long和double型变量的特殊规则"></a>对于long和double型变量的特殊规则</h3>Java模型要求lock、unlock、read、load、assign、use、store、write这8个操作都具有原子性，但是对于64为的数据类型（long和double），在模型中特别定义了一条相对宽松的规定：允许虚拟机将没有被volatile修饰的64位数据的读写操作分为两次32为的操作来进行，即允许虚拟机实现选择可以不保证64位数据类型的load、store、read和write这4个操作的原子性<h3 id="原子性、可见性和有序性"><a href="#原子性、可见性和有序性" class="headerlink" title="原子性、可见性和有序性"></a>原子性、可见性和有序性</h3>原子性：即一个操作或者多个操作</li>
</ol>
<p>要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。Java内存模型是通过在变量修改后将新值同步会主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性，valatile特殊规则保障新值可以立即同步到祝内存中。Synchronized是在对一个变量执行unlock之前，必须把变量同步回主内存中（执行store、write操作）。被final修饰的字段在构造器中一旦初始化完成，并且构造器没有吧this的引用传递出去，那在其他线程中就能看见final字段的值</p>
<p>可见性：可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p>
<p>有序性：即程序执行的顺序按照代码的先后顺序执行。</p>
<h3 id="先行发生原则"><a href="#先行发生原则" class="headerlink" title="先行发生原则"></a>先行发生原则</h3><p>这些先行发生关系无须任何同步就已经存在，如果不再此列就不能保障顺序性，虚拟机就可以对它们任意地进行重排序</p>
<ol>
<li>程序次序规则：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确的说，应该是控制顺序而不是程序代码顺序，因为要考虑分支。循环等结构</li>
<li>管程锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是同一个锁，而后面的是指时间上的先后顺序</li>
<li>Volatile变量规则：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的后面同样是指时间上的先后顺序</li>
<li>线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作</li>
<li>线程终止规则：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.joke()方法结束、ThradisAlive()的返回值等手段检测到线程已经终止执行</li>
<li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断时间的发生，可以通过Thread.interrupted()方法检测到是否有中断发生</li>
<li>对象终结规则：一个对象的初始化完成(构造函数执行结束)先行发生于它的finalize()方法的开始</li>
<li>传递性：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论<h3 id="Java线程调度"><a href="#Java线程调度" class="headerlink" title="Java线程调度"></a>Java线程调度</h3></li>
</ol>
<p>协同式调度：线程的执行时间由线程本身控制</p>
<p>抢占式调度：线程的执行时间由系统来分配</p>
<h3 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h3><ol>
<li>新建</li>
<li>运行：可能正在执行。可能正在等待CPU为它分配执行时间</li>
<li>无限期等待：不会被分配CUP执行时间，它们要等待被其他线程显式唤醒</li>
<li>限期等待：不会被分配CUP执行时间，它们无须等待被其他线程显式唤醒，一定时间会由系统自动唤醒</li>
<li>阻塞：阻塞状态在等待这获取到一个排他锁，这个时间将在另一个线程放弃这个锁的时候发生；等待状态就是在等待一段时间，或者唤醒动作的发生</li>
<li>结束：已终止线程的线程状态，线程已经结束执行</li>
</ol>
<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><ol>
<li>不可变：不可变的对象一定是线程安全的、无论是对象的方法实现还是方法的调用者，都不需要再采取任何的线程安全保障。例如：把对象中带有状态的变量都声明为final，这样在构造函数结束之后，它就是不可变的。</li>
<li>绝对线程安全</li>
<li>相对线程安全：相对的线程安全就是我们通常意义上所讲的线程安全，它需要保证对这个对象单独的操作是线程安全的，我们在调用的时候不需要做额外的保障措施，但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性</li>
<li>线程兼容：对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全使用</li>
<li>线程对立：是指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码<h3 id="线程安全的实现方法"><a href="#线程安全的实现方法" class="headerlink" title="线程安全的实现方法"></a>线程安全的实现方法</h3></li>
<li>互斥同步：<br>同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个（或者是一些，使用信号量的时候）线程使用。而互斥是实现同步的一种手段，临界区、互斥量和信号量都是主要的互斥实现方式。互斥是因，同步是果：互斥是方法，同步是目的.</li>
</ol>
<p>在Java中，最基本的互斥同步手段就是synchronized关键字，它经过编译之后，会在同步块的前后分别形成monitorenter和monitorexit这两个字节码指令，这两个字节码都需要一个reference类型的参数来指明要锁定和解锁的对象。如果Java程序中的synchronized明确指定了对象参数，那就是这个对象的reference；如果没有指明，那就根据synchronized修饰的是实例方法还是类方法，去取对应的对象实例或Class对象来作为锁对象。在执行monitorenter指令时，首先要尝试获取对象的锁。如果这个对象没有被锁定，或者当前线程已经拥有了那个对象的锁，把锁的计数器加1，对应的在执行monitorexit指令时会将锁计数器减1，当计数器为0时，锁就被释放。如果获取对象锁失败，哪当前线程就要阻塞等待，直到对象锁被另外一个线程释放为止</p>
<p>Synchronized，ReentrantLock增加了一些高级功能</p>
<ol>
<li>等待可中断：是指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情，可中断特性对处理执行时间非常长的同步块很有帮助</li>
<li>公平锁：是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁；非公平锁则不能保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。Synchronized中的锁是非公平的，ReentrantLock默认情况下也是非公平的，但可以通过带布尔值的构造函数要求使用公平锁</li>
<li>锁绑定多个条件是指一个ReentrantLock对象可以同时绑定多个Condition对象，而在synchronized中，锁对象的wait()和notify()或notifyAll()方法可以实现一个隐含的条件，如果要和多余一个的条件关联的时候，就不得不额外地添加一个锁，而ReentrantLock则无须这样做，只需要多次调用newCondition方法即可</li>
<li>非阻塞同步</li>
<li>无同步方案<br>可重入代码：也叫纯代码，可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身）而在控制权返回后，原来的程序不会出现任何错误。所有的可重入代码都是线程安全的，但是并非所有的线程安全的代码都是可重入的。</li>
</ol>
<p>判断一个代码是否具备可重入性：如果一个方法，它的返回结果是可预测的，只要输入了相同的数据，就都能返回相同的结果，那它就满足可重入性的要求，当然也就是线程安全的</p>
<p>线程本地存储：如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行？如果能保障，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题</p>
<h3 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h3><p>适应性自旋、锁消除、锁粗化、轻量级锁和偏向锁</p>
<h3 id="自旋锁与自适应自旋"><a href="#自旋锁与自适应自旋" class="headerlink" title="自旋锁与自适应自旋"></a>自旋锁与自适应自旋</h3><p>自旋锁：如果物理机器上有一个以上的处理器，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程稍等一下，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只需让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁</p>
<p>自适应自旋转：是由前一次在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能省略掉自过程，以避免浪费处理器资源。</p>
<h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>锁消除是指虚拟机即时编辑器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。如果在一段代码中。推上的所有数据都不会逃逸出去从而被其他线程访问到，那就可以把它们当作栈上数据对待，认为它们是线程私有的，同步加锁自然就无须进行</p>
<h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>如果虚拟机检测到有一串零碎的操作都是对同一对象的加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部</p>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>它的目的是消除无竞争情况下的同步原语，进一步提高程序的运行性能。如果轻量级锁是在无竞争的情况下使用CAS操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把这个同步都消除掉，CAS操作都不做了<br>如果在接下俩的执行过程中，该锁没有被其他线程获取，则持有偏向锁的线程将永远不需要在进行同步</p>
<h2 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h2><p>逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他方法中，成为方法逃逸。甚至还可能被外部线程访问到，比如赋值给类变量或可以在其他线程中访问的实例变量，称为线程逃逸</p>
<p>如果一个对象不会逃逸到方法或线程之外，也就是别的方法或线程无法通过任何途径访问到这个对象，则可能为这个变量进行一些高效的优化<br>栈上分配：如果确定一个对象不会逃逸出方法外，那让这个对象在栈上分配内存将会是一个不错的注意，对象所占用的内存空间就可以随栈帧出栈而销毁。如果能使用栈上分配，那大量的对象就随着方法的结束而销毁了，垃圾收集系统的压力将会小很多</p>
<p>同步消除：如果确定一个变量不会逃逸出线程，无法被其他线程访问，那这个变量的读写肯定就不会有竞争，对这个变量实施的同步措施也就可以消除掉</p>
<p>标量替换：标量就是指一个数据无法在分解成更小的数据表示了，int、long等及refrence类型等都不能在进一步分解，它们称为标量。</p>
<p>如果一个数据可以继续分解，就称为聚合量，Java中的对象就是最典型的聚合量</p>
<p>如果一个对象不会被外部访问，并且这个对象可以被拆散的化，那程序正整执行的时候将可能不创建这个对象，而改为直接创建它的若干个被这个方法使用到的成员变量来代替</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Spark架构及原理]]></title>
      <url>/Spark%E6%9E%B6%E6%9E%84%E5%8F%8A%E5%8E%9F%E7%90%86.html</url>
      <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2R1ZGVmdTAxMS9hcnRpY2xlL2RldGFpbHMvODAwODA2NDU=" title="https://blog.csdn.net/dudefu011/article/details/80080645">Spark架构及原理<i class="fa fa-external-link"></i></span></p>
]]></content>
      
        <categories>
            
            <category> 大数据 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Spark </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[RDD原理]]></title>
      <url>/RDD%E5%8E%9F%E7%90%86.html</url>
      <content type="html"><![CDATA[<h2 id="RDD概念"><a href="#RDD概念" class="headerlink" title="RDD概念"></a>RDD概念</h2><p>RDD（Resilient Distributed Dataset）叫做分布式数据集，是Spark中最基本的数据抽象，它代表一个不可变、可分区、里面的元素可并行计算的集合。RDD具有数据流模型的特点：自动容错、位置感知性调度和可伸缩性。RDD允许用户在执行多个查询时显式地将工作集缓存在内存中，后续的查询能够重用工作集，这极大地提升了查询速度。<br><a id="more"></a><br>RDD是Spark的最基本抽象,是对分布式内存的抽象使用，实现了以操作本地集合的方式来操作分布式数据集的抽象实现。RDD是Spark最核心的东西，它表示已被分区，不可变的并能够被并行操作的数据集合，不同的数据集格式对应不同的RDD实现。RDD必须是可序列化的。RDD可以cache到内存中，每次对RDD数据集的操作之后的结果，都可以存放到内存中，下一个操作可以直接从内存中输入，省去了MapReduce大量的磁盘IO操作</p>
<p>RDD可以横向多分区，当计算过程中内存不足时，将数据刷到磁盘等外部存储上，从而实现数据在内存和外存的灵活切换。可以说，RDD是有虚拟数据结构组成，并不包含真实数据体。</p>
<h2 id="RDD的内部属性"><a href="#RDD的内部属性" class="headerlink" title="RDD的内部属性"></a>RDD的内部属性</h2><p>通过RDD的内部属性，用户可以获取相应的元数据信息。通过这些信息可以支持更复杂的算法或优化。</p>
<h3 id="一组分片（Partition），即数据集的基本组成单位"><a href="#一组分片（Partition），即数据集的基本组成单位" class="headerlink" title="一组分片（Partition），即数据集的基本组成单位"></a>一组分片（Partition），即数据集的基本组成单位</h3><p>对于RDD来说，每个分片都会被一个task计算任务处理，并决定并行计算的粒度。用户可以在创建RDD时指定RDD的分片个数，如果没有指定，那么就会采用默认值。默认值就是程序所分配的CPU Core的数据。</p>
<h3 id="计算每个分片的函数"><a href="#计算每个分片的函数" class="headerlink" title="计算每个分片的函数"></a>计算每个分片的函数</h3><p>Spark中RDD的计算是以分片为单位的，通过函数可以对每个数据块进行RDD需要进行的用户自定义函数运算。函数会对迭代器进行复合，不需要保存每次计算的结果。</p>
<h3 id="RDD之间的依赖关系"><a href="#RDD之间的依赖关系" class="headerlink" title="RDD之间的依赖关系"></a>RDD之间的依赖关系</h3><p>对父RDD的依赖列表，依赖还具体分为宽依赖和窄依赖，但并不是所有的RDD都有依赖。RDD的<strong>每次转换都会生成一个新的RDD</strong>，所以RDD之间就会形成类似于流水线一样的前后依赖关系。在部分分区数据丢失时，Spark可以通过这个依赖关系重新计算丢失的分区数据，而不是对RDD的所有分区进行重新计算。</p>
<h3 id="一个Partitioner，即RDD的分片函数"><a href="#一个Partitioner，即RDD的分片函数" class="headerlink" title="一个Partitioner，即RDD的分片函数"></a>一个Partitioner，即RDD的分片函数</h3><p>当前Spark中实现了两种类型的分片函数，一个是基于哈希的HashPartitioner，另外一个是基于范围的RangePartitioner。只有对于于key-value的RDD，才会有Partitioner，非key-value的RDD的Parititioner的值是None。Partitioner函数不但决定了RDD本身的分片数量，也决定了parent RDD Shuffle输出时的分片数量。</p>
<h3 id="分区列表，存储存取每个Partition的优先位置（preferred-location）"><a href="#分区列表，存储存取每个Partition的优先位置（preferred-location）" class="headerlink" title="分区列表，存储存取每个Partition的优先位置（preferred location）"></a>分区列表，存储存取每个Partition的优先位置（preferred location）</h3><p>对于一个HDFS文件来说，这个列表保存的就是每个Partition所在的块的位置。按照“移动数据不如移动计算”的理念，Spark在进行任务调度的时候，会尽可能地将计算任务分配到其所要处理数据块的存储位置。</p>
<h3 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h3><p>key-value型的RDD是根据哈希来分区的，类似于mapreduce当中的Paritioner接口，控制key分到哪个reduce。</p>
<h3 id="可选属性-1"><a href="#可选属性-1" class="headerlink" title="可选属性"></a>可选属性</h3><p>每一个分片的优先计算位置（preferred locations），比如HDFS的block的所在位置应该是优先计算的位置。(存储的是一个表，可以将处理的分区“本地化”)</p>
<h2 id="RDD的特点"><a href="#RDD的特点" class="headerlink" title="RDD的特点"></a>RDD的特点</h2><ol>
<li>创建：只能通过转换 ( transformation ，如map/filter/groupBy/join 等，区别于动作 action) 从两种数据源中创建 RDD 1 ）稳定存储中的数据； 2 ）其他 RDD。</li>
<li><p>只读：状态不可变，不能修改。</p>
</li>
<li><p>分区：支持使 RDD 中的元素根据那个 key 来分区 ( partitioning ) ，保存到多个结点上。还原时只会重新计算丢失分区的数据，而不会影响整个系统。</p>
</li>
<li><p>路径：在 RDD 中叫世族或血统 ( lineage ) ，即 RDD 有充足的信息关于它是如何从其他 RDD 产生而来的。</p>
</li>
<li><p>持久化：支持将会被重用的 RDD 缓存 ( 如 in-memory 或溢出到磁盘 )。</p>
</li>
<li><p>延迟计算：Spark 也会延迟计算 RDD ，使其能够将转换管道化 (pipeline transformation)。</p>
</li>
<li><p>操作：丰富的转换（transformation）和动作 ( action ) ， count/reduce/collect/save 等。<br>   执行了多少次transformation操作，RDD都不会真正执行运算（记录lineage），只有当action操作被执行时，运算才会触发。</p>
</li>
</ol>
<h2 id="RDD的优点"><a href="#RDD的优点" class="headerlink" title="RDD的优点"></a>RDD的优点</h2><ol>
<li>RDD只能从持久存储或通过Transformations操作产生，相比于分布式共享内存(DSM)可以更高效实现容错，对于丢失部分数据分区只需根据它的lineage就可重新计算出来，而不需要做特定的Checkpoint。</li>
<li>RDD的不变性，可以实现类Hadoop MapReduce的推测式执行。</li>
<li>RDD的数据分区特性，可以通过数据的本地性来提高性能，这不Hadoop MapReduce是一样的。</li>
<li>RDD都是可序列化的，在内存不足时可自动降级为磁盘存储，把RDD存储于磁盘上，这时性能会有大的下降但不会差于现在的MapReduce。</li>
<li>批量操作：任务能够根据数据本地性 (data locality) 被分配，从而提高性能。</li>
</ol>
<h2 id="RDD的存储与分区"><a href="#RDD的存储与分区" class="headerlink" title="RDD的存储与分区"></a>RDD的存储与分区</h2><ol>
<li>用户可以选择不同的存储级别存储RDD以便重用。</li>
<li>当前RDD默认是存储于内存，但当内存不足时，RDD会spill到disk。</li>
<li>RDD在需要进行分区把数据分布于集群中时会根据每条记录Key进行分区（如Hash 分区），以此保证两个数据集在Join时能高效。</li>
<li>RDD根据useDisk、useMemory、useOffHeap、deserialized、replication参数的组合定义了以下存储级别：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//存储等级定义：  </span><br><span class="line">val NONE = new StorageLevel(false, false, false, false)  </span><br><span class="line">val DISK_ONLY = new StorageLevel(true, false, false, false)  </span><br><span class="line">val DISK_ONLY_2 = new StorageLevel(true, false, false, false, 2)  </span><br><span class="line">val MEMORY_ONLY = new StorageLevel(false, true, false, true)  </span><br><span class="line">val MEMORY_ONLY_2 = new StorageLevel(false, true, false, true, 2)  </span><br><span class="line">val MEMORY_ONLY_SER = new StorageLevel(false, true, false, false)  </span><br><span class="line">val MEMORY_ONLY_SER_2 = new StorageLevel(false, true, false, false, 2)  </span><br><span class="line">val MEMORY_AND_DISK = new StorageLevel(true, true, false, true)  </span><br><span class="line">val MEMORY_AND_DISK_2 = new StorageLevel(true, true, false, true, 2)  </span><br><span class="line">val MEMORY_AND_DISK_SER = new StorageLevel(true, true, false, false)  </span><br><span class="line">val MEMORY_AND_DISK_SER_2 = new StorageLevel(true, true, false, false, 2)  </span><br><span class="line">val OFF_HEAP = new StorageLevel(false, false, true, false)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="RDD的容错机制"><a href="#RDD的容错机制" class="headerlink" title="RDD的容错机制"></a>RDD的容错机制</h2><p>RDD的容错机制实现分布式数据集容错方法有两种：<strong>数据检查点</strong>和<strong>记录更新</strong></p>
<p>RDD采用记录更新的方式：记录所有更新点的成本很高。所以，RDD只支持粗颗粒变换，即只记录单个块（分区）上执行的单个操作，然后创建某个RDD的变换序列（血统 lineage）存储下来；</p>
<p>变换序列指，每个RDD都包含了它是如何由其他RDD变换过来的以及如何重建某一块数据的信息。因此RDD的容错机制又称“<strong>血统</strong>”容错。</p>
<p>要实现这种“血统”容错机制，最大的难题就是<strong>如何表达父RDD和子RDD之间的依赖关系</strong>。实际上依赖关系可以分两种，<strong>窄依赖</strong>和<strong>宽依赖</strong>。</p>
<p><strong>窄依赖</strong>：子RDD中的每个数据块只依赖于父RDD中对应的有限个固定的数据块</p>
<p><strong>宽依赖</strong>：子RDD中的一个数据块可以依赖于父RDD中的<strong>所有数据块</strong>。例如：map变换，子RDD中的数据块只依赖于父RDD中对应的一个数据块；groupByKey变换，子RDD中的数据块会依赖于多块父RDD中的数据块，因为一个key可能分布于父RDD的任何一个数据块中</p>
<p>将依赖关系分类的两个特性：</p>
<ol>
<li>窄依赖可以在某个计算节点上直接通过计算父RDD的某块数据计算得到子RDD对应的某块数据；宽依赖则要等到父RDD所有数据都计算完成之后，并且父RDD的计算结果进行hash并传到对应节点上之后才能计算子RDD。</li>
<li>数据丢失时，对于窄依赖只需要重新计算丢失的那一块数据来恢复；对于宽依赖则要将祖先RDD中的所有数据块全部重新计算来恢复。</li>
</ol>
<p><strong>所以在“血统”链特别是有宽依赖的时候，需要在适当的时机设置数据检查点。也是这两个特性要求对于不同依赖关系要采取不同的任务调度机制和容错恢复机制。</strong></p>
<h2 id="Spark计算工作流"><a href="#Spark计算工作流" class="headerlink" title="Spark计算工作流"></a>Spark计算工作流</h2><ol>
<li>输入：在Spark程序运行中，数据从外部数据空间（例如，HDFS、Scala集合或数据）输入到Spark，数据就进入了Spark运行时数据空间，会转化为Spark中的数据块，通过BlockManager进行管理。</li>
<li>运行：在Spark数据输入形成RDD后，便可以通过变换算子fliter等，对数据操作并将RDD转化为新的RDD，通过行动（Action）算子，触发Spark提交作业。如果数据需要复用，可以通过Cache算子，将数据缓存到内存。</li>
<li>输出：程序运行结束数据会输出Spark运行时空间，存储到分布式存储中（如saveAsTextFile输出到HDFS）或Scala数据或集合中（collect输出到Scala集合，count返回Scala Int型数据）。</li>
</ol>
<p>Spark的核心数据模型是RDD，但RDD是个抽象类，具体由各子类实现，如MappedRDD、ShuffledRDD等子类。Spark将常用的大数据操作都转化成为RDD的子类。</p>
<p><img src="http://ou3xxg3hg.bkt.clouddn.com/spark%E8%AE%A1%E7%AE%97%E5%B7%A5%E4%BD%9C%E6%B5%81.jpg" alt="image"><br><img src="http://ou3xxg3hg.bkt.clouddn.com/Spark%E8%BF%90%E8%A1%8C%E7%9A%84%E6%B5%81%E7%A8%8B.png" alt="image"><br><img src="http://ou3xxg3hg.bkt.clouddn.com/timg.jpg" alt="image"><br><img src="http://ou3xxg3hg.bkt.clouddn.com/spark%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.jpg" alt="image"></p>
<h2 id="RDD编程模型"><a href="#RDD编程模型" class="headerlink" title="RDD编程模型"></a>RDD编程模型</h2><p>textFile算子从HDFS读取日志文件，返回“file”（RDD）；filter算子筛出带“ERROR”的行，赋给 “errors”（新RDD）；cache算子把它缓存下来以备未来使用；count算子返回“errors”的行数。RDD看起来与Scala集合类型 没有太大差别，但它们的数据和运行模型大相迥异。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> file = sc.textFile(<span class="string">"hdfs://..."</span>)</span><br><span class="line"><span class="keyword">val</span> errors = file.filter(_.contains(<span class="string">"ERROR"</span>))</span><br><span class="line">errors.cache()</span><br><span class="line">errors.count()</span><br></pre></td></tr></table></figure></p>
<p>上面代码给出了RDD数据模型，并将上例中用到的四个算子映射到四种算子类型。Spark程序工作在两个空间中：Spark RDD空间和Scala原生数据空间。在原生数据空间里，数据表现为标量（scalar，即Scala基本类型，用橘色小方块表示）、集合类型（蓝色虚线 框）和持久存储（红色圆柱）。</p>
<p>下图描述了Spark运行过程中通过算子对RDD进行转换， 算子是RDD中定义的函数，可以对RDD中的数据进行转换和操作。<br><img src="https://img-blog.csdn.net/20160622185230526" alt="image"></p>
<p>输入算子（橘色箭头）将Scala集合类型或存储中的数据吸入RDD空间，转为RDD（蓝色实线框）。输入算子的输入大致有两类：一类针对 Scala集合类型，如parallelize；另一类针对存储数据，如上例中的textFile。输入算子的输出就是Spark空间的RDD。</p>
<p>因为函数语义，RDD经过变换（transformation）算子（蓝色箭头）生成新的RDD。变换算子的输入和输出都是RDD。RDD会被划分 成很多的分区 （partition）分布到集群的多个节点中，图1用蓝色小方块代表分区。注意，分区是个逻辑概念，变换前后的新旧分区在物理上可能是同一块内存或存 储。这是很重要的优化，以防止函数式不变性导致的内存需求无限扩张。有些RDD是计算的中间结果，其分区并不一定有相应的内存或存储与之对应，如果需要 （如以备未来使用），可以调用缓存算子（例子中的cache算子，灰色箭头表示）将分区物化（materialize）存下来（灰色方块）。</p>
<p>一部分变换算子视RDD的元素为简单元素，分为如下几类：</p>
<ul>
<li><p>输入输出一对一（element-wise）的算子，且结果RDD的分区结构不变，主要是map、flatMap（map后展平为一维RDD）；</p>
</li>
<li><p>输入输出一对一，但结果RDD的分区结构发生了变化，如union（两个RDD合为一个）、coalesce（分区减少）；</p>
</li>
<li><p>从输入中选择部分元素的算子，如filter、distinct（去除冗余元素）、subtract（本RDD有、它RDD无的元素留下来）和sample（采样）。</p>
</li>
</ul>
<p>另一部分变换算子针对Key-Value集合，又分为：</p>
<ul>
<li><p>对单个RDD做element-wise运算，如mapValues（保持源RDD的分区方式，这与map不同）；</p>
</li>
<li><p>对单个RDD重排，如sort、partitionBy（实现一致性的分区划分，这个对数据本地性优化很重要，后面会讲）；</p>
</li>
<li><p>对单个RDD基于key进行重组和reduce，如groupByKey、reduceByKey；</p>
</li>
<li><p>对两个RDD基于key进行join和重组，如join、cogroup。</p>
</li>
</ul>
<p>后三类操作都涉及重排，称为shuffle类操作。</p>
<p>从RDD到RDD的变换算子序列，一直在RDD空间发生。这里很重要的设计是lazy evaluation：计算并不实际发生，只是不断地记录到元数据。元数据的结构是DAG（有向无环图），其中每一个“顶点”是RDD（包括生产该RDD 的算子），从父RDD到子RDD有“边”，表示RDD间的依赖性。Spark给元数据DAG取了个很酷的名字，Lineage（世系）。这个 Lineage也是前面容错设计中所说的日志更新。</p>
<p>Lineage一直增长，直到遇上行动（action）算子（图1中的绿色箭头），这时 就要evaluate了，把刚才累积的所有算子一次性执行。行动算子的输入是RDD（以及该RDD在Lineage上依赖的所有RDD），输出是执行后生 成的原生数据，可能是Scala标量、集合类型的数据或存储。当一个算子的输出是上述类型时，该算子必然是行动算子，其效果则是从RDD空间返回原生数据空间。</p>
<h2 id="RDD的运行逻辑"><a href="#RDD的运行逻辑" class="headerlink" title="RDD的运行逻辑"></a>RDD的运行逻辑</h2><p>如图所示，在Spark应用中，整个执行流程在逻辑上运算之间会形成有向无环图。Action算子触发之后会将所有累积的算子形成一个有向无环图，然后由调度器调度该图上的任务进行运算。Spark的调度方式与MapReduce有所不同。Spark根据RDD之间不同的依赖关系切分形成不同的阶段（Stage），一个阶段包含一系列函数进行流水线执行。图中的A、B、C、D、E、F、G，分别代表不同的RDD，RDD内的一个方框代表一个数据块。数据从HDFS输入Spark，形成RDD A和RDD C，RDD C上执行map操作，转换为RDD D，RDD B和RDD F进行join操作转换为G，而在B到G的过程中又会进行Shuffle。最后RDD G通过函数saveAsSequenceFile输出保存到HDFS中。<br><img src="http://ou3xxg3hg.bkt.clouddn.com/spark%E6%B5%81%E7%A8%8B%E5%9B%BE1.jpg" alt="image"><br><img src="http://ou3xxg3hg.bkt.clouddn.com/RDD%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg" alt="image"></p>
<h2 id="RDD依赖关系"><a href="#RDD依赖关系" class="headerlink" title="RDD依赖关系"></a>RDD依赖关系</h2><p>RDD依赖关系如下图所示：<br><img src="https://img-blog.csdn.net/20160622174357363" alt="image"></p>
<p>窄依赖 (narrowdependencies) 和宽依赖 (widedependencies) 。</p>
<p>窄依赖是指 父 RDD 的每个分区都只被子 RDD 的一个分区所使用，例如map、filter。</p>
<p>宽依赖就是指父 RDD 的分区被多个子 RDD 的分区所依赖，例如groupByKey、reduceByKey等操作。如果父RDD的一个Partition被一个子RDD的Partition所使用就是窄依赖，否则的话就是宽依赖。</p>
<p>这种划分有两个用处。首先，窄依赖支持在一个结点上管道化执行。例如基于一对一的关系，可以在 filter 之后执行 map 。其次，窄依赖支持更高效的故障还原。因为对于窄依赖，只有丢失的父 RDD 的分区需要重新计算。而对于宽依赖，一个结点的故障可能导致来自所有父 RDD 的分区丢失，因此就需要完全重新执行。因此对于宽依赖，Spark 会在持有各个父分区的结点上，将中间数据持久化来简化故障还原，就像 MapReduce 会持久化 map 的输出一样。</p>
<p>特别说明：对于join操作有两种情况，如果join操作的使用每个partition仅仅和已知的Partition进行join，此时的join操作就是窄依赖；其他情况的join操作就是宽依赖；因为是确定的Partition数量的依赖关系，所以就是窄依赖，得出一个推论，窄依赖不仅包含一对一的窄依赖，还包含一对固定个数的窄依赖（也就是说对父RDD的依赖的Partition的数量不会随着RDD数据规模的改变而改变）</p>
<h2 id="Stage的划分："><a href="#Stage的划分：" class="headerlink" title="Stage的划分："></a>Stage的划分：</h2><p><img src="https://img-blog.csdn.net/20160622175905874" alt="image"><br> Stage划分的依据就是宽依赖，什么时候产生宽依赖呢？例如reduceByKey，groupByKey等Action。</p>
<ol>
<li>从后往前推理，遇到宽依赖就断开，遇到窄依赖就把当前的RDD加入到Stage中；</li>
<li>每个Stage里面的Task的数量是由该Stage中最后一个RDD的Partition数量决定的；</li>
<li>最后一个Stage里面的任务的类型是ResultTask，前面所有其他Stage里面的任务类型都是ShuffleMapTask；</li>
<li><p>代表当前Stage的算子一定是该Stage的最后一个计算步骤。</p>
<p>补充：Hadoop中的MapReduce操作中的Mapper和Reducer在Spark中基本等量算子是：map、reduceByKey；在一个Stage内部，首先是算子合并，也就是所谓的函数式编程的执行的时候最终进行函数的展开从而把一个Stage内部的多个算子合并成为一个大算子（其内部包含了当前Stage中所有算子对数据的计算逻辑）；其次是由于Transformation操作的Lazy特性！！在具体算子交给集群的Executor计算之前，首先会通过Spark Framework（DAGScheduler）进行算子的优化。</p>
</li>
</ol>
<p><img src="https://img-blog.csdn.net/20160622185706422" alt="image"></p>
]]></content>
      
        <categories>
            
            <category> 大数据 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> RDD </tag>
            
            <tag> Spark </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SparkCore调优]]></title>
      <url>/SparkCore%E8%B0%83%E4%BC%98.html</url>
      <content type="html"><![CDATA[<h2 id="开发角度"><a href="#开发角度" class="headerlink" title="开发角度"></a>开发角度</h2><ol>
<li>原则一：避免创建重复的RDD</li>
<li>原则二：尽可能用同一个RDD</li>
<li>原则三：对多次使用的RDD进行持久化<br>如何选择一种最合适的持久化策略<ul>
<li>MEMORY_ONLY</li>
<li>MEMORY_ONLY_SER</li>
<li>MEMORY_AND_DISK_SER</li>
<li>不考虑：DISK_ONLY和_2后缀<a id="more"></a></li>
</ul>
</li>
<li>原则四：尽量避免使用shuffle类算子<ul>
<li>能不用就不用</li>
<li>能不能用非shuffle类的算子去替代非shuffle类的join -》 map操作替代</li>
</ul>
</li>
<li>原则五：使用map-side预聚合的shuffle操作：groupBykey 和 reduceBykey</li>
<li>原则六：使用高性能的算子：<ul>
<li>使用reduceBykey//aggregateBykey替代groupBykey</li>
<li>使用mapPartitions替代普通map</li>
<li>使用foreachPartitions替代foreach</li>
<li>使用filter之后进行coalesce操作</li>
<li>使用repartitionAndSortWithhinPartitions替代repartition与sort类操作</li>
</ul>
</li>
<li>原则七：广播大变量</li>
<li>原则八：使用Kryo优化序列化性能<ul>
<li>conf.set(“spark.serializer”, “org.apache.spark.serializer.KryoSerializer”)</li>
<li>conf.registerKryoClasses(Array(classOf[MyClass1], classOf[MyClass2]))</li>
</ul>
</li>
<li>优化数据结构</li>
<li>原则十：Data Locality<ul>
<li>PROCESS_LOCAL data is in the same JVM as the running code. This is the best locality possible</li>
<li>NODE_LOCAL data is on the same node. Examples might be in HDFS on the same node, or in another executor on the same node. This is a little slower than PROCESS_LOCAL because the data has to travel between processes</li>
<li>NO_PREF data is accessed equally quickly from anywhere and has no locality preference</li>
<li>RACK_LOCAL data is on the same rack of servers. Data is on a different server on the same rack so needs to be sent over the network, typically through a single switch</li>
<li>ANY data is elsewhere on the network and not in the same rack</li>
<li>默认值-spark.locality.wait-3s</li>
<li>spark.locality.wait.process-建议60s</li>
<li>park.locality.wait.node-建议30s</li>
<li>spark.locality.wait.rack-建议20s</li>
</ul>
</li>
</ol>
<h2 id="数据倾斜（面试的重点）-美团技术博客"><a href="#数据倾斜（面试的重点）-美团技术博客" class="headerlink" title="数据倾斜（面试的重点） 美团技术博客"></a>数据倾斜（面试的重点） <span class="exturl" data-url="aHR0cHM6Ly90ZWNoLm1laXR1YW4uY29tL3NwYXJrLXR1bmluZy1wcm8uaHRtbA==" title="https://tech.meituan.com/spark-tuning-pro.html">美团技术博客<i class="fa fa-external-link"></i></span></h2><h3 id="数据倾斜："><a href="#数据倾斜：" class="headerlink" title="数据倾斜："></a>数据倾斜：</h3><p>数据倾斜发生时的现象：</p>
<ul>
<li>绝大多数task执行的都非常快，但个别task执行极慢</li>
<li>原本能够正常执行的Spark作业，某天突然报出OOM（内存溢出）异常<br>数据倾斜发生的最根本原因<br>如何定位导致数据倾斜的代码：</li>
<li>shuffle（找代码里面发生shuffle的算子）</li>
<li>stage划分 界面观察就可以定位到是哪个算子导致的数据倾斜<br>如何定位到哪个key导致的数据倾斜：</li>
<li>方式一： countBykey 有可能出来结果，但是会遇到数据倾斜</li>
<li>方式二：sample countBykey</li>
</ul>
<h3 id="方案解决："><a href="#方案解决：" class="headerlink" title="方案解决："></a>方案解决：</h3><p>解决方案一：使用Hive ETL预处理数据</p>
<ul>
<li>方案实现思路—-Hive实现预处理</li>
<li>方案实现原理—-数据倾斜的发生提前到了Hive ETL中，避免Spark程序发生数据倾斜而已</li>
<li>方案优点—–实现起来简单便捷，效果还非常好，完全规避掉了数据倾斜，Spark作业的性能会大幅度提升</li>
<li>方案缺点—–治标不治本，Hive ETL中还是会发生数据倾斜</li>
</ul>
<p>解决方案二：过滤少量导致倾斜的key</p>
<ul>
<li>方案实现原理-将导致数据倾斜的key给过滤掉之后，这些key就不会参与计算了，自然不可能产生数据倾斜。</li>
<li>方案优点—-实现简单，而且效果也很好，可以完全规避掉数据倾斜</li>
<li>方案缺点—-key对于我们来说，没有实际意义才行</li>
</ul>
<p>解决方案三：提高shuffle操作的并行度（没多大用）</p>
<ul>
<li>方案优点—-实现起来比较简单，可以有效缓解和减轻数据倾斜的影响</li>
<li>方案缺点—-只是缓解了数据倾斜而已，没有彻底根除问题，根据实践经验来看，其效果有限。</li>
</ul>
<p>解决方案四：两阶段聚合（局部聚合+全局聚合）</p>
<ul>
<li>方案实现原理—-将原本相同的key通过附加随机前缀的方式，变成多个不同的key，就可以让原本被一个task处理的数据分散到多个task上去做局部聚合，进而解决单个task处理数据量过多的问题。接着去除掉随机前缀，再次进行全局聚合，就可以得到最终的结果。</li>
<li>方案优点—-对于聚合类的shuffle操作导致的数据倾斜，效果是非常不错的。通常都可以解决掉数据倾斜，或者至少是大幅度缓解数据倾斜，将Spark作业的性能提升数倍以上。</li>
<li>方案缺点—-仅仅适用于聚合类的shuffle操作—-groupBykey，join类的shuffle操作</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 大数据 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Spark </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hive环境搭建]]></title>
      <url>/Hive%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html</url>
      <content type="html"><![CDATA[<h2 id="Hive安装"><a href="#Hive安装" class="headerlink" title="Hive安装"></a>Hive安装</h2><h3 id="内嵌Dervy版本"><a href="#内嵌Dervy版本" class="headerlink" title="内嵌Dervy版本"></a>内嵌Dervy版本</h3><ol>
<li>上传安装包 apache-hive-2.3.2-bin.tar.gz </li>
<li>解压安装包 tar  -zxvf  apache-hive-2.3.2-bin.tar.gz  -C  /home/hadoop/apps/ </li>
<li>进入到 bin 目录，运行 hive 脚本：[hadoop@hadoop02 bin]$ ./hive<br>注意： 这时候一般会报错：Terminal initialization failed; falling back to unsupported，是因为 hadoop（/root/apps/hadoop-2.6.5/share/hadoop/yarn/lib）集群的 jline-0.9.94.jar 包版本 过低，替换成 hive/lib 中的 jline-2.12.jar 包即可。记住：所有 hdfs 节点都得替换 hadoop-2.6.5/share/hadoop/yarn/lib/jline-0.9.4.jar 替换成 jline-2.12.jar 如果报错就按照此方式解决，没有报错就不用管，在使用新的 hadoop-2.7.5 版本中已经不 存在这个问题。所以不用关注。 <a id="more"></a>
<h3 id="外置-MySQL-版本"><a href="#外置-MySQL-版本" class="headerlink" title="外置 MySQL 版本"></a>外置 MySQL 版本</h3></li>
<li>准备好 MySQL（请参考以下文档，或者自行安装 MySQL，或者一个可用的 MySQL） </li>
<li>上传安装包 apache-hive-2.3.2-bin.tar.gz </li>
<li>解压安装包 tar  -zxvf  apache-hive-2.3.2-bin.tar.gz  -c  ~/apps/ </li>
<li>修改配置文件 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@hadoop02 conf]# touch  hive-site.xml     </span><br><span class="line">[hadoop@hadoop02 conf]# vi  hive-site.xml </span><br><span class="line">`</span><br></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span> </span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span>&gt;</span> </span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionURL<span class="tag">&lt;/<span class="name">name</span>&gt;</span> </span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>jdbc:mysql://localhost:3306/hive_metastore_232?createDatabaseIfNotExist=true<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line">		<span class="tag">&lt;<span class="name">description</span>&gt;</span>JDBC connect string for a JDBC metastore<span class="tag">&lt;/<span class="name">description</span>&gt;</span> </span><br><span class="line">		<span class="comment">&lt;!-- 如果 mysql 和 hive 在同一个服务器节点，那么请更改 hadoop02 为 localhost  --&gt;</span> </span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"> </span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span>&gt;</span> </span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionDriverName<span class="tag">&lt;/<span class="name">name</span>&gt;</span> </span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line">		<span class="tag">&lt;<span class="name">description</span>&gt;</span>Driver class name for a JDBC metastore<span class="tag">&lt;/<span class="name">description</span>&gt;</span> </span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span>&gt;</span> </span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionUserName<span class="tag">&lt;/<span class="name">name</span>&gt;</span> </span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>root<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line">		<span class="tag">&lt;<span class="name">description</span>&gt;</span>username to use against metastore database<span class="tag">&lt;/<span class="name">description</span>&gt;</span> </span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span>&gt;</span> </span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionPassword<span class="tag">&lt;/<span class="name">name</span>&gt;</span> </span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>root<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line">		<span class="tag">&lt;<span class="name">description</span>&gt;</span>password to use against metastore database<span class="tag">&lt;/<span class="name">description</span>&gt;</span> </span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可选配置，该配置信息用来指定 Hive 数据仓库的数据存储在 HDFS 上的目录<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span> </span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.metastore.warehouse.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span> </span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>/user/myhive/warehouse<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line">		<span class="tag">&lt;<span class="name">description</span>&gt;</span>hive default warehouse, if nessecory, change it<span class="tag">&lt;/<span class="name">description</span>&gt;</span> </span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<ol>
<li>一定要记得加入 MySQL 驱动包（mysql-connector-java-5.1.40-bin.jar） 该 jar 包放置在 hive 的根路径下的 lib 目录 </li>
<li>安装完成，配置环境变量 <pre><code> vi ~/.bashrc  添加以下两行内容：
export HIVE_HOME=/home/hadoop/apps/apache-hive-2.3.2-bin 
export PATH=$PATH:$HIVE_HOME/bin 保存退出。 
最后不要忘记：[hadoop@hadoop02 bin]$ source  ~/.bashrc 
</code></pre></li>
<li>验证 Hive 安装，执行命令hive –help</li>
<li><p>初始化元数据库<br>注意：当使用的 hive 是 2.x 之前的版本，不做初始化也是 OK 的，当 hive 第一次启动的 时候会自动进行初始化，只不过会不会生成足够多的元数据库中的表。在使用过程中会 慢慢生成。但最后进行初始化。如果使用的 2.x 版本的 Hive，那么就必须手动初始化元 数据库。使用命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@hadoop02 bin]$ schematool  -dbType  mysql  -initSchema</span><br></pre></td></tr></table></figure>
<ol>
<li>启动 Hive 客户端 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@hadoop02 bin]$ hive --service cli</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>退出 Hive </p>
<h2 id="Linux-RPM-方式安装-MySQL"><a href="#Linux-RPM-方式安装-MySQL" class="headerlink" title="Linux RPM 方式安装 MySQL"></a>Linux RPM 方式安装 MySQL</h2><p><strong>（记得使用 root 账户进行操作，若使用普通用户，那么请修改相应文件夹权限） </strong></p>
</li>
<li><p>检查以前是否装过 MySQL </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa|grep -i mysql</span><br></pre></td></tr></table></figure>
</li>
<li><p>发现有的话就都卸载 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -e --nodeps  ........</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除老版本 mysql 的开发头文件和库 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rm -fr /usr/lib/mysql     </span><br><span class="line"><span class="meta">#</span>数据库目录</span><br><span class="line"> rm -fr /usr/include/mysql       </span><br><span class="line"> rm -f /etc/my.cnf </span><br><span class="line"> rm -fr /var/lib/mysql </span><br><span class="line"> 注意：卸载后/var/lib/mysql 中的数据及/etc/my.cnf 不会删除，确定没用后就手工删除</span><br></pre></td></tr></table></figure>
</li>
<li><p>准备安装包 MySQL-5.6.26-1.linux_glibc2.5.x86_64.rpm-bundle.tar， 上传，解压 命令：tar -zxvf MySQL-5.6.26-1.linux_glibc2.5.x86_64.rpm-bundle.tar </p>
</li>
<li>开始安装 </li>
<li>安装 server  rpm -ivh MySQL-server-5.6.26-1.linux_glibc2.5.x86_64.rpm </li>
<li>安装客户端 rpm -ivh MySQL-client-5.6.26-1.linux_glibc2.5.x86_64.rpm </li>
<li>登陆 MYSQL（登录之前千万记得一定要启动 mysql 服务） 启动命令： [hadoop@hadoop01 ~]$ service mysql start<br>然后登陆，初始密码在 /root/.mysql_secret 这个文件里 </li>
<li>修改密码 set PASSWORD=PASSWORD(‘root’); </li>
<li>退出登陆验证，看是否改密码成功 </li>
<li><p>增加远程登陆权限，执行以下两个命令： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;%&apos; IDENTIFIED BY &apos;root&apos; WITH GRANT OPTION;  </span><br><span class="line">mysql&gt;FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>
<p>命令释义：grant 权限 1,权限 2,„权限 n on 数据库名称.表名称 to 用户名@用户地址 identified by ‘密码’; </p>
</li>
</ol>
<p>PS：1,权限 2,„权限 n 代表 select，insert，update，delete，create，drop，index，alter，grant， references，reload，shutdown，process，file 等 14 个权限。 当权限 1,权限 2,„权限 n 被 all privileges 或者 all 代替，表示赋予用户全部权限。 当数据库名称.表名称被<em>.</em>代替，表示赋予用户操作服务器上所有数据库所有表的权限。 用户地址可以是 localhost，也可以是 ip 地址、机器名字、域名。也可以用’%’地址连接。 </p>
<ol>
<li>至此 mysql 安装成功 </li>
<li>更改数据库的默认编码为 UTF-8 </li>
</ol>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Hive数据存储]]></title>
      <url>/Hive%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8.html</url>
      <content type="html"><![CDATA[<ol>
<li>、Hive 的存储结构包括数据库、表、视图、分区和表数据等。数据库，表，分区等等都对 应 HDFS 上的一个目录。表数据对应 HDFS 对应目录下的文件。 </li>
<li>Hive 中所有的数据都存储在 HDFS 中，没有专门的数据存储格式，因为 Hive 是读模式 （Schema On Read） ，可支持 TextFile，SequenceFile，RCFile 或者自定义格式等 <a id="more"></a></li>
<li>只需要在创建表的时候告诉 Hive 数据中的列分隔符和行分隔符，Hive 就可以解析数据 Hive 的默认列分隔符：控制符 Ctrl + A，\x01 Hive 的默认行分隔符：换行符 \n </li>
<li>、Hive 中包含以下数据模型： <ul>
<li><strong>database</strong>：在 HDFS 中表现为${hive.metastore.warehouse.dir}目录下一个文件夹</li>
<li>table：在 HDFS 中表现所属 database 目录下一个文件夹 </li>
<li><strong>external table</strong>：与 table 类似，不过其数据存放位置可以指定任意 HDFS 目录路径 </li>
<li>partition：在 HDFS 中表现为 table 目录下的子目录 </li>
<li>bucket：在 HDFS 中表现为同一个表目录或者分区目录下根据某个字段的值进行 hash 散 列之后的多个文件</li>
<li>view：与传统数据库类似，只读，基于基本表创建 </li>
</ul>
</li>
<li>Hive 的元数据存储在 RDBMS 中，除元数据外的其它所有数据都基于 HDFS 存储。默认情 况下，Hive 元数据保存在内嵌的 Derby 数据库中，只能允许一个会话连接，只适合简单的 测试。实际生产环境中不适用，为了支持多用户会话，则需要一个独立的元数据库，使用 MySQL 作为元数据库，Hive 内部对 MySQL 提供了很好的支持</li>
<li>Hive 中的表分为 <strong>内部表</strong>、 <strong>外部表</strong>、 <strong>分区表</strong>  和   <strong>Bucket表</strong><h3 id="内部表和外部表的区别："><a href="#内部表和外部表的区别：" class="headerlink" title="内部表和外部表的区别："></a>内部表和外部表的区别：</h3>删除内部表，删除表元数据和数据  删除外部表，删除元数据，不删除数据 <h3 id="内部表和外部表的使用选择："><a href="#内部表和外部表的使用选择：" class="headerlink" title="内部表和外部表的使用选择："></a>内部表和外部表的使用选择：</h3>大多数情况，他们的区别不明显，如果数据的所有处理都在 Hive 中进行，那么倾向于 选择内部表，但是如果 Hive 和其他工具要针对相同的数据集进行处理，外部表更合适。<br>使用外部表访问存储在 HDFS 上的初始数据，然后通过 Hive 转换数据并存到内部表中<br>使用外部表的场景是针对一个数据集有多个不同的 Schema<br>通过外部表和内部表的区别和使用选择的对比可以看出来，hive 其实仅仅只是对存储在 HDFS 上的数据提供了一种新的抽象。而不是管理存储在 HDFS 上的数据。所以不管创建内部 表还是外部表，都可以对 hive 表的数据存储目录中的数据进行增删操作。 <h3 id="分区表和分桶表的区别："><a href="#分区表和分桶表的区别：" class="headerlink" title="分区表和分桶表的区别："></a>分区表和分桶表的区别：</h3>Hive 数据表可以根据某些字段进行分区操作，细化数据管理，可以让部分查询更快。同 时表和分区也可以进一步被划分为 Buckets，分桶表的原理和 MapReduce 编程中的 HashPartitioner 的原理类似<br>分区和分桶都是细化数据管理，但是分区表是手动添加区分，由于 Hive 是读模式，所 以对添加进分区的数据不做模式校验，分桶表中的数据是按照某些分桶字段进行 hash 散列 形成的多个文件，所以数据的准确性也高很多 </li>
</ol>
]]></content>
      
        <categories>
            
            <category> 大数据 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hive </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hive架构]]></title>
      <url>/Hive%E6%9E%B6%E6%9E%84.html</url>
      <content type="html"><![CDATA[<p><img src="http://ou3xxg3hg.bkt.clouddn.com/HIve%E6%9E%B6%E6%9E%84.png" alt=""><br><a id="more"></a></p>
<h2 id="基本组成"><a href="#基本组成" class="headerlink" title="基本组成"></a>基本组成</h2><h3 id="用户接口"><a href="#用户接口" class="headerlink" title="用户接口"></a>用户接口</h3><ul>
<li>CLI，Shell 终端命令行（Command Line Interface），采用交互形式使用 Hive 命令行与 Hive 进行交互，最常用（学习，调试，生产）  </li>
<li>JDBC/ODBC，是 Hive 的基于 JDBC 操作提供的客户端，用户（开发员，运维人员）通过 这连接至 Hive server 服务  </li>
<li>Web UI，通过浏览器访问 Hive <h3 id="Thrift-Server"><a href="#Thrift-Server" class="headerlink" title="Thrift Server"></a>Thrift Server</h3>Thrift 是 Facebook 开发的一个软件框架，可以用来进行可扩展且跨语言的服务的开发， Hive 集成了该服务，能让不同的编程语言调用 Hive 的接口 <h3 id="元数据存储"><a href="#元数据存储" class="headerlink" title="元数据存储"></a>元数据存储</h3></li>
<li><strong>元数据</strong>，通俗的讲，就是存储在 Hive 中的数据的描述信息。 </li>
<li>Hive 中的元数据通常包括：表的名字，表的列和分区及其属性，表的属性（内部表和 外部表），表的数据所在目录  </li>
<li>Metastore 默认存在自带的 Derby 数据库中。缺点就是不适合多用户操作，并且数据存 储目录不固定。数据库跟着 Hive 走，极度不方便管理  </li>
<li>解决方案：通常存我们自己创建的 MySQL 库（本地 或 远程）  </li>
<li>Hive 和 MySQL 之间通过 MetaStore 服务交互 <h3 id="Driver：编译器（Compiler），优化器（Optimizer），执行器（Executor）"><a href="#Driver：编译器（Compiler），优化器（Optimizer），执行器（Executor）" class="headerlink" title="Driver：编译器（Compiler），优化器（Optimizer），执行器（Executor）"></a>Driver：编译器（Compiler），优化器（Optimizer），执行器（Executor）</h3></li>
<li>Driver 组件完成 HQL 查询语句从词法分析，语法分析，编译，优化，以及生成逻辑执行 计划的生成。生成的逻辑执行计划存储在 HDFS 中，并随后由 MapReduce 调用执行 </li>
<li>Hive 的核心是驱动引擎， 驱动引擎由四部分组成： <pre><code>(1) 解释器：解释器的作用是将 HiveSQL 语句转换为抽象语法树（AST）
(2) 编译器：编译器是将语法树编译为逻辑执行计划
(3) 优化器：优化器是对逻辑执行计划进行优化
(4) 执行器：执行器是调用底层的运行框架执行逻辑执行计划     
</code></pre><h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3>HiveQL 通过命令行或者客户端提交，经过 Compiler 编译器，运用 MetaStore 中的元数 据进行类型检测和语法分析，生成一个逻辑方案(Logical Plan)，然后通过的优化处理，产生 一个 MapReduce 任务。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 大数据 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hive </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hive基本概念]]></title>
      <url>/Hive%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.html</url>
      <content type="html"><![CDATA[<h2 id="Hive的基本概念"><a href="#Hive的基本概念" class="headerlink" title="Hive的基本概念"></a>Hive的基本概念</h2><ol>
<li>开发者: Facebook实现并开源</li>
<li>作用: 基于Hadoop的一个数据仓库工具，可以将结构化的数据映射为一张数据库表，并提供HQL(Hive SQL)查询功能，底层数据是存储在HDFS上。</li>
<li>本质: 将SQL语句转换为MapReduce任务运行，使不熟悉Mapreduce的用户很方便地利用HQL处理和计算HDFS上的结构化的数据，使用于离线的批量数据计算。<a id="more"></a>
<strong>Hive 依赖于 HDFS 存储数据，Hive 将 HQL 转换成 MapReduce 执行 所以说 Hive 是基于 Hadoop 的一个数据仓库工具，实质就是一款基于 HDFS 的 MapReduce 计算框架，对存储在 HDFS 中的数据进行分析和管理 </strong><h2 id="hbase-和-hive-的区别"><a href="#hbase-和-hive-的区别" class="headerlink" title="hbase 和 hive 的区别"></a>hbase 和 hive 的区别</h2> hbase：  数据库<br> hive : 数据仓库<br> 区别：<pre><code>1、数据库，对于数据会做精细化的管理，具有事务的概念
   数据仓库，存储数据的格式就类似打包，没有事务的概念
2、操作方式的区别：
   数据库：NoSQL语法  put get scan delele
   数据仓库: SQL方言 Hive的SQL ===  HQL     hibernate:HQL
3、用途的区别：
   数据库：OLTP  联机事务处理   增删改
   数据仓库： OLAP   联机分析处理   查询
   hive是数据仓库，它根本就不支持 update和delete   但是支持insert
4、模式上的区别
    数据库： 写模式    hbase无严格模式 ： 仅有的模式校验只有 表名和列簇的名称
    数据仓库：  读模式
</code></pre><h2 id="Hive的特点"><a href="#Hive的特点" class="headerlink" title="Hive的特点"></a>Hive的特点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3></li>
<li>可扩展性,横向扩展，Hive 可以自由的扩展集群的规模，一般情况下不需要重启服务 横向扩展：通过分担压力的方式扩展集群的规模 纵向扩展： 一台服务器cpu i7-6700k 4核心8线程， 8核心16线程，内存64G =&gt; 128G  </li>
<li>延展性，Hive 支持自定义函数，用户可以根据自己的需求来实现自己的函数 </li>
<li>良好的容错性，可以保障即使有节点出现问题，SQL 语句仍可完成执行     <h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3></li>
<li>Hive 不支持记录级别的增删改操作，但是用户可以通过查询生成新表或者将查询结 果导入到文件中（当前选择的 hive-2.3.2 的版本支持记录级别的插入操作）</li>
<li>Hive 的查询延时很严重，因为 MapReduce Job 的启动过程消耗很长时间，所以不能 用在交互查询系统中。 </li>
<li>Hive 不支持事务（因为不没有增删改，所以主要用来做 OLAP（联机分析处理），而 不是 OLTP（联机事务处理），这就是数据处理的两大级别）</li>
</ol>
<h3 id="Hive-只适合用来做海量离线数-据统计分析，也就是数据仓库"><a href="#Hive-只适合用来做海量离线数-据统计分析，也就是数据仓库" class="headerlink" title="Hive 只适合用来做海量离线数 据统计分析，也就是数据仓库"></a>Hive 只适合用来做海量离线数 据统计分析，也就是数据仓库</h3>]]></content>
      
        <categories>
            
            <category> 大数据 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hive </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hbase底层原理]]></title>
      <url>/hbase%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86.html</url>
      <content type="html"><![CDATA[<h2 id="1、系统架构"><a href="#1、系统架构" class="headerlink" title="1、系统架构"></a>1、系统架构</h2><p><img src="http://ou3xxg3hg.bkt.clouddn.com/hbase%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="image"></p>
<h3 id="client职责"><a href="#client职责" class="headerlink" title="client职责"></a>client职责</h3><ol>
<li>HBase有两张特殊表<br> .METE.：记录了用户所有表拆分出来的Region映射信息，.META.可以有多个Region<br> -ROOT-:记录了.METE.表的Region信息，-ROOT-只有一个Region，无论如何不会分裂</li>
<li>Client访问用户数据过程：<br> 1、首先访问zookeeper，找到-root-表的region所在的位置<br> 2、然后访问-ROOT-表，接着访问.META.表<br> 3、最后才能找到用户数据的位置去访问<br>中间需要多次网络操作，不过Client端会做cache缓存<a id="more"></a>
<h3 id="ZooKeeper职责"><a href="#ZooKeeper职责" class="headerlink" title="ZooKeeper职责"></a>ZooKeeper职责</h3></li>
<li>ZooKeeper 为 HBase 提供 Failover 机制，选举 Master，避免单点 Master 单点故障问题 </li>
<li>存储所有 Region 的寻址入口，即-ROOT-表的位置信息 （在哪台服务器上）</li>
<li>实时监控 RegionServer 的状态，将 RegionServer 的上线和下线信息实时通知给 Master </li>
<li>存储 HBase 的 Schema，包括有哪些 Table，每个 Table 有哪些 Column Family </li>
</ol>
<h3 id="Master职责"><a href="#Master职责" class="headerlink" title="Master职责"></a>Master职责</h3><ol>
<li>为RegionServer分配Region</li>
<li>负责RegionServer的负载均衡</li>
<li>发现失效的 RegionServer 并重新分配其上的 Region </li>
<li>HDFS 上的垃圾文件（HBase）回收 </li>
<li>处理 Schema 更新请求（表的创建，删除，修改，列簇的增加等等） </li>
</ol>
<h3 id="RegionServer职责"><a href="#RegionServer职责" class="headerlink" title="RegionServer职责"></a>RegionServer职责</h3><ol>
<li>RegionServer 维护 Master 分配给它的 Region，处理对这些 Region 的 IO 请求 </li>
<li>RegionServer 负责 Split 在运行过程中变得过大的 Region，负责 Compact 操作 （溢出到磁盘的文件有可能会有很多，会进行合并，把rowkey相同的所有keyvalue对象收集到一起，进行合并）</li>
</ol>
<p>注意：1、可以看到，client 访问 HBase 上数据的过程并不需要 master 参与（寻址访问 zookeeper 和RegioneServer，数据读写访问 RegioneServer）， Master 仅仅维护者 Table 和 Region 的元数据Stay hungry Stay foolish – <span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhvbmdxaTI1MTM=" title="http://blog.csdn.net/zhongqi2513">http://blog.csdn.net/zhongqi2513<i class="fa fa-external-link"></i></span> 信息，负载很低。 2、.META. 存的是所有的 Region 的位置信息，那么 RegioneServer 当中 Region 在进行分裂之后 的新产生的 Region，是由 Master 来决定发到哪个 RegioneServer，这就意味着，只有 Master 知道 new Region 的位置信息，所以，由 Master 来管理.META.这个表当中的数据的 CRUD所以结合以上两点表明，在没有 Region 分裂的情况，Master 宕机一段时间是可以忍受的</p>
<h2 id="2、物理存储"><a href="#2、物理存储" class="headerlink" title="2、物理存储"></a>2、物理存储</h2><h3 id="整体物理结构"><a href="#整体物理结构" class="headerlink" title="整体物理结构"></a>整体物理结构</h3><p><img src="http://ou3xxg3hg.bkt.clouddn.com/HBase%E6%95%B4%E4%BD%93%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84.png" alt="image"></p>
<ol>
<li>Table 中的所有行都按照 RowKsey 的字典序排列。 </li>
<li>Table 在行的方向上分割为多个 HRegion。   </li>
<li>HRegion 按大小分割的(默认 10G)，每个表一开始只有一个 HRegion，随着数据不断插入 表，HRegion 不断增大，当增大到一个阀值的时候，HRegion 就会等分会两个新的 HRegion。 当表中的行不断增多，就会有越来越多的 HRegion。  </li>
<li>HRegion 是 Hbase 中分布式存储和负载均衡的最小单元。最小单元就表示不同的 HRegion 可以分布在不同的 HRegionserver 上。但一个 HRegion 是不会拆分到多个 server 上的。   </li>
<li>HRegion 虽然是负载均衡的最小单元，但并不是物理存储的最小单元。事实上，HRegion 由一个或者多个 Store 组成，每个 Store 保存一个 Column Family。每个 Strore 又由一个 memStore 和 0 至多个 StoreFile 组成 </li>
</ol>
<h3 id="StoreFile和HFile结构"><a href="#StoreFile和HFile结构" class="headerlink" title="StoreFile和HFile结构"></a>StoreFile和HFile结构</h3><p><img src="http://ou3xxg3hg.bkt.clouddn.com/StoreFile%E5%92%8CHFile%E7%BB%93%E6%9E%84.png" alt="image"><br><img src="http://ou3xxg3hg.bkt.clouddn.com/HFile.png" alt="image"><br><img src="http://ou3xxg3hg.bkt.clouddn.com/HFile2.png" alt="image"></p>
<h3 id="MemStore和StoreFile"><a href="#MemStore和StoreFile" class="headerlink" title="MemStore和StoreFile"></a>MemStore和StoreFile</h3><ol>
<li>一个 Hregion 由多个 Store 组成，每个 Store 包含一个列族的所有数据 </li>
<li>Store 包括位于内存的一个 memstore 和位于硬盘的多个 storefile 组成 </li>
<li>写操作先写入 memstore，当 memstore 中的数据量达到某个阈值，HRegionServer 启动 flushcache 进程写入 storefile，每次写入形成单独一个 Hfile </li>
<li>当总 storefile 大小超过一定阈值后，会把当前的 region 分割成两个，并由 HMaster 分配给相 应的 region 服务器，实现负载均衡 </li>
<li>客户端检索数据时，先在 memstore 找，找不到再找 storefile </li>
</ol>
<h3 id="HLog-WAL"><a href="#HLog-WAL" class="headerlink" title="HLog(WAL)"></a>HLog(WAL)</h3><ol>
<li>WAL 意为 Write ahead log(<span class="exturl" data-url="aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Xcml0ZS1haGVhZF9sb2dnaW5nKe+8jOexu+S8vA==" title="http://en.wikipedia.org/wiki/Write-ahead_logging)，类似">http://en.wikipedia.org/wiki/Write-ahead_logging)，类似<i class="fa fa-external-link"></i></span> mysql 中的 binlog，用来做灾难恢复之用，Hlog 记录数据的所有变更，一旦数据修改，就可以从 log 中 进行恢复。 </li>
<li>每个 Region Server 维护一个 Hlog,而不是每个 Region 一个。这样不同 region(来自不同 table) 的日志会混在一起，这样做的目的是不断追加单个文件相对于同时写多个文件而言，可以减 少磁盘寻址次数，因此可以提高对 table 的写性能。带来的麻烦是，如果一台 region server 下线，为了恢复其上的 region，需要将 region server 上的 log 进行拆分，然后分发到其它 region server 上进行恢复。 </li>
<li>HLog 文件就是一个普通的 Hadoop Sequence File： 1、HLog Sequence File 的 Key 是 HLogKey 对象，HLogKey 中记录了写入数据的归属信息，除 了 table 和 region 名字外，同时还包括 sequence number 和 timestamp，timestamp 是”写入 时间”，sequence number 的起始值为 0，或者是最近一次存入文件系统中 sequence number。 </li>
<li>HLog Sequece File 的 Value 是 HBase 的 KeyValue 对象，即对应 HFile 中的 KeyValue </li>
</ol>
<h2 id="3、寻址机制"><a href="#3、寻址机制" class="headerlink" title="3、寻址机制"></a>3、寻址机制</h2><p>既然读写都在 RegionServer 上发生，我们前面有讲到，每个 RegionSever 为一定数量的 Region 服务，那么 Client 要对某一行数据做读写的时候如何能知道具体要去访问哪个 RegionServer 呢？那就是接下来我们要讨论的问题 </p>
<h3 id="老的Region寻址方式"><a href="#老的Region寻址方式" class="headerlink" title="老的Region寻址方式"></a>老的Region寻址方式</h3><p>在 HBase-0.96 版本以前，HBase有两个特殊的表，分别是-ROOT-表和.META.表，其中-ROOT的位置存储在 ZooKeeper 中， -ROOT-本身存储了.META. Table 的 RegionInfo 信息，并且-ROOT不会分裂，只有一个 Region。而 .META.表可以被切分成多个 Region。读取的流程如下图所示：<br><img src="http://ou3xxg3hg.bkt.clouddn.com/%E8%80%81%E7%9A%84Region%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F.png" alt="image"><br>详细步骤： </p>
<pre><code>第 1 步：Client 请求 ZooKeeper 获得-ROOT-所在的 RegionServer 地址 
第 2 步：Client 请求-ROOT-所在的 RS 地址，获取.META.表的地址，Client 会将-ROOT-的相关 信息 cache 下来，以便下一次快速访问 
第 3 步：Client 请求.META.表的 RegionServer 地址，获取访问数据所在 RegionServer 的地址， Client 会将.META.的相关信息 cache 下来，以便下一次快速访问 
第 4 步：Client 请求访问数据所在 RegionServer 的地址，获取对应的数据 
</code></pre><p>从上面的路径我们可以看出，用户需要 3 次请求才能直到用户 Table 真正的位置，这在一定 程序带来了性能的下降。在 0.96 之前使用 3 层设计的主要原因是考虑到元数据可能需要很 大。但是真正集群运行，元数据的大小其实很容易计算出来。在 BigTable 的论文中，每行 METADATA 数据存储大小为 1KB 左右，如果按照一个 Region 为 128M 的计算，3 层设计可以<br>支持的 Region 个数为 2^34 个，采用 2 层设计可以支持 2^17（131072）。那么 2 层设计的情 况下一个集群可以存储 4P 的数据。这仅仅是一个 Region 只有 128M 的情况下。如果是 10G 呢? 因此，通过计算，其实 2 层设计就可以满足集群的需求。因此在 0.96 版本以后就去掉 了-ROOT-表了。</p>
<p><img src="http://ou3xxg3hg.bkt.clouddn.com/%E6%96%B0%E7%9A%84%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F.png" alt="image"></p>
<h2 id="4、读写过程"><a href="#4、读写过程" class="headerlink" title="4、读写过程"></a>4、读写过程</h2><h3 id="读请求过程"><a href="#读请求过程" class="headerlink" title="读请求过程"></a>读请求过程</h3><p>1、客户端通过 ZooKeeper 以及-ROOT-表和.META.表找到目标数据所在的 RegionServer(就是 数据所在的 Region 的主机地址) 2、联系 RegionServer 查询目标数据 3、RegionServer 定位到目标数据所在的 Region，发出查询请求 4、Region 先在 Memstore 中查找，命中则返回 5、如果在 Memstore 中找不到，则在 Storefile 中扫描    为了能快速的判断要查询的数据在不在这个 StoreFile 中，应用了 BloomFilter </p>
<p>（BloomFilter，布隆过滤器：迅速判断一个元素是不是在一个庞大的集合内，但是他有一个 弱点：它有一定的误判率） （误判率：原本不存在与该集合的元素，布隆过滤器有可能会判断说它存在，但是，如果 布隆过滤器，判断说某一个元素不存在该集合，那么该元素就一定不在该集合内） </p>
<h3 id="写请求过程"><a href="#写请求过程" class="headerlink" title="写请求过程"></a>写请求过程</h3><ol>
<li>Client 先根据 RowKey 找到对应的 Region 所在的 RegionServer </li>
<li>Client 向 RegionServer 提交写请求 </li>
<li>RegionServer 找到目标 Region </li>
<li>Region 检查数据是否与 Schema 一致 </li>
<li>如果客户端没有指定版本，则获取当前系统时间作为数据版本 </li>
<li>将更新写入 WAL Log </li>
<li>将更新写入 Memstore </li>
<li>判断 Memstore 的是否需要 flush 为 StoreFile 文件。 </li>
</ol>
<p>Hbase 在做数据插入操作时，首先要找到 RowKey 所对应的的 Region，怎么找到的？其实这 个简单，因为.META.表存储了每张表每个 Region 的起始 RowKey 了。 </p>
<p>建议：在做海量数据的插入操作，避免出现递增 rowkey 的 put 操作 如果 put 操作的所有 RowKey 都是递增的，那么试想，当插入一部分数据的时候刚好进行分 裂，那么之后的所有数据都开始往分裂后的第二个 Region 插入，就造成了数据热点现象。 </p>
<p>细节描述： HBase 使用 MemStore 和 StoreFile 存储对表的更新。 </p>
<p>数据在更新时首先写入 HLog(WAL Log)，再写入内存(MemStore)中，MemStore 中的数据是排 序的，当 MemStore 累计到一定阈值时，就会创建一个新的 MemStore，并且将老的 MemStore 添加到 flush 队列，由单独的线程 flush 到磁盘上，成为一个 StoreFile。于此同时，系统会在 ZooKeeper 中记录一个 redo point，表示这个时刻之前的变更已经持久化了。当系统出现意</p>
<p>Stay hungry Stay foolish – <span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhvbmdxaTI1MTM=" title="http://blog.csdn.net/zhongqi2513">http://blog.csdn.net/zhongqi2513<i class="fa fa-external-link"></i></span><br>外时，可能导致内存(MemStore)中的数据丢失，此时使用 HLog(WAL Log)来恢复 checkpoint 之后的数据。 </p>
<p>StoreFile 是只读的，一旦创建后就不可以再修改。因此 HBase 的更新/修改其实是不断追加 的操作。当一个 Store 中的 StoreFile 达到一定的阈值后，就会进行一次合并(minor_compact, major_compact)，将对同一个 key 的修改合并到一起，形成一个大的 StoreFile，当 StoreFile 的大小达到一定阈值后，又会对 StoreFile 进行 split，等分为两个 StoreFile。由于对表的更 新是不断追加的，compact 时，需要访问 Store 中全部的 StoreFile 和 MemStore，将他们按 rowkey 进行合并，由于 StoreFile 和 MemStore 都是经过排序的，并且 StoreFile 带有内存中 索引，合并的过程还是比较快。 </p>
<p>major_compact 和 minor_compact 的区别： minor_compact 仅仅合并小文件（HFile） major_compact 合并一个 region 内的所有文件 </p>
<p>Client 写入 -&gt; 存入 MemStore，一直到 MemStore 满 -&gt; Flush 成一个 StoreFile，直至增长到 一定阈值 -&gt; 触发 Compact 合并操作 -&gt; 多个 StoreFile 合并成一个 StoreFile，同时进行版本 合并和数据删除 -&gt; 当StoreFiles Compact后，逐步形成越来越大的StoreFile -&gt; 单个StoreFile 大小超过一定阈值后，触发 Split 操作，把当前 Region Split 成 2 个 Region，Region 会下线， 新 Split 出的 2 个孩子 Region 会被 HMaster 分配到相应的 HRegionServer 上，使得原先 1 个 Region 的压力得以分流到 2 个 Region 上由此过程可知，HBase 只是增加数据，有所得更新 和删除操作，都是在 Compact 阶段做的，所以，用户写操作只需要进入到内存即可立即返 回，从而保证 I/O 高性能。 </p>
<p>写入数据的过程补充： 工作机制：每个 HRegionServer 中都会有一个 HLog 对象，HLog 是一个实现 Write Ahead Log 的类，每次用户操作写入 Memstore 的同时，也会写一份数据到 HLog 文件，HLog 文件定期 会滚动出新，并删除旧的文件(已持久化到 StoreFile 中的数据)。当 HRegionServer 意外终止 后，HMaster 会通过 ZooKeeper 感知，HMaster 首先处理遗留的 HLog 文件，将不同 Region 的log数据拆分，分别放到相应Region目录下，然后再将失效的Region（带有刚刚拆分的log） 重新分配，领取到这些 Region 的 HRegionServer 在 load Region 的过程中，会发现有历史 HLog 需要处理，因此会 Replay HLog 中的数据到 MemStore 中，然后 flush 到 StoreFiles，完成数据 恢复。 </p>
<h2 id="5、RegionServer工作机制"><a href="#5、RegionServer工作机制" class="headerlink" title="5、RegionServer工作机制"></a>5、RegionServer工作机制</h2><ol>
<li>Region 分配 任何时刻，一个 Region 只能分配给一个 RegionServer。master 记录了当前有哪些可用的 RegionServer。以及当前哪些 Region 分配给了哪些 RegionServer，哪些 Region 还没有分配。 当需要分配的新的 Region，并且有一个 RegionServer 上有可用空间时，Master 就给这个 RegionServer 发送一个装载请求，把 Region 分配给这个 RegionServer。RegionServer 得到请 求后，就开始对此 Region 提供服务。   </li>
<li>RegionServer 上线Master 使用 zookeeper 来跟踪 RegionServer 状态。当某个 RegionServer 启动时，会首先在 ZooKeeper 上的 server 目录下建立代表自己的 znode。由于 Master 订阅了 server 目录上的变 更消息，当 server 目录下的文件出现新增或删除操作时，Master 可以得到来自 ZooKeeper 的实时通知。因此一旦 RegionServer 上线，Master 能马上得到消息。   </li>
<li>RegionServer 下线 当 RegionServer 下线时，它和 zookeeper 的会话断开，ZooKeeper 而自动释放代表这台 server 的文件上的独占锁。Master 就可以确定：<br> 1、RegionServer 和 ZooKeeper 之间的网络断开了。<br> 2、RegionServer 挂了。 无论哪种情况，         RegionServer都无法继续为它的Region提供服务了，此时Master会删除server 目录下代表这台 RegionServer 的 znode 数据，并将这台 RegionServer 的 Region 分配给其它还 活着的同志。 </li>
</ol>
<h2 id="6、Master工作机制"><a href="#6、Master工作机制" class="headerlink" title="6、Master工作机制"></a>6、Master工作机制</h2><p>Master 上线 Master 启动进行以下步骤: </p>
<ol>
<li>从ZooKeeper上获取唯一一个代表Active Master的锁，用来阻止其它Master成为Master。</li>
<li>扫描 ZooKeeper 上的 server 父节点，获得当前可用的 RegionServer 列表。 </li>
<li>和每个 RegionServer 通信，获得当前已分配的 Region 和 RegionServer 的对应关系。</li>
<li>扫描.META. Region 的集合，计算得到当前还未分配的 Region，将他们放入待分配 Region 列表。 ### Master 下线 </li>
<li>由于 Master 只维护表和 Region 的元数据，而不参与表数据 IO 的过程，Master 下线仅 导致所有元数据的修改被冻结(无法创建删除表，无法修改表的 schema，无法进行 Region 的负载均衡，无法处理 Region 上下线，无法进行 Region 的合并，唯一例外的是 Region 的 split 可以正常进行，因为只有 RegionServer 参与)，表的数据读写还可以正常进行。因此 Master 下线短时间内对整个 hbase 集群没有影响。 </li>
<li>从上线过程可以看到，Master 保存的信息全是可以冗余信息（都可以从系统其它地方 收集到或者计算出来） </li>
<li>因此，一般 HBase 集群中总是有一个 Master 在提供服务，还有一个以上的 Master 在等 待时机抢占它的位置。 </li>
</ol>
]]></content>
      
        <categories>
            
            <category> 大数据 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hbase </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[wordcount求共同好友代码实现]]></title>
      <url>/wordcount%E6%B1%82%E5%85%B1%E5%90%8C%E5%A5%BD%E5%8F%8B%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0.html</url>
      <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.Practice.SameFriend;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.FileSystem;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.LongWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Job;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Mapper;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Reducer;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br></pre></td><td class="code"><pre><span class="line">import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class="line">import org.apache.hadoop.mapreduce.lib.jobcontrol.ControlledJob;</span><br><span class="line">import org.apache.hadoop.mapreduce.lib.jobcontrol.JobControl;</span><br><span class="line">import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 求共同好友合并版</span><br><span class="line"> * 主要思路： 第一步：求出每一个好友所对应的所有用户</span><br><span class="line"> *           第二步：将第一步中所有用户进行排序，两两组合，最后求出两用户间的共同好友</span><br><span class="line"> */</span><br><span class="line">public class SameFriendMerge1 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException, InterruptedException &#123;</span><br><span class="line">        Configuration conf = new Configuration();</span><br><span class="line">        FileSystem fs = FileSystem.get(conf);</span><br><span class="line"></span><br><span class="line">        //第一个job信息</span><br><span class="line">        Job job = Job.getInstance(conf);</span><br><span class="line">        job.setJar(&quot;wordcountJar/wordcount.jar&quot;);</span><br><span class="line"></span><br><span class="line">        job.setMapperClass(SFMerge1Mapper1.class);</span><br><span class="line">        job.setReducerClass(SFMerge1Reducer1.class);</span><br><span class="line"></span><br><span class="line">        job.setOutputKeyClass(Text.class);</span><br><span class="line">        job.setOutputValueClass(Text.class);</span><br><span class="line"></span><br><span class="line">        Path inputPath = new Path(&quot;input/sameFriend&quot;);</span><br><span class="line">        Path outputPath = new Path(&quot;output/sameFriend&quot;);</span><br><span class="line"></span><br><span class="line">        if(fs.isDirectory(outputPath))&#123;</span><br><span class="line">            fs.delete(outputPath,true);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        FileInputFormat.setInputPaths(job,inputPath);</span><br><span class="line">        FileOutputFormat.setOutputPath(job,outputPath);</span><br><span class="line"></span><br><span class="line">        //第二个job信息</span><br><span class="line">       Job job1 = Job.getInstance(conf);</span><br><span class="line">       job1.setJar(&quot;wordcountJar/wordcount.jar&quot;);</span><br><span class="line"></span><br><span class="line">       job1.setMapperClass(SFMerge1Mapper2.class);</span><br><span class="line">       job1.setReducerClass(SFMerge1Reducer2.class);</span><br><span class="line"></span><br><span class="line">       job1.setOutputKeyClass(Text.class);</span><br><span class="line">       job1.setOutputValueClass(Text.class);</span><br><span class="line"></span><br><span class="line">       Path inputPath1 = new Path(&quot;output/sameFriend&quot;);</span><br><span class="line">       Path outputPath1 = new Path(&quot;output/sameFriend1&quot;);</span><br><span class="line"></span><br><span class="line">       if(fs.isDirectory(outputPath1))&#123;</span><br><span class="line">           fs.delete(outputPath1,true);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       FileInputFormat.setInputPaths(job1,inputPath1);</span><br><span class="line">       FileOutputFormat.setOutputPath(job1,outputPath1);</span><br><span class="line"></span><br><span class="line">        ControlledJob ctlJob1 = new ControlledJob(job.getConfiguration());</span><br><span class="line">        ControlledJob ctlJob2 = new ControlledJob(job.getConfiguration());</span><br><span class="line"></span><br><span class="line">        ctlJob1.setJob(job);</span><br><span class="line">        ctlJob2.setJob(job1);</span><br><span class="line"></span><br><span class="line">        ctlJob2.addDependingJob(ctlJob1);</span><br><span class="line"></span><br><span class="line">        JobControl jobControl = new JobControl(&quot;SameFriends&quot;);</span><br><span class="line">        jobControl.addJob(ctlJob1);</span><br><span class="line">        jobControl.addJob(ctlJob2);</span><br><span class="line"></span><br><span class="line">        Thread jobThread = new Thread(jobControl);</span><br><span class="line">        jobThread.start();</span><br><span class="line"></span><br><span class="line">        // 每隔一段时间来判断一下该jc线程的任务是否执行完成</span><br><span class="line">        while (!jobControl.allFinished())&#123;</span><br><span class="line">            Thread.sleep(500);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        jobControl.stop();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class SFMerge1Mapper1 extends Mapper&lt;LongWritable,Text,Text,Text&gt;&#123;</span><br><span class="line">        private Text outKey = new Text();</span><br><span class="line">        private Text outValue = new Text();</span><br><span class="line">        @Override</span><br><span class="line">        protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException &#123;</span><br><span class="line">            String[] split = value.toString().split(&quot;:&quot;);</span><br><span class="line">            outValue.set(split[0]);</span><br><span class="line">            String[] friends = split[1].split(&quot;,&quot;);</span><br><span class="line">            for (String str :</span><br><span class="line">                    friends) &#123;</span><br><span class="line">                outKey.set(str);</span><br><span class="line">                context.write(outKey,outValue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 第一次reducer输出结果：</span><br><span class="line">         A	F,I,O,K,G,D,C,H,B</span><br><span class="line">         B	E,J,F,A</span><br><span class="line">         C	B,E,K,A,H,G,F</span><br><span class="line">         D	H,C,G,F,E,A,K,L</span><br><span class="line">         E	A,B,L,G,M,F,D,H</span><br><span class="line">         F	C,M,L,A,D,G</span><br><span class="line">         G	M</span><br><span class="line">         H	O</span><br><span class="line">         I	O,C</span><br><span class="line">         J	O</span><br><span class="line">         K	O,B</span><br><span class="line">         L	D,E</span><br><span class="line">         M	E,F</span><br><span class="line">         O	A,H,I,J,F</span><br><span class="line">     */</span><br><span class="line">    public static class SFMerge1Reducer1 extends Reducer&lt;Text,Text,Text,Text&gt;&#123;</span><br><span class="line">        private Text outValue = new Text();</span><br><span class="line">        @Override</span><br><span class="line">        protected void reduce(Text key, Iterable&lt;Text&gt; values, Context context) throws IOException, InterruptedException &#123;</span><br><span class="line">            StringBuilder sb = new StringBuilder();</span><br><span class="line">            for (Text str :</span><br><span class="line">                    values) &#123;</span><br><span class="line">                if( sb.length()!= 0 )&#123;</span><br><span class="line">                    sb.append(&quot;,&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                sb.append(str);</span><br><span class="line">            &#125;</span><br><span class="line">            outValue.set(sb.toString());</span><br><span class="line">            context.write(key,outValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class SFMerge1Mapper2 extends Mapper&lt;LongWritable,Text,Text,Text&gt;&#123;</span><br><span class="line">        private Text outValue = new Text();</span><br><span class="line">        private Text outKey = new Text();</span><br><span class="line">        @Override</span><br><span class="line">        protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException &#123;</span><br><span class="line">            String[] splits = value.toString().split(&quot;\t&quot;);</span><br><span class="line">            String[] strings = splits[1].split(&quot;,&quot;);</span><br><span class="line">            outValue.set(splits[0]);</span><br><span class="line">            Arrays.sort(strings);</span><br><span class="line">            for (int i = 0; i &lt; strings.length - 1; i++) &#123;</span><br><span class="line">                for (int j = i+1; j &lt; strings.length; j++) &#123;</span><br><span class="line">                    outKey.set(strings[i]+&quot;-&quot;+strings[j]);</span><br><span class="line">                    context.write(outKey,outValue);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 第二次reducer输出结果：</span><br><span class="line">         A-B	E,C</span><br><span class="line">         A-C	D,F</span><br><span class="line">         A-D	E,F</span><br><span class="line">         A-E	B,C,D</span><br><span class="line">         A-F	C,E,O,D,B</span><br><span class="line">         A-G	E,F,C,D</span><br><span class="line">         A-H	C,D,E,O</span><br><span class="line">         A-I	O</span><br><span class="line">         A-J	O,B</span><br><span class="line">         A-K	C,D</span><br><span class="line">         A-L	F,D,E</span><br><span class="line">         A-M	F,E</span><br><span class="line">         B-C	A</span><br><span class="line">         B-D	A,E</span><br><span class="line">         B-E	C</span><br><span class="line">         B-F	C,A,E</span><br><span class="line">         B-G	E,C,A</span><br><span class="line">         B-H	E,C,A</span><br><span class="line">         B-I	A</span><br><span class="line">         B-K	A,C</span><br><span class="line">         B-L	E</span><br><span class="line">         B-M	E</span><br><span class="line">         B-O	A,K</span><br><span class="line">         C-D	A,F</span><br><span class="line">         C-E	D</span><br><span class="line">         C-F	A,D</span><br><span class="line">         C-G	A,D,F</span><br><span class="line">         C-H	D,A</span><br><span class="line">         C-I	A</span><br><span class="line">         C-K	A,D</span><br><span class="line">         C-L	D,F</span><br><span class="line">         C-M	F</span><br><span class="line">         C-O	I,A</span><br><span class="line">         D-E	L</span><br><span class="line">         D-F	A,E</span><br><span class="line">         D-G	E,A,F</span><br><span class="line">         D-H	A,E</span><br><span class="line">         D-I	A</span><br><span class="line">         D-K	A</span><br><span class="line">         D-L	E,F</span><br><span class="line">         D-M	F,E</span><br><span class="line">         D-O	A</span><br><span class="line">         E-F	D,M,C,B</span><br><span class="line">         E-G	C,D</span><br><span class="line">         E-H	C,D</span><br><span class="line">         E-J	B</span><br><span class="line">         E-K	C,D</span><br><span class="line">         E-L	D</span><br><span class="line">         F-G	D,C,A,E</span><br><span class="line">         F-H	A,D,O,E,C</span><br><span class="line">         F-I	O,A</span><br><span class="line">         F-J	B,O</span><br><span class="line">         F-K	D,C,A</span><br><span class="line">         F-L	E,D</span><br><span class="line">         F-M	E</span><br><span class="line">         F-O	A</span><br><span class="line">         G-H	D,C,E,A</span><br><span class="line">         G-I	A</span><br><span class="line">         G-K	D,A,C</span><br><span class="line">         G-L	D,F,E</span><br><span class="line">         G-M	E,F</span><br><span class="line">         G-O	A</span><br><span class="line">         H-I	O,A</span><br><span class="line">         H-J	O</span><br><span class="line">         H-K	A,C,D</span><br><span class="line">         H-L	D,E</span><br><span class="line">         H-M	E</span><br><span class="line">         H-O	A</span><br><span class="line">         I-J	O</span><br><span class="line">         I-K	A</span><br><span class="line">         I-O	A</span><br><span class="line">         K-L	D</span><br><span class="line">         K-O	A</span><br><span class="line">         L-M	E,F</span><br><span class="line"></span><br><span class="line">     */</span><br><span class="line">    public static class SFMerge1Reducer2 extends Reducer&lt;Text,Text,Text,Text&gt;&#123;</span><br><span class="line">        private Text outValue = new Text();</span><br><span class="line">        @Override</span><br><span class="line">        protected void reduce(Text key, Iterable&lt;Text&gt; values, Context context) throws IOException, InterruptedException &#123;</span><br><span class="line">            StringBuilder sb = new StringBuilder();</span><br><span class="line">            for (Text str :</span><br><span class="line">                    values) &#123;</span><br><span class="line">                if(sb.length()!= 0)&#123;</span><br><span class="line">                    sb.append(&quot;,&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                sb.append(str);</span><br><span class="line">                outValue.set(sb.toString());</span><br><span class="line">            &#125;</span><br><span class="line">            context.write(key,outValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 大数据 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hadoop </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[wordcount学生成绩普通版案例]]></title>
      <url>/wordcount%E5%AD%A6%E7%94%9F%E6%88%90%E7%BB%A9%E6%99%AE%E9%80%9A%E7%89%88%E6%A1%88%E4%BE%8B.html</url>
      <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.Practice.StudentScores;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.FileSystem;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.LongWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Job;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Mapper;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Reducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Collections;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 题目：学生成绩普通版</span><br><span class="line"> *</span><br><span class="line"> *   computer,huangxiaoming,85</span><br><span class="line">     computer,xuzheng,54</span><br><span class="line">     computer,huangbo,86</span><br><span class="line">     computer,liutao,85</span><br><span class="line">     computer,huanglei,99</span><br><span class="line">     computer,liujialing,85</span><br><span class="line">     computer,liuyifei,75</span><br><span class="line">     computer,huangdatou,48</span><br><span class="line">     computer,huangjiaju,88</span><br><span class="line">     computer,huangzitao,85</span><br><span class="line">     english,zhaobenshan,57</span><br><span class="line">     english,liuyifei,85</span><br><span class="line">     english,liuyifei,76</span><br><span class="line">     english,huangdatou,48</span><br><span class="line">     english,zhouqi,85</span><br><span class="line">     english,huangbo,85</span><br><span class="line">     english,huangxiaoming,96</span><br><span class="line">     english,huanglei,85</span><br><span class="line">     english,liujialing,75</span><br><span class="line">     algorithm,liuyifei,75</span><br><span class="line">     algorithm,huanglei,76</span><br><span class="line">     algorithm,huangjiaju,85</span><br><span class="line">     algorithm,liutao,85</span><br><span class="line">     algorithm,huangdou,42</span><br><span class="line">     algorithm,huangzitao,81</span><br><span class="line">     math,wangbaoqiang,85</span><br><span class="line">     math,huanglei,76</span><br><span class="line">     math,huangjiaju,85</span><br><span class="line">     math,liutao,48</span><br><span class="line">     math,xuzheng,54</span><br><span class="line">     math,huangxiaoming,85</span><br><span class="line">     math,liujialing,85</span><br><span class="line"> *</span><br><span class="line"> * 1、每一个course的最高分，最低分，平均分</span><br><span class="line"> 返回结果格式：</span><br><span class="line"> course	max=95	min=22	avg=55</span><br><span class="line"> 例子：</span><br><span class="line"> computer	max=99	min=48	avg=75</span><br><span class="line"></span><br><span class="line"> 解题思路：在map以course作为key值，其余部分作为value，在reduce中设置变量max，min，avg，通过累计求出，并设置格式</span><br><span class="line"></span><br><span class="line"> 2、求该成绩表当中出现了相同分数的分数，还有次数，以及该分数的人</span><br><span class="line"> 返回结果的格式：</span><br><span class="line"> 科目	分数	次数	该分数的人</span><br><span class="line"> 例子：</span><br><span class="line"> computer	85	3	huangzitao,liujialing,huangxiaoming</span><br><span class="line"></span><br><span class="line"> 解题思路：求某科目中出现系统分数的人数以及分数，map以科目和分数作为key值，进行分组，在reduce中进行计数，当计数结果大于1时，输出分数，人数和人名</span><br><span class="line"> */</span><br><span class="line">public class StudentScores1 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException, ClassNotFoundException, InterruptedException &#123;</span><br><span class="line">        Configuration conf = new Configuration();</span><br><span class="line">        FileSystem fs = FileSystem.get(conf);</span><br><span class="line"></span><br><span class="line">        Job job = Job.getInstance(conf);</span><br><span class="line">        job.setJar(&quot;wordcountJar/wordcount.jar&quot;);</span><br><span class="line">//        job.setMapperClass(StudentScoresMapper.class);</span><br><span class="line">//        job.setReducerClass(StudentScoresReducer.class);</span><br><span class="line">        job.setMapperClass(StudentScoresMapper2.class);</span><br><span class="line">        job.setReducerClass(StudentScoresReducer2.class);</span><br><span class="line"></span><br><span class="line">//        job.setOutputKeyClass(Text.class);</span><br><span class="line">//        job.setOutputValueClass(IntWritable.class);</span><br><span class="line">        job.setOutputKeyClass(Text.class);</span><br><span class="line">        job.setOutputValueClass(Text.class);</span><br><span class="line"></span><br><span class="line">        Path inputPath = new Path(&quot;input/studentScores&quot;);</span><br><span class="line">        Path outputPath = new Path(&quot;output/studentScores&quot;);</span><br><span class="line"></span><br><span class="line">        if(fs.isDirectory(outputPath))&#123;</span><br><span class="line">            fs.delete(outputPath,true);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        FileInputFormat.setInputPaths(job,inputPath);</span><br><span class="line">        FileOutputFormat.setOutputPath(job,outputPath);</span><br><span class="line"></span><br><span class="line">        Boolean waitForCompletion = job.waitForCompletion(true);</span><br><span class="line">        System.exit(waitForCompletion ? 0 : 1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 第一题</span><br><span class="line">     */</span><br><span class="line">    public static class StudentScoresMapper extends Mapper&lt;LongWritable,Text,Text,IntWritable&gt; &#123;</span><br><span class="line">        private IntWritable outValue = new IntWritable();</span><br><span class="line">        private Text outKey = new Text();</span><br><span class="line">        @Override</span><br><span class="line">        protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException &#123;</span><br><span class="line">            String[] splits = value.toString().split(&quot;,&quot;);</span><br><span class="line">            outKey.set(splits[0]);</span><br><span class="line">            outValue.set(Integer.parseInt(splits[2]));</span><br><span class="line">            context.write(outKey,outValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 第一题</span><br><span class="line">     */</span><br><span class="line">    public static class StudentScoresReducer extends Reducer&lt;Text,IntWritable,Text,Text&gt; &#123;</span><br><span class="line">        private Text outValue = new Text();</span><br><span class="line">        @Override</span><br><span class="line">        protected void reduce(Text key, Iterable&lt;IntWritable&gt; values, Context context) throws IOException, InterruptedException &#123;</span><br><span class="line">            int min = 1000 ;</span><br><span class="line">            int max = 0 ;</span><br><span class="line">            int avg  ;</span><br><span class="line">            int sum = 0 ;</span><br><span class="line">            int count = 0 ;</span><br><span class="line">            //方法一：最大最小通过逐一比较得到</span><br><span class="line">//            for (IntWritable val:</span><br><span class="line">//                 values) &#123;</span><br><span class="line">//                int score = val.get();</span><br><span class="line">//                if(max  &lt; score)&#123;</span><br><span class="line">//                    max = score;</span><br><span class="line">//                &#125;</span><br><span class="line">//                if(min &gt; score)&#123;</span><br><span class="line">//                    min = score ;</span><br><span class="line">//                &#125;</span><br><span class="line">//                sum += score ;</span><br><span class="line">//                count++ ;</span><br><span class="line">//            &#125;</span><br><span class="line">//                avg = sum /count ;</span><br><span class="line">//                String outStr = &quot;max=&quot;+max+&quot; min=&quot;+min+&quot; avg=&quot;+avg;</span><br><span class="line">//                outValue.set(outStr);</span><br><span class="line"></span><br><span class="line">            //方法二：最大最小值通过集合数组得到</span><br><span class="line">            List&lt;Integer&gt; scores = new ArrayList&lt;&gt;();</span><br><span class="line">            for (IntWritable val :</span><br><span class="line">                    values) &#123;</span><br><span class="line">                scores.add(val.get());</span><br><span class="line">                sum += val.get();</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            Collections.sort(scores);</span><br><span class="line">            min = scores.get(0);</span><br><span class="line">            max = scores.get(scores.size()-1);</span><br><span class="line">            avg = sum / count ;</span><br><span class="line">            String outStr = &quot;max=&quot;+max+&quot; min=&quot;+min+&quot; avg=&quot;+avg;</span><br><span class="line">            outValue.set(outStr);</span><br><span class="line">            context.write(key,outValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 第二题</span><br><span class="line">     */</span><br><span class="line">    public static class StudentScoresMapper2 extends Mapper&lt;LongWritable,Text,Text,Text&gt;&#123;</span><br><span class="line">        private Text outKey = new Text();</span><br><span class="line">        private Text outValue = new Text();</span><br><span class="line">        @Override</span><br><span class="line">        protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException &#123;</span><br><span class="line">            String[] splits = value.toString().split(&quot;,&quot;);</span><br><span class="line">            outKey.set(splits[0]+&quot;\t&quot;+splits[2]);</span><br><span class="line">            outValue.set(splits[1]);</span><br><span class="line">            context.write(outKey,outValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 第二题</span><br><span class="line">     */</span><br><span class="line">    public static class StudentScoresReducer2 extends Reducer&lt;Text,Text,Text,Text&gt;&#123;</span><br><span class="line">        private Text outValue = new Text();</span><br><span class="line">        @Override</span><br><span class="line">        protected void reduce(Text key, Iterable&lt;Text&gt; values, Context context) throws IOException, InterruptedException &#123;</span><br><span class="line">            StringBuilder sb = new StringBuilder();</span><br><span class="line">            int count = 0 ;</span><br><span class="line">            for (Text text :</span><br><span class="line">                    values) &#123;</span><br><span class="line">                if(sb.length()!=0)&#123;</span><br><span class="line">                    sb.append(&quot;,&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                sb.append(text);</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            //如果count大于等于2，说明有分数重合的</span><br><span class="line">            if(count &gt;= 2 )&#123;</span><br><span class="line">                outValue.set(count+&quot; &quot;+sb.toString());</span><br><span class="line">                context.write(key,outValue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 大数据 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hadoop </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[wordcount求学生平均成绩案例]]></title>
      <url>/wordcount%E6%B1%82%E5%AD%A6%E7%94%9F%E5%B9%B3%E5%9D%87%E6%88%90%E7%BB%A9%E6%A1%88%E4%BE%8B.html</url>
      <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.Practice.AverageScores;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.Practice.SameFriend.SameFriend;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.FileSystem;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.LongWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Job;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Mapper;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Reducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.StringTokenizer;</span><br><span class="line">/**</span><br><span class="line"> * 求学生平均成绩</span><br><span class="line"> * 计算学生考试平均成绩 源数据：</span><br><span class="line">     张三 98</span><br><span class="line">     李四 96</span><br><span class="line">     王五 95</span><br><span class="line">     张三 90</span><br><span class="line">     李四 92</span><br><span class="line">     王五 99</span><br><span class="line">     张三 80</span><br><span class="line">     李四 90</span><br><span class="line">     王五 94</span><br><span class="line">     张三 82</span><br><span class="line">     李四 92</span><br><span class="line"> */</span><br><span class="line">public class AverageScores &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException, ClassNotFoundException, InterruptedException &#123;</span><br><span class="line">        Configuration conf = new Configuration();</span><br><span class="line">        FileSystem fs = FileSystem.get(conf);</span><br><span class="line"></span><br><span class="line">        Job job = Job.getInstance(conf);</span><br><span class="line">        job.setJar(&quot;wordcountJar/wordcount.jar&quot;);</span><br><span class="line"></span><br><span class="line">        job.setMapperClass(AverageScoresMapper.class);</span><br><span class="line">        job.setReducerClass(AverageScoresReducer.class);</span><br><span class="line"></span><br><span class="line">        job.setOutputKeyClass(Text.class);</span><br><span class="line">        job.setOutputValueClass(IntWritable.class);</span><br><span class="line"></span><br><span class="line">        Path inputPath = new Path(&quot;input/AverageScore&quot;);</span><br><span class="line">        Path outputPath = new Path(&quot;output/AverageScore&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        if(fs.isDirectory(outputPath))&#123;</span><br><span class="line">            fs.delete(outputPath,true);</span><br><span class="line">        &#125;</span><br><span class="line">        FileInputFormat.setInputPaths(job,inputPath);</span><br><span class="line">        FileOutputFormat.setOutputPath(job,outputPath);</span><br><span class="line"></span><br><span class="line">        boolean waitForCompletion = job.waitForCompletion(true);</span><br><span class="line">        System.exit(waitForCompletion ? 0 : 1 );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class AverageScoresMapper extends Mapper&lt;LongWritable,Text,Text,IntWritable&gt; &#123;</span><br><span class="line">        private Text outKey = new Text();</span><br><span class="line">        private IntWritable outValue = new IntWritable();</span><br><span class="line">        @Override</span><br><span class="line">        protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException &#123;</span><br><span class="line">            String[] splits = value.toString().split(&quot;\t&quot;);</span><br><span class="line">            outKey.set(splits[0]);</span><br><span class="line">            outValue.set(Integer.parseInt(splits[1]));</span><br><span class="line">            context.write(outKey,outValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class AverageScoresReducer extends Reducer&lt;Text,IntWritable,Text,IntWritable&gt; &#123;</span><br><span class="line">        private IntWritable outValue = new IntWritable();</span><br><span class="line">        @Override</span><br><span class="line">        protected void reduce(Text key, Iterable&lt;IntWritable&gt; values, Context context) throws IOException, InterruptedException &#123;</span><br><span class="line">            int avg = 0 ;</span><br><span class="line">            int sum = 0 ;</span><br><span class="line">            int count = 0 ;</span><br><span class="line">            for (IntWritable val :</span><br><span class="line">                    values) &#123;</span><br><span class="line">                int score = val.get();</span><br><span class="line">                sum += score ;</span><br><span class="line">                count ++ ;</span><br><span class="line">            &#125;</span><br><span class="line">            avg = sum /count ;</span><br><span class="line">            outValue.set(avg);</span><br><span class="line">            context.write(key,outValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 大数据 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hadoop </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[wordcount数据去重案例]]></title>
      <url>/wordcount%E6%95%B0%E6%8D%AE%E5%8E%BB%E9%87%8D%E6%A1%88%E4%BE%8B.html</url>
      <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.Practice.RemoveDupData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.FileSystem;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.LongWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.NullWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Job;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Mapper;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Reducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 题目：数据去重</span><br><span class="line"> * 解题思路：将每行数据作为key值，value值为空</span><br><span class="line"> *  2012-3-1 a</span><br><span class="line">    2012-3-2 b</span><br><span class="line">    2012-3-3 c</span><br><span class="line">    2012-3-4 d</span><br><span class="line">    2012-3-5 a</span><br><span class="line">    2012-3-6 b</span><br><span class="line">    2012-3-7 c</span><br><span class="line">    2012-3-3 c</span><br><span class="line">    2012-3-1 b</span><br><span class="line">    2012-3-2 a</span><br><span class="line">    2012-3-3 b</span><br><span class="line">    2012-3-4 d</span><br><span class="line">    2012-3-5 a</span><br><span class="line">    2012-3-6 c</span><br><span class="line">    2012-3-7 d</span><br><span class="line">    2012-3-3 c</span><br><span class="line"> */</span><br><span class="line">public class RemoveDupData &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException, ClassNotFoundException, InterruptedException &#123;</span><br><span class="line">        Configuration conf = new Configuration();</span><br><span class="line">        FileSystem fs = FileSystem.get(conf);</span><br><span class="line"></span><br><span class="line">        Job job = Job.getInstance(conf);</span><br><span class="line">        job.setJar(&quot;wordcountJar/wordcount.jar&quot;);</span><br><span class="line"></span><br><span class="line">        job.setMapperClass(RemoveDupDataMapper.class);</span><br><span class="line">        job.setReducerClass(RemoveDupDataReducer.class);</span><br><span class="line"></span><br><span class="line">        job.setOutputKeyClass(Text.class);</span><br><span class="line">        job.setOutputValueClass(NullWritable.class);</span><br><span class="line"></span><br><span class="line">        Path inputPath = new Path(&quot;input/RemoveDupData&quot;);</span><br><span class="line">        Path outputPath = new Path(&quot;output/RemoveDupData&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        if(fs.isDirectory(outputPath))&#123;</span><br><span class="line">            fs.delete(outputPath,true);</span><br><span class="line">        &#125;</span><br><span class="line">        FileInputFormat.setInputPaths(job,inputPath);</span><br><span class="line">        FileOutputFormat.setOutputPath(job,outputPath);</span><br><span class="line"></span><br><span class="line">        boolean waitForCompletion = job.waitForCompletion(true);</span><br><span class="line">        System.exit(waitForCompletion ? 0 : 1 );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class RemoveDupDataMapper extends Mapper&lt;LongWritable,Text,Text,NullWritable&gt;&#123;</span><br><span class="line">        @Override</span><br><span class="line">        protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException &#123;</span><br><span class="line">            context.write(value,NullWritable.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class RemoveDupDataReducer extends Reducer&lt;Text,NullWritable,Text,NullWritable&gt;&#123;</span><br><span class="line">        @Override</span><br><span class="line">        protected void reduce(Text key, Iterable&lt;NullWritable&gt; values, Context context) throws IOException, InterruptedException &#123;</span><br><span class="line">            context.write(key,NullWritable.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 大数据 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hadoop </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[wordcount 互为好友对案例]]></title>
      <url>/wordcount%E4%BA%92%E4%B8%BA%E5%A5%BD%E5%8F%8B%E5%AF%B9%E6%A1%88%E4%BE%8B.html</url>
      <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.Practice.SameFriend2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.Practice.SameFriend.SameFriend;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.FileSystem;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.LongWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Job;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Mapper;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Reducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 求互粉好友对 比如：如果A和B互为好友，那么A-B即为互粉好友对。</span><br><span class="line"> *   A:B,C,D,F,E,O</span><br><span class="line">     B:A,C,E,K</span><br><span class="line">     C:F,A,D,I</span><br><span class="line">     D:A,E,F,L</span><br><span class="line">     E:B,C,D,M,L</span><br><span class="line">     F:A,B,C,D,E,O,M</span><br><span class="line">     G:A,C,D,E,F</span><br><span class="line">     H:A,C,D,E,O</span><br><span class="line">     I:A,O</span><br><span class="line">     J:B,O</span><br><span class="line">     K:A,C,D</span><br><span class="line">     L:D,E,F</span><br><span class="line">     M:E,F,G</span><br><span class="line">     O:A,H,I,J,K</span><br><span class="line"> */</span><br><span class="line">public class SameFriend2 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException, ClassNotFoundException, InterruptedException &#123;</span><br><span class="line">        Configuration conf = new Configuration();</span><br><span class="line">        FileSystem fs = FileSystem.get(conf);</span><br><span class="line"></span><br><span class="line">        Job job = Job.getInstance(conf);</span><br><span class="line">        job.setJar(&quot;wordcountJar/wordcount.jar&quot;);</span><br><span class="line"></span><br><span class="line">        job.setMapperClass(SameFriend2Mapper.class);</span><br><span class="line">        job.setReducerClass(SameFriend2Reducer.class);</span><br><span class="line"></span><br><span class="line">        job.setOutputKeyClass(Text.class);</span><br><span class="line">        job.setOutputValueClass(IntWritable.class);</span><br><span class="line"></span><br><span class="line">        Path inputPath = new Path(&quot;input/SameFriend2&quot;);</span><br><span class="line">        Path outputPath = new Path(&quot;output/SameFriend2&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        if(fs.isDirectory(outputPath))&#123;</span><br><span class="line">            fs.delete(outputPath,true);</span><br><span class="line">        &#125;</span><br><span class="line">        FileInputFormat.setInputPaths(job,inputPath);</span><br><span class="line">        FileOutputFormat.setOutputPath(job,outputPath);</span><br><span class="line"></span><br><span class="line">        boolean waitForCompletion = job.waitForCompletion(true);</span><br><span class="line">        System.exit(waitForCompletion ? 0 : 1 );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class SameFriend2Mapper extends Mapper&lt;LongWritable,Text,Text,IntWritable&gt; &#123;</span><br><span class="line">        private Text outKey = new Text();</span><br><span class="line">        private IntWritable outValue = new IntWritable(1);</span><br><span class="line">        @Override</span><br><span class="line">        protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException &#123;</span><br><span class="line">            String[] splits = value.toString().split(&quot;:&quot;);</span><br><span class="line">            String[] strings = splits[1].split(&quot;,&quot;);</span><br><span class="line">            for (String str:</span><br><span class="line">                 strings) &#123;</span><br><span class="line">                //关键代码：如果A和B互为好友，则必定存在A-B和B-A，此处的作用就是将A-B和B-A 都编程为A-B，或者都编程为B-A</span><br><span class="line">                if(splits[0].compareTo(str)&gt;0)&#123;</span><br><span class="line">                    outKey.set(str+&quot;-&quot;+splits[0]);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    outKey.set(splits[0]+&quot;-&quot;+str);</span><br><span class="line">                &#125;</span><br><span class="line">               context.write(outKey,outValue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 如果互为好友对，count必定为2</span><br><span class="line">     */</span><br><span class="line">    public static class SameFriend2Reducer extends Reducer&lt;Text,IntWritable,Text,IntWritable&gt; &#123;</span><br><span class="line">        private IntWritable outValue = new IntWritable();</span><br><span class="line">        @Override</span><br><span class="line">        protected void reduce(Text key, Iterable&lt;IntWritable&gt; values, Context context) throws IOException, InterruptedException &#123;</span><br><span class="line">            int count = 0 ;</span><br><span class="line">            for (IntWritable val :</span><br><span class="line">                    values) &#123;</span><br><span class="line">                count += val.get();</span><br><span class="line">            &#125;</span><br><span class="line">            //当count为2时，即可求出好友对</span><br><span class="line">            if(count == 2)&#123;</span><br><span class="line">                outValue.set(count);</span><br><span class="line">                context.write(key,outValue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>```</p>
]]></content>
      
        <categories>
            
            <category> 大数据 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> mapreduce </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[IDEA windows本地运行wordcount程序]]></title>
      <url>/IDEAwindows%E6%9C%AC%E5%9C%B0%E8%BF%90%E8%A1%8Cwordcount%E7%A8%8B%E5%BA%8F.html</url>
      <content type="html"><![CDATA[<h3 id="第一步创建maven项目"><a href="#第一步创建maven项目" class="headerlink" title="第一步创建maven项目"></a>第一步创建maven项目</h3><h3 id="第二步创建WordCountDemo类"><a href="#第二步创建WordCountDemo类" class="headerlink" title="第二步创建WordCountDemo类"></a>第二步创建WordCountDemo类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wordcountModel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.FileSystem;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.LongWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Job;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Mapper;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Reducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.StringTokenizer;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  本地运行wordcount程序</span><br><span class="line"> */</span><br><span class="line">public class WordCountDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException, ClassNotFoundException, InterruptedException &#123;</span><br><span class="line">        //指定hdfs的相关参数</span><br><span class="line">        Configuration conf = new Configuration() ;</span><br><span class="line">        FileSystem fs = FileSystem.get(conf);</span><br><span class="line"></span><br><span class="line">        //通过Configuration对象获取job对象，该job对象会组织所有的该mapreduce的所有各种组件</span><br><span class="line">        Job job = Job.getInstance(conf);</span><br><span class="line">        //指定jar包所在路径，本地模式需要这样指定，如果不是本地，则使用setJarByClass指定所在class文件即可</span><br><span class="line">        //job.setJarByClass(&quot;wordcountJar/wordcount.jar&quot;)</span><br><span class="line">        job.setJar(&quot;wordcountJar/wordcount.jar&quot;);</span><br><span class="line"></span><br><span class="line">        //指定mapper类和reducer类</span><br><span class="line">        job.setMapperClass(WordcountMapper.class);</span><br><span class="line">        job.setReducerClass(WordcountReducer.class);</span><br><span class="line"></span><br><span class="line">        //Mapper的输入key-value类型，由mapreduce框架决定</span><br><span class="line">        //指定maptask的输出类型</span><br><span class="line">        job.setMapOutputKeyClass(Text.class);</span><br><span class="line">        job.setMapOutputValueClass(IntWritable.class);</span><br><span class="line">        // 假如 mapTask的输出key-value类型，跟reduceTask的输出key-value类型一致，那么，以上两句代码可以不用设置</span><br><span class="line"></span><br><span class="line">        // reduceTask的输入key-value类型 就是 mapTask的输出key-value类型。所以不需要指定</span><br><span class="line">        // 指定reducetask的输出类型</span><br><span class="line">        job.setOutputKeyClass(Text.class);</span><br><span class="line">        job.setOutputValueClass(IntWritable.class);</span><br><span class="line"></span><br><span class="line">        // 为job指定输入数据的组件和输出数据的组件，以下两个参数是默认的，所以不指定也是OK的</span><br><span class="line">        // job.setInputFormatClass(TextInputFormat.class);</span><br><span class="line">        // job.setOutputFormatClass(TextOutputFormat.class);</span><br><span class="line"></span><br><span class="line">        // 为该mapreduce程序制定默认的数据分区组件。默认是 HashPartitioner.class</span><br><span class="line">        // job.setPartitionerClass(HashPartitioner.class);</span><br><span class="line"></span><br><span class="line">        // 指定该mapreduce程序数据的输入和输出路径</span><br><span class="line">        Path inputPath = new Path(&quot;input/wordcount/&quot;);</span><br><span class="line">        Path outputPath = new Path(&quot;output/wordcount/&quot;);</span><br><span class="line"></span><br><span class="line">        // 设置该MapReduce程序的ReduceTask的个数,默认为1</span><br><span class="line">        // job.setNumReduceTasks(3);</span><br><span class="line"></span><br><span class="line">        // 该段代码是用来判断输出路径存在不存在，存在就删除，虽然方便操作，但请谨慎</span><br><span class="line">        if(fs.isDirectory(outputPath))&#123;</span><br><span class="line">            fs.delete(outputPath,true);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //设置wordcount程序的输入路径</span><br><span class="line">        FileInputFormat.setInputPaths(job,inputPath);</span><br><span class="line">        //设置wordcount程序的输出路径</span><br><span class="line">        FileOutputFormat.setOutputPath(job,outputPath);</span><br><span class="line"></span><br><span class="line">        // job.submit();</span><br><span class="line">        // 最后提交任务(verbose布尔值 决定要不要将运行进度信息输出给用户)</span><br><span class="line">        boolean waitForCompletion = job.waitForCompletion(true);</span><br><span class="line">        System.exit( waitForCompletion ? 0 : 1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Mapper&lt;KEYIN, VALUEIN, KEYOUT, VALUEOUT&gt;</span><br><span class="line">     *</span><br><span class="line">     * KEYIN 是指框架读取到的数据的key的类型，在默认的InputFormat下，读到的key是一行文本的起始偏移量，所以key的类型是Long</span><br><span class="line">     * VALUEIN 是指框架读取到的数据的value的类型,在默认的InputFormat下，读到的value是一行文本的内容，所以value的类型是String</span><br><span class="line">     * KEYOUT 是指用户自定义逻辑方法返回的数据中key的类型，由用户业务逻辑决定，在此wordcount程序中，我们输出的key是单词，所以是String</span><br><span class="line">     * VALUEOUT 是指用户自定义逻辑方法返回的数据中value的类型，由用户业务逻辑决定,在此wordcount程序中，我们输出的value是单词的数量，所以是Integer</span><br><span class="line">     *</span><br><span class="line">     * 但是，String ，Long等jdk中自带的数据类型，在序列化时，效率比较低，hadoop为了提高序列化效率，自定义了一套序列化框架</span><br><span class="line">     * 所以，在hadoop的程序中，如果该数据需要进行序列化（写磁盘，或者网络传输），就一定要用实现了hadoop序列化框架的数据类型</span><br><span class="line">     *</span><br><span class="line">     * Long ----&gt; LongWritable</span><br><span class="line">     * String ----&gt; Text</span><br><span class="line">     * Integer ----&gt; IntWritable</span><br><span class="line">     * Null ----&gt; NullWritable</span><br><span class="line">     */</span><br><span class="line">    public static class WordcountMapper extends Mapper&lt;LongWritable,Text,Text,IntWritable&gt; &#123;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * LongWritable key : 该key就是value该行文本的在文件当中的起始偏移量</span><br><span class="line">         * Text value ： 就是MapReduce框架默认的数据读取组件TextInputFormat读取文件当中的一行文本</span><br><span class="line">         */</span><br><span class="line">        private Text word = new Text();</span><br><span class="line">        @Override</span><br><span class="line">        protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException &#123;</span><br><span class="line">            // 切分单词</span><br><span class="line">            StringTokenizer tokenizer = new StringTokenizer(value.toString());</span><br><span class="line">            while (tokenizer.hasMoreTokens())&#123;</span><br><span class="line">                word.set(tokenizer.nextToken());</span><br><span class="line">                // 每个单词计数一次，也就是把单词组织成&lt;hello,1&gt;这样的key-value对往外写出</span><br><span class="line">                context.write(word,new IntWritable(1));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 首先，和前面一样，Reducer类也有输入和输出，输入就是Map阶段的处理结果，输出就是Reduce最后的输出</span><br><span class="line">     * reducetask在调我们写的reduce方法,reducetask应该收到了前一阶段（map阶段）中所有maptask输出的数据中的一部分</span><br><span class="line">     * （数据的key.hashcode%reducetask数==本reductask号），所以reducetaks的输入类型必须和maptask的输出类型一样</span><br><span class="line">     *</span><br><span class="line">     * reducetask将这些收到kv数据拿来处理时，是这样调用我们的reduce方法的： 先将自己收到的所有的kv对按照k分组（根据k是否相同）</span><br><span class="line">     * 将某一组kv中的第一个kv中的k传给reduce方法的key变量，把这一组kv中所有的v用一个迭代器传给reduce方法的变量values</span><br><span class="line">     */</span><br><span class="line">    public static class WordcountReducer extends Reducer&lt;Text,IntWritable,Text,IntWritable&gt; &#123;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Text key : mapTask输出的key值</span><br><span class="line">         * Iterable&lt;IntWritable&gt; values ： key对应的value的集合（该key只是相同的一个key）</span><br><span class="line">         *</span><br><span class="line">         * reduce方法接收key值相同的一组key-value进行汇总计算</span><br><span class="line">         */</span><br><span class="line">        private IntWritable result = new IntWritable();</span><br><span class="line">        @Override</span><br><span class="line">        protected void reduce(Text key, Iterable&lt;IntWritable&gt; values, Context context) throws IOException, InterruptedException &#123;</span><br><span class="line">            //结果汇总</span><br><span class="line">            int sum = 0 ;</span><br><span class="line">            for (IntWritable val:</span><br><span class="line">                 values ) &#123;</span><br><span class="line">                sum += val.get();</span><br><span class="line">            &#125;</span><br><span class="line">            //汇总的结果往外输出</span><br><span class="line">            result.set(sum);</span><br><span class="line">            context.write(key,result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意事项：wordcount程序加载配置文件的顺序为:</p>
<pre><code>1、conf.set(&quot;fs.defaultFS&quot;,&quot;hdfs://hadoop01:9000&quot;);
2、通过加载配置文件：
    conf.addResource(&quot;hdfs_config/core-site.xml&quot;);
    conf.addResource(&quot;hdfs_config/hdfs-site.xml&quot;);
3、加载本地hadoop的jar包中的配置文件
</code></pre><p>所以，如果要进行本地运行wordcount程序，则使用第二种，即不需要手动配置，程序会自动加载。如果配置文件夹中已经存在已经配置好的文件，程序会优先加载配置文件夹中的配置文件。</p>
<h3 id="第三步-导入jar包"><a href="#第三步-导入jar包" class="headerlink" title="第三步 导入jar包"></a>第三步 导入jar包</h3><p><img src="http://ou3xxg3hg.bkt.clouddn.com/%E5%AF%BC%E5%87%BAjar%E5%8C%85.gif" alt="这里写图片描述"></p>
<h3 id="第四步-运行程序"><a href="#第四步-运行程序" class="headerlink" title="第四步 运行程序"></a>第四步 运行程序</h3><h4 id="注：部分注意事项写在程序注释中。"><a href="#注：部分注意事项写在程序注释中。" class="headerlink" title="注：部分注意事项写在程序注释中。"></a>注：部分注意事项写在程序注释中。</h4>]]></content>
      
        <categories>
            
            <category> 大数据 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hadoop </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[shell实现九九乘法表]]></title>
      <url>/shell%E5%AE%9E%E7%8E%B0%E4%B9%9D%E4%B9%9D%E4%B9%98%E6%B3%95%E8%A1%A8.html</url>
      <content type="html"><![CDATA[<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for (( i=1;i&lt;=9;i++ ))</span><br><span class="line">do</span><br><span class="line">        for (( j=1;j&lt;=i;j++ ))</span><br><span class="line">        do</span><br><span class="line">            echo -n "$j*$i=$[$j*$i] "</span><br><span class="line">        done</span><br><span class="line">        echo -e '\n'</span><br><span class="line">done</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> shell </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[配置163云源repo]]></title>
      <url>/%E9%85%8D%E7%BD%AE163%E4%BA%91%E6%BA%90repo.html</url>
      <content type="html"><![CDATA[<ol>
<li><p>进入yum配置文件目录<br>cd /etc/yum.repos.d/</p>
</li>
<li><p>备份配置文件<br>  mv CentOS-Base.repo CentOS-Base.repo.bak</p>
</li>
<li><p>下载163的配置<br> wget <span class="exturl" data-url="aHR0cDovL21pcnJvcnMuMTYzLmNvbS8uaGVscC9DZW50T1M2LQ==" title="http://mirrors.163.com/.help/CentOS6-">http://mirrors.163.com/.help/CentOS6-<i class="fa fa-external-link"></i></span>              Base-163.repo，下载下来的文件名为 CentOS6-    Base-163.repo</p>
</li>
<li><p>改名<br> mv CentOS6-Base-163.repo CentOS-Base.repo</p>
</li>
<li><p>更新数据库<br> yum update</p>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> rpm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Spring侵入式和非侵入式的区别]]></title>
      <url>/Spring%E4%BE%B5%E5%85%A5%E5%BC%8F%E5%92%8C%E9%9D%9E%E4%BE%B5%E5%85%A5%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB.html</url>
      <content type="html"><![CDATA[<h2 id="简单解释："><a href="#简单解释：" class="headerlink" title="简单解释："></a>简单解释：</h2><p>侵入式：使用者编写代码时，需要继承或者实现框架的类或接口，需要依赖框架。<br>非侵入式：使用者编写代码时，无需继承或者实现框架的类或接口，察觉不到框架的存在。</p>
<hr>
<h2 id="Spring框架是一种非侵入式的轻量级框架"><a href="#Spring框架是一种非侵入式的轻量级框架" class="headerlink" title="Spring框架是一种非侵入式的轻量级框架"></a>Spring框架是一种非侵入式的轻量级框架</h2><p>###1.非侵入式的技术体现<br>允许在应用系统中自由选择和组装Spring框架的各个功能模块，并且不强制要求应用系统的类必须从Spring框架的系统API的某个类来继承或者实现某个接口。</p>
<h3 id="2-如何实现非侵入式的设计目标的"><a href="#2-如何实现非侵入式的设计目标的" class="headerlink" title="2.如何实现非侵入式的设计目标的"></a>2.如何实现非侵入式的设计目标的</h3><p> 1）应用反射机制，通过动态调用的方式来提供各方面的功能，建立核心组间BeanFactory<br> 2）配合使用Spring框架中的BeanWrapper和BeanFactory组件类最终达到对象的实例创建和属性注入<br> 3）优点：允许所开发出来的应用系统能够在不用的环境中自由移植，不需要修改应用系统中的核心功能实现的代码</p>
]]></content>
      
        <categories>
            
            <category> 框架 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[常见SQL语句]]></title>
      <url>/%E5%B8%B8%E8%A7%81SQL%E8%AF%AD%E5%8F%A5.html</url>
      <content type="html"><![CDATA[<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> employee</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> emp <span class="keyword">where</span> empno=<span class="number">9999</span>;</span><br><span class="line"><span class="keyword">select</span> ename,sal <span class="keyword">from</span> emp ;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> sal &gt; <span class="number">2000</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> deptno = <span class="number">20</span> <span class="keyword">and</span> sal &gt; <span class="number">2000</span> ;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> deptno = <span class="number">20</span> <span class="keyword">or</span> sal &gt; <span class="number">2000</span> ;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> sal <span class="keyword">between</span> <span class="number">1000</span> <span class="keyword">and</span> <span class="number">3000</span> ;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> empno = <span class="number">7788</span> <span class="keyword">or</span> empno = <span class="number">7369</span> <span class="keyword">or</span> empno=<span class="number">7521</span>;</span><br><span class="line">&lt;!---more---&gt;</span><br><span class="line"><span class="comment">-- in</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> empno <span class="keyword">in</span>(<span class="number">7788</span>,<span class="number">7369</span>,<span class="number">7521</span>);</span><br><span class="line"><span class="comment">-- DISTINCT 去重</span></span><br><span class="line"><span class="keyword">select</span> job <span class="keyword">from</span> emp ;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">DISTINCT</span> job <span class="keyword">from</span> emp ;</span><br><span class="line"><span class="comment">-- 别名（字段，表）</span></span><br><span class="line"><span class="keyword">select</span> empno  员工编号,ename 员工姓名 <span class="keyword">from</span> emp ;</span><br><span class="line"><span class="keyword">select</span> ename,sal,sal*<span class="number">1.05</span> 新工资 <span class="keyword">from</span> emp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> ename,sal <span class="keyword">from</span> emp e ;</span><br><span class="line"><span class="keyword">select</span> e.ename,e.sal <span class="keyword">from</span> emp e ;</span><br><span class="line"><span class="comment">-- null 的判断</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> comm <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment">--模糊查询</span></span><br><span class="line"><span class="comment">--查询所有S打头的员工信息（模糊查询） % 代表0到多个字符</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> ename <span class="keyword">like</span> <span class="string">'S%'</span>;</span><br><span class="line"><span class="comment">--查询所有N结尾的</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> ename <span class="keyword">like</span> <span class="string">'%N'</span>;</span><br><span class="line"><span class="comment">--查询所有包含S的</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> ename <span class="keyword">like</span> <span class="string">'%S%'</span>;</span><br><span class="line"><span class="comment">--查询所有第二个字符为L的员工信息</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> ename <span class="keyword">like</span> <span class="string">'__L%'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--排序  (默认升序   order by字段 [asc]  | desc)</span></span><br><span class="line"><span class="comment">--默认  升序</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> sal ;</span><br><span class="line"><span class="comment">--降序</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> sal <span class="keyword">desc</span> ;</span><br><span class="line"><span class="comment">--按照工资的降序排序，如果工资一样的，则按照empno的升序排序(用逗号)</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> sal <span class="keyword">desc</span> , empno <span class="keyword">ASC</span>;</span><br><span class="line"><span class="comment">--限制结果查询（limit m,n)  m代表起始索引，n代表记录的数目,limit 仅适用于MySQL</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">limit</span> <span class="number">5</span>,<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--查询20号部门工资最高的员工的信息</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> deptno = <span class="number">20</span> <span class="keyword">order</span> <span class="keyword">by</span> sal <span class="keyword">desc</span> <span class="keyword">limit</span> <span class="number">0</span>,<span class="number">1</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment">--计算3的15次方</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--数学函数</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">ABS</span>(<span class="number">10</span>);  <span class="comment">--绝对值</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">CEIL</span>(<span class="number">-12.3</span>);   <span class="comment">--向上取整</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">FLOOR</span>(<span class="number">12.5</span>);   <span class="comment">--向下取整</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">ROUND</span>(<span class="number">12.6</span>);   <span class="comment">--四舍五入</span></span><br><span class="line"><span class="keyword">select</span> ROUNT(<span class="number">12.49</span>，<span class="number">1</span>);   </span><br><span class="line"><span class="keyword">select</span> <span class="keyword">POW</span>(<span class="number">3</span>,<span class="number">3</span>);   <span class="comment">--幂运算</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">RAND</span>();     <span class="comment">--随机数[0,1)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">--字符串函数</span></span><br><span class="line">desc emp ;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">LENGTH</span>(ename) <span class="keyword">from</span> emp ;    <span class="comment">--获取字符串长度</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">length</span>(<span class="string">'this is a apple'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">LOWER</span>(ename) <span class="keyword">from</span> emp ;  <span class="comment">--转换为小写</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">UPPER</span>(<span class="string">'this is a page'</span>);   <span class="comment">-- 转换大小写</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">substr</span>(<span class="string">'aabbcc'</span>,<span class="number">1</span>,<span class="number">2</span>);      <span class="comment">-- 从1开始</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">LPAD</span>(<span class="string">'smith'</span>,<span class="number">10</span>,<span class="string">'*'</span>);  <span class="comment">-- 开始字符串，总长度，padstr填充的字符</span></span><br><span class="line"><span class="keyword">select</span> RPAD(<span class="string">'smith'</span>,<span class="number">10</span>,<span class="string">'*'</span>);  <span class="comment">-- 右填充</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">TRIM</span>(<span class="string">'     smi  th'</span>);  <span class="comment">--去空格</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 日期</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">NOW</span>();</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">sysdate</span>();</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">CURRENT_DATE</span>();     <span class="comment">--当前日期</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">current_time</span>();     <span class="comment">--当前时间</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">YEAR</span>(<span class="string">'1998-09-09'</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">MONTH</span>(<span class="string">'1998-09-09'</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">DAY</span>(<span class="string">'1998-09-09'</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">DATE_ADD</span>(<span class="string">'1998-09-09'</span>,<span class="built_in">INTERVAL</span> <span class="number">2</span> <span class="keyword">YEAR</span>);</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student ;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> student <span class="keyword">add</span> birthday <span class="built_in">date</span> <span class="keyword">AFTER</span> age;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 聚合函数</span></span><br><span class="line"><span class="comment">--count /sum/avg/max/min</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 员工数（统计记录数）</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> emp ;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">from</span> emp ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 统计非空字段数目</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(comm) <span class="keyword">from</span> emp;</span><br><span class="line"><span class="comment">-- SUM</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">sum</span>(sal) <span class="keyword">from</span> emp ;</span><br><span class="line"><span class="comment">-- AVG </span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">avg</span>(sal) <span class="keyword">from</span> emp ;</span><br><span class="line"><span class="comment">-- MIN</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">min</span>(sal) <span class="keyword">from</span> emp ;</span><br><span class="line"><span class="comment">-- MAX </span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">max</span>(sal) <span class="keyword">from</span> emp ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 分组函数 GROUP BY deptno</span></span><br><span class="line"><span class="comment">-- 每个部门的平均工资</span></span><br><span class="line"><span class="comment">-- group by 根据条件字段的值返回相应的记录数；但是在select字句中，只能出现聚合函数或者分组的条件字段。</span></span><br><span class="line"><span class="keyword">select</span> deptno, <span class="keyword">avg</span>(sal) <span class="keyword">from</span> emp <span class="keyword">GROUP</span> <span class="keyword">BY</span> deptno ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 各个职位员工数？ job</span></span><br><span class="line"><span class="keyword">select</span> job, <span class="keyword">count</span>(*) <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> job;</span><br><span class="line"><span class="comment">-- 平均工资大于2000的部门的部门编号和平均工资？   where 不能放group by之后，having可以，group by 和having  经常配套使用</span></span><br><span class="line">   <span class="comment">-- 1.求出每个部门的平均工资</span></span><br><span class="line">	 <span class="comment">-- 2.平均工资&gt;2000</span></span><br><span class="line"><span class="keyword">select</span> deptno,<span class="keyword">avg</span>(sal) <span class="keyword">from</span> emp <span class="keyword">GROUP</span> <span class="keyword">BY</span> deptno <span class="keyword">having</span> <span class="keyword">avg</span>(sal) &gt; <span class="number">2000</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- where 和 having 的区别</span></span><br><span class="line"><span class="comment">-- 查询工资大于1500的每个部门的平均工资</span></span><br><span class="line"><span class="keyword">select</span> deptno, <span class="keyword">avg</span>(sal) <span class="keyword">from</span> emp <span class="keyword">where</span> sal &gt; <span class="number">1500</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> deptno ;</span><br><span class="line"><span class="comment">-- 查询平均工资大于1500的部门编号和平均工资</span></span><br><span class="line"><span class="keyword">select</span> deptno,<span class="keyword">avg</span>(sal) <span class="keyword">from</span> emp <span class="keyword">GROUP</span> <span class="keyword">BY</span> deptno <span class="keyword">having</span> <span class="keyword">avg</span>(sal) &gt; <span class="number">1500</span> ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 加密函数</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">MD5</span>(<span class="string">'root'</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">SHA</span>(<span class="string">'root'</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">PASSWORD</span>(<span class="string">'root'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 外键约束： foreign key</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> classroom(</span><br><span class="line">	cid <span class="built_in">int</span> PRIMARY <span class="keyword">key</span>,</span><br><span class="line">	cname <span class="built_in">varchar</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> student <span class="keyword">add</span> <span class="keyword">CONSTRAINT</span> FK_CID FOREIGN <span class="keyword">KEY</span>(cid) <span class="keyword">REFERENCES</span> classroom(cid);</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 高级查询</span></span><br><span class="line"><span class="comment">-- 多表查询</span></span><br><span class="line"><span class="comment">-- 查询的结果集分布于多张表</span></span><br><span class="line"><span class="comment">-- 查询员工编号为7788的员工姓名和部门名称。</span></span><br><span class="line"><span class="comment">-- 内连接 ，注意：1 内连接的结果集与连接顺序无关 2 在多张表中都出现的数据才会出现在内连接的结果集中</span></span><br><span class="line"><span class="keyword">select</span> e.ename,d.dname <span class="keyword">from</span> emp e ,dept d <span class="keyword">where</span> e.empno = <span class="number">7788</span> <span class="keyword">and</span> e.deptno = d.deptno;</span><br><span class="line"><span class="comment">-- inner join ...on....</span></span><br><span class="line"><span class="keyword">select</span> ename,dname <span class="keyword">from</span> emp <span class="keyword">inner</span> <span class="keyword">join</span> dept <span class="keyword">on</span> emp.deptno = dept.deptno ;</span><br><span class="line"><span class="comment">-- inner join ...using... (局限,当deptno不同时)</span></span><br><span class="line"><span class="keyword">select</span> ename,dname  <span class="keyword">from</span> emp <span class="keyword">inner</span> <span class="keyword">join</span> dept <span class="keyword">using</span>(deptno)</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java集合常见面试题]]></title>
      <url>/Java%E9%9B%86%E5%90%88%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98.html</url>
      <content type="html"><![CDATA[<p>　Java集合框架是最常被问到的Java面试问题，要理解Java技术强大特性就有必要掌握集合框架。这里有一些实用问题，常在核心Java面试中问到。</p>
<ol>
<li>什么是Java集合API<br>　　Java集合框架API是用来表示和操作集合的统一框架，它包含接口、实现类、以及帮助程序员完成一些编程的算法。简言之，API在上层完成以下几件事：<br>　　● 编程更加省力，提高城程序速度和代码质量<br>　　● 非关联的API提高互操作性<br>　　● 节省学习使用新API成本<br>　　● 节省设计新API的时间<br>　　● 鼓励、促进软件重用<br>　　具体来说，有6个集合接口，最基本的是Collection接口，由三个接口Set、List、SortedSet继承，另外两个接口是Map、SortedMap，这两个接口不继承Collection，表示映射而不是真正的集合。<a id="more"></a></li>
<li>什么是Iterator<br>　　一些集合类提供了内容遍历的功能，通过java.util.Iterator接口。这些接口允许遍历对象的集合。依次操作每个元素对象。当使用 Iterators时，在获得Iterator的时候包含一个集合快照。通常在遍历一个Iterator的时候不建议修改集合本省。</li>
<li>Iterator与ListIterator有什么区别？<br>　　Iterator：只能正向遍历集合，适用于获取移除元素。ListIerator：继承Iterator，可以双向列表的遍历，同样支持元素的修改。</li>
<li>什么是HaspMap和Map？<br>　　Map是接口，Java 集合框架中一部分，用于存储键值对，HashMap是用哈希算法实现Map的类。</li>
<li>HashMap与HashTable有什么区别？对比Hashtable VS HashMap<br>　　两者都是用key-value方式获取数据。Hashtable是原始集合类之一（也称作遗留类）。HashMap作为新集合框架的一部分在Java2的1.2版本中加入。它们之间有一下区别：<br>　　● HashMap和Hashtable大致是等同的，除了非同步和空值（HashMap允许null值作为key和value，而Hashtable不可以）。<br>　　● HashMap没法保证映射的顺序一直不变，但是作为HashMap的子类LinkedHashMap，如果想要预知的顺序迭代（默认按照插入顺序），你可以很轻易的置换为HashMap，如果使用Hashtable就没那么容易了。<br>　　● HashMap不是同步的，而Hashtable是同步的。<br>　　● 迭代HashMap采用快速失败机制，而Hashtable不是，所以这是设计的考虑点。</li>
<li>在Hashtable上下文中同步是什么意思？<br>　　同步意味着在一个时间点只能有一个线程可以修改哈希表，任何线程在执行hashtable的更新操作前需要获取对象锁，其他线程等待锁的释放。</li>
<li>什么叫做快速失败特性<br>　　从高级别层次来说快速失败是一个系统或软件对于其故障做出的响应。一个快速失败系统设计用来即时报告可能会导致失败的任何故障情况，它通常用来停止正常的操作而不是尝试继续做可能有缺陷的工作。当有问题发生时，快速失败系统即时可见地发错错误告警。在Java中，快速失败与iterators有关。如果一个iterator在集合对象上创建了，其它线程欲“结构化”的修改该集合对象，并发修改异常 （ConcurrentModificationException） 抛出。</li>
<li>怎样使Hashmap同步？<br>　　HashMap可以通过Map m = Collections.synchronizedMap（hashMap）来达到同步的效果。</li>
<li>什么时候使用Hashtable，什么时候使用HashMap<br>　　基本的不同点是Hashtable同步HashMap不是的，所以无论什么时候有多个线程访问相同实例的可能时，就应该使用Hashtable，反之使用HashMap。非线程安全的数据结构能带来更好的性能。<br>　　如果在将来有一种可能—你需要按顺序获得键值对的方案时，HashMap是一个很好的选择，因为有HashMap的一个子类 LinkedHashMap。所以如果你想可预测的按顺序迭代（默认按插入的顺序），你可以很方便用LinkedHashMap替换HashMap。反观要是使用的Hashtable就没那么简单了。同时如果有多个线程访问HashMap，Collections.synchronizedMap（）可以代替，总的来说HashMap更灵活。</li>
<li>为什么Vector类认为是废弃的或者是非官方地不推荐使用？或者说为什么我们应该一直使用ArrayList而不是Vector<br>　　你应该使用ArrayList而不是Vector是因为默认情况下你是非同步访问的，Vector同步了每个方法，你几乎从不要那样做，通常有想要同步的是整个操作序列。同步单个的操作也不安全（如果你迭代一个Vector，你还是要加锁，以避免其它线程在同一时刻改变集合）.而且效率更慢。当然同样有锁的开销即使你不需要，这是个很糟糕的方法在默认情况下同步访问。你可以一直使用Collections.sychronizedList来装饰一个集合。<br>　　事实上Vector结合了“可变数组”的集合和同步每个操作的实现。这是另外一个设计上的缺陷。Vector还有些遗留的方法在枚举和元素获取的方法，这些方法不同于List接口，如果这些方法在代码中程序员更趋向于想用它。尽管枚举速度更快，但是他们不能检查如果集合在迭代的时候修改了，这样将导致问题。尽管以上诸多原因，oracle也从没宣称过要废弃Vector。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java集合体系结构以及集合和数组的区别]]></title>
      <url>/Java%E9%9B%86%E5%90%88%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8A%E9%9B%86%E5%90%88%E5%92%8C%E6%95%B0%E7%BB%84%E7%9A%84%E5%8C%BA%E5%88%AB.html</url>
      <content type="html"><![CDATA[<p>数组和集合的定义<br>一、数组</p>
<p>数组是java语言内置的数据类型，他是一个线性的序列，所有可以快速访问其他的元素，数组和其他语言不同，当你创建了一个数组时，他的容量是不变的，而且在生命周期也是不能改变的，还有JAVA数组会做边界检查，如果发现有越界现象，会报RuntimeException异常错误，当然检查边界会以效率为代价。<br>二、集合</p>
<p>JAVA还提供其他集合，list，map，set，他们处理对象的时候就好像这些对象没有自己的类型一样，而是直接归根于Object，这样只需要创建一个集合，把对象放进去，取出时转换成自己的类型就行了。<br>三、数组和集合的区别<br><a id="more"></a></p>
<p>一、数组声明了它容纳的元素的类型，而集合不声明。<br>二、数组是静态的，一个数组实例具有固定的大小，一旦创建了就无法改变容量了。而集合是可以动态扩展容量，可以根据需要动态改变大小，集合提供更多的成员方法，能满足更多的需求。<br>三、数组的存放的类型只能是一种（基本类型/引用类型）,集合存放的类型可以不是一种(不加泛型时添加的类型是Object)。<br>四、数组是java语言中内置的数据类型,是线性排列的,执行效率或者类型检查都是最快的。<br>集合体系结构</p>
<p>Collection<br>├List （有序集合，允许相同元素和null）<br>│├LinkedList （非同步，允许相同元素和null，遍历效率低插入和删除效率高）<br>│├ArrayList （非同步，允许相同元素和null，实现了动态大小的数组，遍历效率高，用的多）<br>│└Vector（同步，允许相同元素和null，效率低）<br>│　└Stack（继承自Vector，实现一个后进先出的堆栈）<br>└Set （无序集合，不允许相同元素，最多有一个null元素）<br>     |-HashSet(无序集合，不允许相同元素，最多有一个null元素)</p>
<p>Map （没有实现collection接口，key不能重复，value可以重复，一个key映射一个value）<br>├Hashtable （实现Map接口，同步，不允许null作为key和value，用自定义的类当作key的话要复写hashCode和eques方法，）<br>├HashMap （实现Map接口，非同步，允许null作为key和value，用的多）<br>└WeakHashMap（实现Map接口）</p>
<p>Collection接口<br>　　Collection是最基本的集合接口，一个Collection代表一组Object，即Collection的元素（Elements）。一些Collection允许相同的元素而另一些不行。一些能排序而另一些不行。Java SDK不提供直接继承自Collection的类，Java SDK提供的类都是继承自Collection的“子接口”如List和Set。<br>　　所有实现Collection接口的类都必须提供两个标准的构造函数：无参数的构造函数用于创建一个空的Collection，有一个Collection参数的构造函数用于创建一个新的Collection，这个新的Collection与传入的Collection有相同的元素。后一个构造函数允许用户复制一个Collection。<br>　　如何遍历Collection中的每一个元素？不论Collection的实际类型如何，它都支持一个iterator()的方法，该方法返回一个迭代子，使用该迭代子即可逐一访问Collection中每一个元素。典型的用法如下：<br>　　　Iterator it = collection.iterator(); // 获得一个迭代子<br>　　　　while(it.hasNext()) {<br>　　　　　　Object obj = it.next(); // 得到下一个元素<br>　　　　}<br>　　由Collection接口派生的两个接口是List和Set。<br>一、List接口<br>　List是有序的Collection，使用此接口能够精确的控制每个元素插入的位置。用户能够使用索引（元素在List中的位置，类似于数组下标）来访问List中的元素，这类似于Java的数组。<br>和下面要提到的Set不同，List允许有相同的元素。<br>　　除了具有Collection接口必备的iterator()方法外，List还提供一个listIterator()方法，返回一个ListIterator接口，和标准的Iterator接口相比，ListIterator多了一些add()之类的方法，允许添加，删除，设定元素，还能向前或向后遍历。<br>　　实现List接口的常用类有LinkedList，ArrayList，Vector和Stack。<br>LinkedList类<br>　LinkedList实现了List接口，允许null元素。LinkenList底层采用了双向链表来存储数据，每个节点都存储着上一个节点和下一个节点的地址以及本节点的数据。此外LinkedList提供额外的get，remove，insert方法在LinkedList的首部或尾部。这些操作使LinkedList可被用作堆栈（stack），队列（queue）或双向队列（deque）。<br>　　注意：LinkedList没有同步方法。如果多个线程同时访问一个List，则必须自己实现访问同步。一种解决方法是在创建List时构造一个同步的List：<br>　　　　List list = Collections.synchronizedList(new LinkedList(…));<br>ArrayList类<br>　　ArrayList实现了可变大小的数组。它允许所有元素，包括null。ArrayList底层采用动态数组的存储方式，便利效率非常高，ArrayList是线程不安全的。<br>size，isEmpty，get，set方法运行时间为常数。但是add方法开销为分摊的常数，添加n个元素需要O(n)的时间。其他的方法运行时间为线性。<br>　　每个ArrayList实例都有一个容量（Capacity），即用于存储元素的数组的大小。这个容量可随着不断添加新元素而自动增加，但是增长算法并没有定义。当需要插入大量元素时，在插入前可以调用ensureCapacity方法来增加ArrayList的容量以提高插入效率。<br>ArrayList和LindedList的区别：<br>        1.ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。<br>     2.对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。<br>     3.对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。<br>Vector类<br>　　Vector非常类似ArrayList，但是Vector是同步的。由Vector创建的Iterator，虽然和ArrayList创建的Iterator是同一接口，但是，因为Vector是同步的，当一个Iterator被创建而且正在被使用，另一个线程改变了Vector的状态（例如，添加或删除了一些元素），这时调用Iterator的方法时将抛出ConcurrentModificationException，因此必须捕获该异常。<br>Stack 类<br>　　Stack继承自Vector，实现一个后进先出的堆栈。Stack提供5个额外的方法使得Vector得以被当作堆栈使用。基本的push和pop方法，还有peek方法得到栈顶的元素，empty方法测试堆栈是否为空，search方法检测一个元素在堆栈中的位置。Stack刚创建后是空栈。<br>二、Set接口<br>Set是一种无序的并且不包含重复的元素的Collection，即任意的两个元素e1和e2都有e1.equals(e2)=false，Set最多有一个null元素。<br>　　很明显，Set的构造函数有一个约束条件，传入的Collection参数不能包含重复的元素。<br>HashSet 类<br>是哈希表实现的,HashSet中的数据是无序的，可以放入null，但只能放入一个null，两者中的值都不能重复，因为HashSet的底层实现是HashMap，但是HashSet只使用了HashMap的key来存取数据所以HashSet存的数据不能重复。 </p>
<p>HashSet要求放入的对象必须实现HashCode()方法，放入的对象，是以hashcode码作为标识的，而具有相同内容的 String对象，hashcode是一样，所以放入的内容不能重复。但是同一个类的对象可以放入不同的实例 。</p>
<p>三、Map接口<br>Map没有继承Collection接口，Map提供key到value的映射。一个Map中不能包含相同的key，每个key只能映射一个value。Map接口提供3种集合的视图，Map的内容可以被当作一组key集合，一组value集合，或者一组key-value映射。</p>
<p>Hashtable类<br>Hashtable继承Map接口，实现一个key-value映射的哈希表。任何非空（non-null）的对象都可作为key或者value。<br>　　添加数据使用put(key, value)，取出数据使用get(key)，这两个基本操作的时间开销为常数。<br>使用Hashtable的简单示例如下，将1，2，3放到Hashtable中，他们的key分别是”one”，”two”，”three”：<br>Hashtable numbers = new Hashtable();<br>numbers.put(“one”, new Integer(1));<br>numbers.put(“two”, new Integer(2));<br>numbers.put(“three”, new Integer(3));<br>　　要取出一个数，比如2，用相应的key：<br>Integer n = (Integer)numbers.get(“two”);<br>System.out.println(“two = ” + n);<br>　　由于作为key的对象将通过计算其散列函数来确定与之对应的value的位置，因此任何作为key的对象都必须实现hashCode和equals方法。hashCode和equals方法继承自根类Object，如果你用自定义的类当作key的话，要相当小心，按照散列函数的定义，如果两个对象相同，即obj1.equals(obj2)=true，则它们的hashCode必须相同，但如果两个对象不同，则它们的hashCode不一定不同，如果两个不同对象的hashCode相同，这种现象称为冲突，冲突会导致操作哈希表的时间开销增大，所以尽量定义好的hashCode()方法，能加快哈希表的操作。<br>　　如果相同的对象有不同的hashCode，对哈希表的操作会出现意想不到的结果（期待的get方法返回null），要避免这种问题，只需要牢记一条：要同时复写equals方法和hashCode方法，而不要只写其中一个。<br>　　Hashtable是同步的。</p>
<p>HashMap类<br>HashMap和Hashtable类似，不同之处在于HashMap是非同步的，并且允许null，即null value和null key，但是将HashMap视为Collection时（values()方法可返回Collection）。<br>WeakHashMap类<br>WeakHashMap是一种改进的HashMap，它对key实行“弱引用”，如果一个key不再被外部所引用，那么该key可以被GC回收。</p>
<p>总结<br>1.如果涉及到堆栈，队列等操作，应该考虑用List，对于需要快速插入，删除元素，应该使用LinkedList，如果需要快速随机访问元素，应该使用ArrayList。<br>2.如果程序在单线程环境中，或者访问仅仅在一个线程中进行，考虑非同步的类，其效率较高，如果多个线程可能同时操作一个类，应该使用同步的类。<br>3.要特别注意对哈希表的操作，作为key的对象要正确复写equals和hashCode方法。<br>4.尽量返回接口而非实际的类型，如返回List而非ArrayList，这样如果以后需要将ArrayList换成LinkedList时，客户端代码不用改变。这就是针对抽象编程。</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[数据抽象]]></title>
      <url>/%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1.html</url>
      <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>数据抽象结构：对现实世界的一种抽象从实际的人、物、事和概念中抽取所关心的共同特性，忽略非本质的细节，把这些特性用各种概念精确地加以描述这些概念组成了某种模型。</p>
<h2 id="三种常用抽象"><a href="#三种常用抽象" class="headerlink" title="三种常用抽象"></a>三种常用抽象</h2><h3 id="分类（Classification"><a href="#分类（Classification" class="headerlink" title="分类（Classification)"></a>分类（Classification)</h3><p>定义某一类概念作为现实世界中一组对象的类型，这些对象具有某些共同的特性和行为，它抽象了对象值和型之间的“is member of”的语义，在E-R模型中，实体型就是这种抽象。</p>
<h3 id="聚集（Aggregation）"><a href="#聚集（Aggregation）" class="headerlink" title="聚集（Aggregation）"></a>聚集（Aggregation）</h3><p>定义某一类型的组成成分，它抽象了对象内部类型和成分之间“is part of”的语义，在E-R模型中若干属性的聚集组成了实体型，就是这种抽象。<br><a id="more"></a></p>
<h3 id="概括（Generalization）"><a href="#概括（Generalization）" class="headerlink" title="概括（Generalization）"></a>概括（Generalization）</h3><p>定义类型之间的一种子集联系，它抽象了类型之间的“is subset of”的语义，概括有一个很重要的性质：继承性。子类继承超类上定义的所有抽象。<br>注：原E-R模型不具有概括，本书对E-R模型作了扩充，允许定义超类实体型和子类实体型。用双竖边的矩形框表示子类，用直线加小圆圈表示超类-子类的联系</p>
<h2 id="数据抽象的用途"><a href="#数据抽象的用途" class="headerlink" title="数据抽象的用途"></a>数据抽象的用途</h2><p>对需求分析阶段收集到的数据进行分类、组织（聚集），形成实体<br>实体的属性，标识实体的码<br>确定实体之间的联系类型(1:1，1:n，m:n)</p>
<h2 id="类背后蕴含的基本思想是数据抽象和封装"><a href="#类背后蕴含的基本思想是数据抽象和封装" class="headerlink" title="类背后蕴含的基本思想是数据抽象和封装"></a>类背后蕴含的基本思想是数据抽象和封装</h2><p>数据抽象是一种依赖于接口和实现分离的编程和设计技术。类的设计者必须关心类是如何实现的，但是使用该类的程序员不必了解这些细节，仅需抽象地考虑该类型能做什么。<br>封装是一项将低层次的元素组合起来形成新的、高层次实体的技术。函数和类都是封装的形式。被封装的元素隐藏了他们的实现细节，其主要优点在于：避免类内部出现无意的、可能破坏对象状态的用户级错误；使得修改类的实现时只要保持接口不变，就无需改变用户级代码。</p>
]]></content>
      
        <categories>
            
            <category> 干货 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 概念 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java基本数据类型取值范围]]></title>
      <url>/Java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%96%E5%80%BC%E8%8C%83%E5%9B%B4.html</url>
      <content type="html"><![CDATA[<p>在JAVA中一共有八种基本数据类型，他们分别是<br>byte、short、int、long、float、double、char、boolean </p>
<h2 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h2><p>其中byte、short、int、long都是表示整数的，只不过他们的取值范围不一样<br>byte的取值范围为-128~127，占用1个字节（-2的7次方到2的7次方-1）<br>short的取值范围为-32768~32767，占用2个字节（-2的15次方到2的15次方-1）<br>int的取值范围为（-2147483648~2147483647），占用4个字节（-2的31次方到2的31次方-1）<br>long的取值范围为（-9223372036854774808~9223372036854774807），占用8个字节（-2的63次方到2的63次方-1）<br><a id="more"></a><br>可以看到byte和short的取值范围比较小，而long的取值范围太大，占用的空间多，基本上int可以满足我们的日常的计算了，而且int也是使用的最多的整型类型了。<br>在通常情况下，如果JAVA中出现了一个整数数字比如35，那么这个数字就是int型的，如果我们希望它是byte型的，可以在数据后加上大写的 B：35B，表示它是byte型的，同样的35S表示short型，35L表示long型的，表示int我们可以什么都不用加，但是如果要表示long型的，就一定要在数据后面加“L”。 </p>
<h2 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h2><p>float和double是表示浮点型的数据类型，他们之间的区别在于他们的精确度不同<br>float 3.402823e+38 ~ 1.401298e-45（e+38表示是乘以10的38次方，同样，e-45表示乘以10的负45次方）占用4个字节<br>double 1.797693e+308~ 4.9000000e-324 占用8个字节<br>double型比float型存储范围更大，精度更高，所以通常的浮点型的数据在不声明的情况下都是double型的，如果要表示一个数据是float型的，可以在数据后面加上“F”。<br>浮点型的数据是不能完全精确的，所以有的时候在计算的时候可能会在小数点最后几位出现浮动，这是正常的。 </p>
<p>boolean型（布尔型）<br>这个类型只有两个值，true和false（真和非真）<br>boolean t = true；<br>boolean f = false；<br>char型（文本型）<br>用于存放字符的数据类型，占用2个字节，采用unicode编码，它的前128字节编码与ASCII兼容<br>字符的存储范围在\u0000~\uFFFF，在定义字符型的数据时候要注意加’ ‘，比如 ‘1’表示字符’1’而不是数值1，<br>char c = ‘ 1 ‘;<br>我们试着输出c看看，System.out.println(c);结果就是1，而如果我们这样输出呢System.out.println(c+0);<br>结果却变成了49。<br>如果我们这样定义c看看<br>char c = ‘ \u0031 ‘;输出的结果仍然是1，这是因为字符’1’对应着unicode编码就是\u0031<br>char c1 = ‘h’,c2 = ‘e’,c3=’l’,c4=’l’,c5 = ‘o’;<br>System.out.print(c1);System.out.print(c2);System.out.print(c3);System.out.print(c4);Sytem.out.print(c5);</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java基础编程题]]></title>
      <url>/Java%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B%E9%A2%98.html</url>
      <content type="html"><![CDATA[<ol>
<li>把一个数组arr[n]进行反转<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一，思路：利用for循环，只循环n/2-1次，在同一个数组里进行值的交换</span></span><br><span class="line"> <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>,j = arr.length-<span class="number">1</span>; i &lt; arr.length; i++,j--) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">            arr[i] = arr[j];</span><br><span class="line">            arr[j] = temp ;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">3</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">         &lt;!---more---&gt;</span><br><span class="line"><span class="comment">//方法二，思路：重新new一个数组，将原数组逆向赋值给新数组</span></span><br><span class="line"><span class="keyword">int</span>[] arrTemp = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arrTemp[i] = arr[arr.length-i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        arr = arrTemp ;</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line"><span class="comment">//方法三，思路：通过Collections.reverse(list);</span></span><br><span class="line"> ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            list.add(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(list);</span><br><span class="line">        System.out.println( list);</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[自动装箱的陷阱]]></title>
      <url>/%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E7%9A%84%E9%99%B7%E9%98%B1.html</url>
      <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Integer a = <span class="number">1</span>;</span><br><span class="line">Integer b = <span class="number">2</span>;</span><br><span class="line">Integer c = <span class="number">3</span>;</span><br><span class="line">Integer d = <span class="number">3</span>;</span><br><span class="line">Integer e = <span class="number">321</span>;</span><br><span class="line">Integer f = <span class="number">321</span>;</span><br><span class="line">Long g = <span class="number">3L</span>;</span><br><span class="line">System.out.println(c == d);</span><br><span class="line">System.out.println(e == f);</span><br><span class="line">System.out.println(c == (a+b));</span><br><span class="line">System.out.println(c.equals(a+b));</span><br><span class="line">System.out.println(g == (a+b));</span><br><span class="line">System.out.println(g.equals(a+b));</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="输出结果："><a href="#输出结果：" class="headerlink" title="输出结果："></a>输出结果：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure>
<ol>
<li>包装类“==”运算会发生自动拆装箱，在没有算术运算的情况下不会自动拆箱，以及它们的equals()方法不处理数据转型的关系。</li>
<li>自动装箱过程调用了valueOf()的方法，查看valueOf()方法的源码为：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">            <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="comment">// high value may be configured by property</span></span><br><span class="line">            <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">            String integerCacheHighPropValue =</span><br><span class="line">                sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</span><br><span class="line">            <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                    i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                    <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                    h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                    <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            high = h;</span><br><span class="line"></span><br><span class="line">            cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> j = low;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">                cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">            <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong> 通过阅读源代码，可以发现，java内部为了节省内存，IntegerCache类中有一个数组缓存了值从-128到127的Integer对象。当我们调用Integer.valueOf（int i）的时候，如果i的值时结余-128到127之间的，会直接从这个缓存中返回一个对象，否则就new一个新的Integer对象。</strong><br>321&gt;127,所以重新new了一个对象。</p>
<p>典型题目：<br>请提供一个对i和j的声明，将下面的循环转变成为一个无限循环：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(j &lt;= i &amp;&amp; i &lt;= j &amp;&amp; i != j)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>答案：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="number">200</span> ;</span><br><span class="line">Integer j = <span class="number">200</span> ;</span><br><span class="line"> <span class="keyword">while</span>(j&lt;=i &amp;&amp; i&lt;=j &amp;&amp; i!= j)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[二进制、十进制快速转换]]></title>
      <url>/%E4%BA%8C%E8%BF%9B%E5%88%B6%E3%80%81%E5%8D%81%E8%BF%9B%E5%88%B6%E5%BF%AB%E9%80%9F%E8%BD%AC%E6%8D%A2.html</url>
      <content type="html"><![CDATA[<h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>以8位 来演示:</p>
<ol>
<li>第一种:<br>00000001      1<br>00000010      2<br>00000100      4<br>00001000      8<br>00010000      16<br>00100000      32<br>01000000      64<br>10000000      128<a id="more"></a></li>
<li>第二种：<br>00000001      1<br>00000011      3<br>00000111      7<br>00001111      15<br>00011111      31<br>00111111      63<br>01111111      127<br>3.第三种：<br>10000000     128<br>11000000     192<br>11100000     224<br>11110000     240<br>11111000     248<br>11111100     252<br>11111110     254<br>举个例子：  11101011     <pre><code>可分为：
11100000（上面第三种类型）   224
00001000（上面第一种类型）   8
00000011（上面第二种类型）   3
</code></pre><h1 id="我们通过记住上面三种类型的转换，再用加-法（加法口算你会吧）立即得到结果：235"><a href="#我们通过记住上面三种类型的转换，再用加-法（加法口算你会吧）立即得到结果：235" class="headerlink" title="我们通过记住上面三种类型的转换，再用加 法（加法口算你会吧）立即得到结果：235"></a>我们通过记住上面三种类型的转换，再用加 法（加法口算你会吧）立即得到结果：235</h1><h2 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h2>熟记以下排列，其实很Easy了，从右往 左，依次是前一个数的2倍：<br>2^8      2^7     2^6     2^5    2^4   2^3   2^2     2^1    2^0<br>256      128      64       32      16      8        4         2         1<br>随便写个数字比如48<br>48 = 32 + 16,所以在32 和 16所在的位置为1，其余为0，<br>转为2进制就是<br>256  128  64  32  16  8   4   2   1<br>0      0       0    1    1   0   0   0   0</li>
</ol>
<p>二进制转十进制就更简单了，<br>比如随便写的一串 01111101<br>先写上 ：  0         1           1         1         1         1          0          1<br>然后填充 128      64        32       16        8          4          2          1</p>
<p>十进制为 64+32+16+8+4+1=125</p>
]]></content>
      
        <categories>
            
            <category> 系统 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 进制转换 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[DOS下创建文件和文件夹]]></title>
      <url>/DOS%E4%B8%8B%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6%E5%92%8C%E6%96%87%E4%BB%B6%E5%A4%B9.html</url>
      <content type="html"><![CDATA[<h2 id="DOS下创建文件的三种方法"><a href="#DOS下创建文件的三种方法" class="headerlink" title="DOS下创建文件的三种方法"></a>DOS下创建文件的三种方法</h2><p><strong>第一种：</strong></p>
<ol>
<li>echo 内容 &gt; a.txt 重定向输出，此时创建文本文件a.txt </li>
<li>echo 内容 &gt;&gt; a.txt 向a.txt文件中追加信息<br><strong>第二种：</strong><br>copy con a.txt 创建空文本文件a.txt<br>输入完成后，按ctrl+z退出<br><strong>第三种：</strong><br>type nul&gt;filename 可以创建一个名为filename的空文件，在批处理中经常使用<br>copy nul a.txt 可创建一个空文件，如果a.txt已经存在，且有内容，会被清空，在批文件中经常用。<a id="more"></a>
<h2 id="DOS下创建目录的命令"><a href="#DOS下创建目录的命令" class="headerlink" title="DOS下创建目录的命令"></a>DOS下创建目录的命令</h2></li>
<li>创建：md 目录名 或者 mkdir 目录名</li>
<li>删除：rd 目录名 或者rmdir 目录名</li>
<li>删除非空目录： rd /s /q 目录名      <ul>
<li>/s 除目录本身外，还将删除指定目录下的所有子目录和文件,用于删除目录树。</li>
<li>/q 安静模式</li>
<li>/s 删除目录树时不要求确认<h2 id="其他一些命令"><a href="#其他一些命令" class="headerlink" title="其他一些命令"></a>其他一些命令</h2></li>
</ul>
</li>
<li>cmd命令</li>
<li>附件<br>命令：</li>
<li>切换 盘符<br>d: e: f:</li>
<li>查看文件目录清单<br>dir<br>dir  /s 查看所有目录和子目录下的文件目录清单<br>dir /p分屏显示</li>
<li>改变当前目录<br>cd 目录<br>cd.. 回退到上一级目录<br>cd/ 回退到根目录</li>
<li>新建文件夹（目录）<br>md 目录名</li>
<li>新建文件<br>copy con 文件名.扩展名<br>内容<br>ctrl + z</li>
<li>显示文件内容<br>type 文件名.扩展名</li>
<li>复制<br>copy 源文件目录 目标文件目录</li>
<li>重命名<br>ren 原文件名 新文件名</li>
<li>移动<br>move 原文件 目标路径</li>
<li>删除目录<br>rd 目录名<br>但是只能删除 空的目录</li>
<li><p>删除文件<br>del  文件.扩展名<br>del <em>.</em></p>
</li>
<li><p>清屏<br>cls</p>
</li>
<li>退出<br>exit</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 系统 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> DOS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Intellij导出JavaDoc编码异常]]></title>
      <url>/Intellij%E5%AF%BC%E5%87%BAJavaDoc%E7%BC%96%E7%A0%81%E5%BC%82%E5%B8%B8.html</url>
      <content type="html"><![CDATA[<p>Intellij IDEA 导出JavaDoc时编码异常之解决方案。</p>
<p>javac编译提示错误需要为 class、interface 或 enum<br>HelloWorld.java:1: 需要为 class、interface 或 enum<br>锘缝ublic class HelloWorld{<br>^<br>D:\IDE-workspace\src\com\dudefu\www\Test2.java:1: 错误: 非法字符: ‘\ufeff’<br>?package com.dudefu.www;<br><a id="more"></a><br>^<br>D:\IDE-workspace\src\com\dudefu\www\Test2.java:1: 错误: 需要class, interface或enum<br>?package com.dudefu.www;<br>         ^<br>3 错误</p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>这个错误出现的原因主要是在中文操作系统中，使用一贯的“javac HelloWorld.java”方式编译UTF-8（带BOM）编码的.java源文件，在没有指定编码参数（encoding）的情况下，默认是使用GBK编码。当编译器用GBK编码来编译UTF-8文件时，就会把UTF-8（带BOM）编码文件的文件头的占3个字节的头信息，按照GBK中汉字占两个字节、英文占1个字节的特性解码成了“乱码”的两个汉字。这个源文件应该是用记事本另存存为UTF-8编码造成的。<br> 对于非GBK及其子集编码（GB2312）的正确的源文件，编译方式为“javac -encoding “UTF-8” HelloWord.java”，这样代码错误的指定代码里就不会出现乱码的中文。<br> 但是依然会有错误，提示“HelloWorld.java:1: 非法字符: \65279。<br>这是因为.java对于UTF-8编码，只识别UTF-8（不带BOM）那种。而记事本只支持保存文件为带签名的UTF-8，那有没有办法解决呢？<br>当然是有的，那就是使用EmEditor、EditPlus、UltraEdit或Notepad++之类的工具另存为UTF（不带BOM）（区别于带UTF + BOM）的编码文件。这时候使用“javac -encoding “UTF-8” HelloWorld.java”，就没有上述编码问题了。<br>也许有人会说，“我干脆都用GBK不就行了吗，为什么还要用UTF-8呢？”<br>这是因为UTF-8支持世界多种语言的文字，被世界多数国家接受，是国际通用编码，也是Java推荐使用的编码。Java集成开发环境Eclipse中默认编码就是UTF-8。如果使用GBK，尤其是做网站，在非汉语国家，将无法正常浏览。在信息化时代，国际交往日益频繁；做软件和网站，不能只着眼当前，也要为日后维护做优化、降低维护成本。</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Intellij </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java内存区域与内存溢出异常]]></title>
      <url>/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8.html</url>
      <content type="html"><![CDATA[<h2 id="程序运行时，存储数据的五个地方："><a href="#程序运行时，存储数据的五个地方：" class="headerlink" title="程序运行时，存储数据的五个地方："></a>程序运行时，存储数据的五个地方：</h2><p>1）<strong>寄存器</strong> 这是最快的存储区，位于处理器内部。但是，寄存器数量极其有限，所以寄存器根据需求进行分配。你不能直接控制，也不能在程序中感觉到寄存器存在的任何迹象（C和C++允许向编译器建议寄存器的分配方式）。<br>寄存器是存在在cpu上的。而内存是挂在数据总线的，数据总线就是用来决定传输数据的大小。而就是通过在寄存器上的地址来寻找相应内存。总的来说，寄存器和内存是两个东西，程序是无法来控制寄存器，所以这里了解一下就可以了。主要涉及到运行程序涉及到的就是下面这些栈（stack）、堆（heap）、静态域、常量池。<br><a id="more"></a><br>2）<strong>堆栈</strong> 即“栈”，位于通用RAM（随机访问存储器）中，但通过堆栈指针可以从处理器那里获得直接支持。堆栈指针若向下移动，则分配新的内存；若向上移动，则释放那些内存。这是一种快速有效的分配存储方法，仅次于寄存器。创建程序时，Java系统必须知道存储在堆栈内所有项的确切生命周期，以便上下移动堆栈指针。这一约束限制了程序的灵活性，所以虽然某些Java数据存储于堆栈中—–特别是对象引用，但是Java对象并不存储于其中。<br>栈中主要存放一些基本类型的变量（ int, short, long, byte,float, double, boolean, char ）和对象引用。 对象是不会放置在里面的。<br>3）<strong>堆</strong>  一种通用的内存池（位于RAM区），用于存放所有的Java对象，以及动态生成的对象（包括数组）和程序运行时生成的一些数据（包括对象的定义和变量的定义）。堆不同于堆栈的好处是：编译器不需要知道存储的数据在堆里存活多长时间。因此，在堆里分配存储有很大的灵活性。new一个对象，会自动在堆里进行存储分配。 <strong>当然</strong>，为这种灵活性必须付出相应的代价：用堆进行存储分配和清理可能比堆栈进行存储分配需要更多的时间。<br>4）常量存储。常量值通常直接存放在程序代码内部，这样做是安全的，因为它们永远不会被改变。<br>5）<strong>非RAM存储</strong> 比如流对象和持久化对象。在流对象中，对象转化成字节流，通常被发送给另一台机器。在“持久化对象”中，对象被存放磁盘中。这种存储方式的技巧在于：把对象转化成可以存放在其他媒介上的事物，在需要时，可以恢复成常规的、基于RAM的对象。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><strong>数据共享</strong> 这个数据共享主要也是由于引用的是地址来决定的，举个例子：char str1=”str1”;char str2=”str1”;这时候再次声明Str2，同时指定两个不同的引用而相同的变量;这时候并不需要重新开辟另外一份内存，只需要两者都指向相同的地址就可以了。这样数据共享带来的就是内存上的节省。<br><strong>定义和声明</strong> 这里需要对这两个动词进行一些说明。因为在平时过程中，我是对这两个概念比较模糊。一说就是定义声明了一个变量。但是事实上确实不一样的。声明就只是定义这个变量的名字，告诉编译器会有这么一个变量。而定义就不同了，定义就是在声明之后对变量进行初始化、设置一个初始值的过程。如：int i；int i=1；就是这个区别。<br>而在java变量的声明过程中，是不允许没有初始化变量的。<br><strong> Data segment</strong> 这个包括静态域和常量池。<br><strong> 静态域 </strong> 这个就是咱们存放在对象中的静态变量。<br><strong> 常量池</strong> 这个主要是在编译完成后，存放在.class文件中（code segment）。包括一些基本的数据类型和相应的类的接口和声明。换言之就是在编译后，程序中经常使用的不会改变的。例如：基本数据类型（这个是<br>规定，肯定没法改）。接口的命名：这个你肯定不会闲到改改这个来解闷的。</p>
<h2 id="内存分析，java程序执行的过程，一般变量的内存粗存放过程。"><a href="#内存分析，java程序执行的过程，一般变量的内存粗存放过程。" class="headerlink" title="内存分析，java程序执行的过程，一般变量的内存粗存放过程。"></a>内存分析，java程序执行的过程，一般变量的内存粗存放过程。</h2><p><img src="http://ou3xxg3hg.bkt.clouddn.com/Java内存分析.jpg" alt=""><br><strong> 实例：</strong><br>下面通过分析一个例子来说明java变量是怎么存放在内存中的<br>Code segment：arraylistlist[]=new arraylist[2]；<br>Arraylist[0]=2;arraylist[1]=3;arraylist[2]=4;<br>因为list[]是一个变量，这是一个声明我们放到栈中。<br>而后面每个数组实例化出来的变量，所以放到堆中。<br>而实实在在存在的变量的值都是常量，所以放在常量池中，也就是上图中的datasegment。</p>
<h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><p>Java虚拟机在执行Java程序的过程中，会把所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。下图是Java虚拟机运行时数据区：<br><img src="http://ou3xxg3hg.bkt.clouddn.com/Java虚拟机运行时数据区.png" alt="Java虚拟机运行时数据区"><br><!---more---></p>
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。<br>在Java虚拟机中，多线程是通过线程 <strong>轮流切换</strong>并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对多核处理器来说是一个内核）都只会执行一条线程中的命令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类区域为“线程私有”的内存。<br>如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器值则为空（Undefined）。此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</p>
<h2 id="Java虚拟机栈（栈）"><a href="#Java虚拟机栈（栈）" class="headerlink" title="Java虚拟机栈（栈）"></a>Java虚拟机栈（栈）</h2><p>与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。<br>局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。<br>两种异常，如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。</p>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。本地方法栈也会抛出StackOverflowError和OutOfMemoryError异常。</p>
<h1 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h1><p>对大多数应用来说，Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。Java堆是所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。</p>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>Method Area,Non-Heap(非堆)与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><p>运行时常量池（RuntiMe ConStant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用的，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p>
<h2 id="直接内存（Direct-Memory）"><a href="#直接内存（Direct-Memory）" class="headerlink" title="直接内存（Direct Memory）"></a>直接内存（Direct Memory）</h2><p>NIO类引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以 <strong>使用Native函数库直接分配堆外内存</strong>，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提供性能，因为避免了在Java堆和Native堆中来回复制数据。<br>服务器管理员在配置虚拟机参数时，会根据实际内存设置-Xmx等参数信息，但经常忽略直接内存，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统的限制），从而导致动态扩展时出现OutOfMemoryError异常。</p>
<p>在虚拟机中，对象创建对象的过程？？？？<br>虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程，在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。<br>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头）。接下来，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头（Object Header）之中。从虚拟机的视角来看，一个新的对象已经差生了，但从Java程序的视角来看，对象创建才刚刚开始—<init>方法还没有执行，所有的字段都还为零。   所以，一般来说，执行new指令之后会接着执行<init>方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</init></init></p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[面试题：百度前200页都在这里了]]></title>
      <url>/%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E7%99%BE%E5%BA%A6%E5%89%8D200%E9%A1%B5%E9%83%BD%E5%9C%A8%E8%BF%99%E9%87%8C%E4%BA%86.html</url>
      <content type="html"><![CDATA[<p>基本概念<br>操作系统中 heap 和 stack 的区别<br>什么是基于注解的切面实现<br>什么是 对象/关系 映射集成模块<br>什么是 Java 的反射机制<br>什么是 ACID<br>BS与CS的联系与区别<br>Cookie 和 Session的区别<br>fail-fast 与 fail-safe 机制有什么区别<br>get 和 post请求的区别<br>Interface 与 abstract 类的区别<br>IOC的优点是什么<br><a id="more"></a><br>IO 和 NIO的区别，NIO优点<br>Java 8 / Java 7 为我们提供了什么新功能<br>什么是竞态条件？ 举个例子说明。<br>JRE、JDK、JVM 及 JIT 之间有什么不同<br>MVC的各个部分都有那些技术来实现?如何实现?<br>RPC 通信和 RMI 区别<br>什么是 Web Service（Web服务）<br>JSWDL开发包的介绍。JAXP、JAXM的解释。SOAP、UDDI,WSDL解释。<br>WEB容器主要有哪些功能? 并请列出一些常见的WEB容器名字。<br>一个”.java”源文件中是否可以包含多个类（不是内部类）？有什么限制<br>简单说说你了解的类加载器。是否实现过类加载器<br>解释一下什么叫AOP（面向切面编程）<br>请简述 Servlet 的生命周期及其相关的方法<br>请简述一下 Ajax 的原理及实现步骤<br>简单描述Struts的主要功能<br>什么是 N 层架构<br>什么是CORBA？用途是什么<br>什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”<br>什么是正则表达式？用途是什么？哪个包使用正则表达式来实现模式匹配<br>什么是懒加载（Lazy Loading）<br>什么是尾递归，为什么需要尾递归<br>什么是控制反转（Inversion of Control）与依赖注入（Dependency Injection）<br>关键字</p>
<p>finalize</p>
<p>什么是finalize()方法<br>finalize()方法什么时候被调用<br>析构函数(finalization)的目的是什么<br>final 和 finalize 的区别<br>final<br>final关键字有哪些用法<br>final 与 static 关键字可以用于哪里？它们的作用是什么<br>final, finally, finalize的区别<br>final、finalize 和 finally 的不同之处？<br>能否在运行时向 static final 类型的赋值<br>使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变<br>一个类被声明为final类型，表示了什么意思<br>throws, throw, try, catch, finally分别代表什么意义<br>Java 有几种修饰符？分别用来修饰什么<br>volatile</p>
<p>volatile 修饰符的有过什么实践<br>volatile 变量是什么？volatile 变量和 atomic 变量有什么不同<br>volatile 类型变量提供什么保证？能使得一个非原子操作变成原子操作吗<br>能创建 volatile 数组吗？<br>transient变量有什么特点<br>super什么时候使用<br>public static void 写成 static public void会怎样<br>说明一下public static void main(String args[])这段声明里每个关键字的作用<br>请说出作用域public, private, protected, 以及不写时的区别<br>sizeof 是Java 的关键字吗<br>static</p>
<p>static class 与 non static class的区别<br>static 关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法<br>静态类型有什么特点<br>main() 方法为什么必须是静态的？能不能声明 main() 方法为非静态<br>是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用<br>静态变量在什么时候加载？编译期还是运行期？静态代码块加载的时机呢<br>成员方法是否可以访问静态变量？为什么静态方法不能访问成员变量<br>switch</p>
<p>switch 语句中的表达式可以是什么类型数据<br>switch 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上<br>while 循环和 do 循环有什么不同<br>操作符</p>
<p>&amp;操作符和&amp;&amp;操作符有什么区别?<br>a = a + b 与 a += b 的区别？<br>逻辑操作符 (&amp;,|,^)与条件操作符(&amp;&amp;,||)的区别<br>3*0.1 == 0.3 将会返回什么？true 还是 false？<br>float f=3.4; 是否正确？<br>short s1 = 1; s1 = s1 + 1;有什么错?<br>数据结构</p>
<p>基础类型(Primitives)</p>
<p>基础类型(Primitives)与封装类型(Wrappers)的区别在哪里<br>简述九种基本数据类型的大小，以及他们的封装类<br>int 和 Integer 哪个会占用更多的内存？ int 和 Integer 有什么区别？parseInt()函数在什么时候使用到<br>float和double的默认值是多少<br>如何去小数四舍五入保留小数点后两位<br>char 型变量中能不能存贮一个中文汉字，为什么<br>类型转换</p>
<p>怎样将 bytes 转换为 long 类型<br>怎么将 byte 转换为 String<br>如何将数值型字符转换为数字<br>我们能将 int 强制转换为 byte 类型的变量吗？如果该值大于 byte 类型的范围，将会出现什么现象<br>能在不进行强制转换的情况下将一个 double 值赋值给 long 类型的变量吗<br>类型向下转换是什么<br>数组</p>
<p>如何权衡是使用无序的数组还是有序的数组<br>怎么判断数组是 null 还是为空<br>怎么打印数组？ 怎样打印数组中的重复元素<br>Array 和 ArrayList有什么区别？什么时候应该使用Array而不是ArrayList<br>数组和链表数据结构描述，各自的时间复杂度<br>数组有没有length()这个方法? String有没有length()这个方法<br>队列</p>
<p>队列和栈是什么，列出它们的区别<br>BlockingQueue是什么<br>简述 ConcurrentLinkedQueue LinkedBlockingQueue 的用处和不同之处。<br>ArrayList、Vector、LinkedList的存储性能和特性<br>String<br>StringBuffer</p>
<p>ByteBuffer 与 StringBuffer有什么区别<br>HashMap</p>
<p>HashMap的工作原理是什么<br>内部的数据结构是什么<br>HashMap 的 table的容量如何确定？loadFactor 是什么？ 该容量如何变化？这种变化会带来什么问题？<br>HashMap 实现的数据结构是什么？如何实现<br>HashMap 和 HashTable、ConcurrentHashMap 的区别<br>HashMap的遍历方式及效率<br>HashMap、LinkedMap、TreeMap的区别<br>如何决定选用HashMap还是TreeMap<br>如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办<br>HashMap 是线程安全的吗？并发下使用的 Map 是什么，它们内部原理分别是什么，比如存储方式、 hashcode、扩容、 默认容量等<br>HashSet</p>
<p>HashSet和TreeSet有什么区别<br>HashSet 内部是如何工作的<br>WeakHashMap 是怎么工作的？<br>Set</p>
<p>Set 里的元素是不能重复的，那么用什么方法来区分重复与否呢？是用 == 还是 equals()？ 它们有何区别?<br>TreeMap：TreeMap 是采用什么树实现的？TreeMap、HashMap、LindedHashMap的区别。TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort()方法如何比较元素？<br>TreeSet：一个已经构建好的 TreeSet，怎么完成倒排序。<br>EnumSet 是什么<br>Hash算法</p>
<p>Hashcode 的作用<br>简述一致性 Hash 算法<br>有没有可能 两个不相等的对象有相同的 hashcode？当两个对象 hashcode 相同怎么办？如何获取值对象<br>为什么在重写 equals 方法的时候需要重写 hashCode 方法？equals与 hashCode 的异同点在哪里<br>a.hashCode() 有什么用？与 a.equals(b) 有什么关系<br>hashCode() 和 equals() 方法的重要性体现在什么地方<br>Object：Object有哪些公用方法？Object类hashcode,equals 设计原则？ sun为什么这么设计？Object类的概述<br>如何在父类中为子类自动完成所有的 hashcode 和 equals 实现？这么做有何优劣。<br>可以在 hashcode() 中使用随机数字吗？<br>LinkedHashMap</p>
<p>LinkedHashMap 和 PriorityQueue 的区别是什么<br>List</p>
<p>List, Set, Map三个接口，存取元素时各有什么特点<br>List, Set, Map 是否继承自 Collection 接口<br>遍历一个 List 有哪些不同的方式<br>LinkedList<br>LinkedList 是单向链表还是双向链表<br>LinkedList 与 ArrayList 有什么区别<br>描述下 Java 中集合（Collections），接口（Interfaces），实现（Implementations）的概念。LinkedList 与 ArrayList 的区别是什么？<br>插入数据时，ArrayList, LinkedList, Vector谁速度较快？<br>ArrayList<br>ArrayList 和 HashMap 的默认大小是多数<br>ArrayList 和 LinkedList 的区别，什么时候用 ArrayList？<br>ArrayList 和 Set 的区别？<br>ArrayList, LinkedList, Vector的区别<br>ArrayList是如何实现的，ArrayList 和 LinkedList 的区别<br>ArrayList如何实现扩容<br>Array 和 ArrayList 有何区别？什么时候更适合用Array<br>说出ArraList,Vector, LinkedList的存储性能和特性<br>Map</p>
<p>Map, Set, List, Queue, Stack<br>Map 接口提供了哪些不同的集合视图<br>为什么 Map 接口不继承 Collection 接口<br>Collections</p>
<p>介绍Java中的Collection FrameWork。集合类框架的基本接口有哪些<br>Collections类是什么？Collection 和 Collections的区别？Collection、Map的实现<br>集合类框架的最佳实践有哪些<br>为什么 Collection 不从 Cloneable 和 Serializable 接口继承<br>说出几点 Java 中使用 Collections 的最佳实践？<br>Collections 中 遗留类 (HashTable、Vector) 和 现有类的区别<br>什么是 B+树，B-树，列出实际的使用场景。</p>
<p>接口</p>
<p>Comparator 与 Comparable 接口是干什么的？列出它们的区别<br>对象</p>
<p>拷贝(clone)</p>
<p>如何实现对象克隆<br>深拷贝和浅拷贝区别<br>深拷贝和浅拷贝如何实现激活机制<br>写clone()方法时，通常都有一行代码，是什么<br>比较</p>
<p>在比较对象时，”==” 运算符和 equals 运算有何区别<br>如果要重写一个对象的equals方法，还要考虑什么<br>两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对<br>构造器</p>
<p>构造器链是什么<br>创建对象时构造器的调用顺序<br>不可变对象</p>
<p>什么是不可变象（immutable object）<br>为什么 Java 中的 String 是不可变的（Immutable）<br>如何构建不可变的类结构？关键点在哪里<br>能创建一个包含可变对象的不可变对象吗<br>如何对一组对象进行排序</p>
<p>方法</p>
<p>构造器（constructor）是否可被重写（override）<br>方法可以同时即是 static 又是 synchronized 的吗<br>abstract 的 method是否可同时是 static，是否可同时是 native，是否可同时是synchronized<br>Java支持哪种参数传递类型<br>一个对象被当作参数传递到一个方法，是值传递还是引用传递<br>当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递<br>我们能否重载main()方法<br>如果main方法被声明为private会怎样<br>GC</p>
<p>概念</p>
<p>GC是什么？为什么要有GC<br>什么时候会导致垃圾回收<br>GC是怎么样运行的<br>新老以及永久区是什么<br>GC 有几种方式？怎么配置<br>什么时候一个对象会被GC？ 如何判断一个对象是否存活<br>System.gc() Runtime.gc()会做什么事情？ 能保证 GC 执行吗<br>垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？<br>Minor GC 、Major GC、Young GC 与 Full GC分别在什么时候发生<br>垃圾回收算法的实现原理<br>如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？<br>垃圾回收的最佳做法是什么<br>GC收集器有哪些</p>
<p>垃圾回收器的基本原理是什么？<br>串行(serial)收集器和吞吐量(throughput)收集器的区别是什么<br>Serial 与 Parallel GC之间的不同之处<br>CMS 收集器 与 G1 收集器的特点与区别<br>CMS垃圾回收器的工作过程<br>JVM 中一次完整的 GC 流程是怎样的？ 对象如何晋升到老年代<br>吞吐量优先和响应优先的垃圾收集器选择<br>GC策略</p>
<p>举个实际的场景，选择一个GC策略<br>JVM的永久代中会发生垃圾回收吗<br>收集方法</p>
<p>标记清除、标记整理、复制算法的原理与特点？分别用在什么地方<br>如果让你优化收集方法，有什么思路<br>JVM</p>
<p>参数</p>
<p>说说你知道的几种主要的jvm 参数<br>-XX:+UseCompressedOops 有什么作用<br>类加载器(ClassLoader)</p>
<p>Java 类加载器都有哪些<br>JVM如何加载字节码文件<br>内存管理</p>
<p>JVM内存分哪几个区，每个区的作用是什么<br>一个对象从创建到销毁都是怎么在这些部分里存活和转移的<br>解释内存中的栈(stack)、堆(heap)和方法区(method area)的用法<br>JVM中哪个参数是用来控制线程的栈堆栈小<br>简述内存分配与回收策略<br>简述重排序，内存屏障，happen-before，主内存，工作内存<br>Java中存在内存泄漏问题吗？请举例说明<br>简述 Java 中软引用（SoftReferenc）、弱引用（WeakReference）和虚引用<br>内存映射缓存区是什么<br>jstack，jstat，jmap，jconsole怎么用<br>32 位 JVM 和 64 位 JVM 的最大堆内存分别是多数？32 位和 64 位的 JVM，int 类型变量的长度是多数？<br>怎样通过 Java 程序来判断 JVM 是 32 位 还是 64 位<br>JVM自身会维护缓存吗？是不是在堆中进行对象分配，操作系统的堆还是JVM自己管理堆<br>什么情况下会发生栈内存溢出<br>双亲委派模型是什么</p>
<p>多线程</p>
<p>基本概念</p>
<p>什么是线程<br>多线程的优点<br>多线程的几种实现方式<br>用 Runnable 还是 Thread<br>什么是线程安全<br>Vector, SimpleDateFormat 是线程安全类吗<br>什么 Java 原型不是线程安全的<br>哪些集合类是线程安全的<br>多线程中的忙循环是什么<br>如何创建一个线程<br>编写多线程程序有几种实现方式<br>什么是线程局部变量<br>线程和进程有什么区别？进程间如何通讯，线程间如何通讯<br>什么是多线程环境下的伪共享（false sharing）<br>同步和异步有何异同，在什么情况下分别使用他们？举例说明<br>Current</p>
<p>ConcurrentHashMap 和 Hashtable的区别<br>ArrayBlockingQueue, CountDownLatch的用法<br>ConcurrentHashMap的并发度是什么<br>CyclicBarrier 和 CountDownLatch有什么不同？各自的内部原理和用法是什么<br>Semaphore的用法<br>Thread</p>
<p>启动一个线程是调用 run() 还是 start() 方法？start() 和 run() 方法有什么区别<br>调用start()方法时会执行run()方法，为什么不能直接调用run()方法<br>sleep() 方法和对象的 wait() 方法都可以让线程暂停执行，它们有什么区别<br>yield方法有什么作用？sleep() 方法和 yield() 方法有什么区别<br>Java 中如何停止一个线程<br>stop() 和 suspend() 方法为何不推荐使用<br>如何在两个线程间共享数据<br>如何强制启动一个线程<br>如何让正在运行的线程暂停一段时间<br>什么是线程组，为什么在Java中不推荐使用<br>你是如何调用 wait（方法的）？使用 if 块还是循环？为什么<br>生命周期</p>
<p>有哪些不同的线程生命周期<br>线程状态，BLOCKED 和 WAITING 有什么区别<br>画一个线程的生命周期状态图<br>ThreadLocal 用途是什么，原理是什么，用的时候要注意什么<br>ThreadPool</p>
<p>线程池是什么？为什么要使用它<br>如何创建一个Java线程池<br>ThreadPool用法与优势<br>提交任务时，线程池队列已满时会发会生什么<br>newCache 和 newFixed 有什么区别？简述原理。构造函数的各个参数的含义是什么，比如 coreSize, maxsize 等<br>线程池的实现策略<br>线程池的关闭方式有几种，各自的区别是什么<br>线程池中submit() 和 execute()方法有什么区别？<br>线程调度</p>
<p>Java中用到的线程调度算法是什么<br>什么是多线程中的上下文切换<br>你对线程优先级的理解是什么<br>什么是线程调度器 (Thread Scheduler) 和时间分片 (Time Slicing)<br>线程同步</p>
<p>请说出你所知的线程同步的方法<br>synchronized 的原理是什么<br>synchronized 和 ReentrantLock 有什么不同<br>什么场景下可以使用 volatile 替换 synchronized<br>有T1，T2，T3三个线程，怎么确保它们按顺序执行？怎样保证T2在T1执行完后执行，T3在T2执行完后执行<br>同步块内的线程抛出异常会发生什么<br>当一个线程进入一个对象的 synchronized 方法A 之后，其它线程是否可进入此对象的 synchronized 方法B<br>使用 synchronized 修饰静态方法和非静态方法有什么区别<br>如何从给定集合那里创建一个 synchronized 的集合<br>锁</p>
<p>Java Concurrency API 中 的 Lock 接口是什么？对比同步它有什么优势<br>Lock 与 Synchronized 的区别？Lock 接口比 synchronized 块的优势是什么<br>ReadWriteLock是什么？<br>锁机制有什么用<br>什么是乐观锁（Optimistic Locking）？如何实现乐观锁？如何避免ABA问题<br>解释以下名词：重排序，自旋锁，偏向锁，轻量级锁，可重入锁，公平锁，非公平锁，乐观锁，悲观锁<br>什么时候应该使用可重入锁<br>简述锁的等级方法锁、对象锁、类锁<br>Java中活锁和死锁有什么区别？<br>什么是死锁(Deadlock)？导致线程死锁的原因？如何确保 N 个线程可以访问 N 个资源同时又不导致死锁<br>死锁与活锁的区别，死锁与饥饿的区别<br>怎么检测一个线程是否拥有锁<br>如何实现分布式锁<br>有哪些无锁数据结构，他们实现的原理是什么<br>读写锁可以用于什么应用场景<br>Executors类是什么？ Executor和Executors的区别<br>什么是Java线程转储(Thread Dump)，如何得到它<br>如何在Java中获取线程堆栈<br>说出 3 条在 Java 中使用线程的最佳实践<br>在线程中你怎么处理不可捕捉异常<br>实际项目中使用多线程举例。你在多线程环境中遇到的常见的问题是什么？你是怎么解决它的<br>请说出与线程同步以及线程调度相关的方法<br>程序中有3个 socket，需要多少个线程来处理<br>假如有一个第三方接口，有很多个线程去调用获取数据，现在规定每秒钟最多有 10 个线程同时调用它，如何做到<br>如何在 Windows 和 Linux 上查找哪个线程使用的 CPU 时间最长<br>如何确保 main() 方法所在的线程是 Java 程序最后结束的线程<br>非常多个线程（可能是不同机器），相互之间需要等待协调才能完成某种工作，问怎么设计这种协调方案<br>你需要实现一个高效的缓存，它允许多个用户读，但只允许一个用户写，以此来保持它的完整性，你会怎样去实现它</p>
<p>异常</p>
<p>基本概念</p>
<p>Error 和 Exception有什么区别<br>UnsupportedOperationException是什么<br>NullPointerException 和 ArrayIndexOutOfBoundException 之间有什么相同之处<br>什么是受检查的异常，什么是运行时异常<br>运行时异常与一般异常有何异同<br>简述一个你最常见到的runtime exception(运行时异常)<br>finally</p>
<p>finally关键词在异常处理中如何使用<br>如果执行finally代码块之前方法返回了结果，或者JVM退出了，finally块中的代码还会执行吗<br>try里有return，finally还执行么？那么紧跟在这个try后的finally {}里的code会不会被执行，什么时候被执行，在return前还是后<br>在什么情况下，finally语句不会执行<br>throw 和 throws 有什么区别？<br>OOM你遇到过哪些情况？你是怎么搞定的？<br>SOF你遇到过哪些情况？<br>既然我们可以用RuntimeException来处理错误，那么你认为为什么Java中还存在检查型异常<br>当自己创建异常类的时候应该注意什么<br>导致空指针异常的原因<br>异常处理 handle or declare 原则应该如何理解<br>怎么利用 JUnit 来测试一个方法的异常<br>catch块里别不写代码有什么问题<br>你曾经自定义实现过异常吗？怎么写的<br>什么是 异常链<br>在try块中可以抛出异常吗</p>
<p>JDBC</p>
<p>通过 JDBC 连接数据库有哪几种方式<br>阐述 JDBC 操作数据库的基本步骤<br>JDBC 中如何进行事务处理<br>什么是 JdbcTemplate<br>什么是 DAO 模块<br>使用 JDBC 操作数据库时，如何提升读取数据的性能？如何提升更新数据的性能<br>列出 5 个应该遵循的 JDBC 最佳实践<br>IO</p>
<p>File<br>File类型中定义了什么方法来创建一级目录<br>File类型中定义了什么方法来判断一个文件是否存在</p>
<p>流<br>为了提高读写性能，可以采用什么流<br>Java中有几种类型的流<br>JDK 为每种类型的流提供了一些抽象类以供继承，分别是哪些类<br>对文本文件操作用什么I/O流<br>对各种基本数据类型和String类型的读写，采用什么流<br>能指定字符编码的 I/O 流类型是什么<br>序列化<br>什么是序列化？如何实现 Java 序列化及注意事项<br>Serializable 与 Externalizable 的区别<br>Socket<br>socket 选项 TCP NO DELAY 是指什么<br>Socket 工作在 TCP/IP 协议栈是哪一层<br>TCP、UDP 区别及 Java 实现方式<br>说几点 IO 的最佳实践<br>直接缓冲区与非直接缓冲器有什么区别？<br>怎么读写 ByteBuffer？ByteBuffer 中的字节序是什么<br>当用System.in.read(buffer)从键盘输入一行n个字符后，存储在缓冲区buffer中的字节数是多少<br>如何使用扫描器类（Scanner Class）令牌化<br>面向对象编程（OOP）</p>
<p>解释下多态性（polymorphism），封装性（encapsulation），内聚（cohesion）以及耦合（coupling）<br>多态的实现原理<br>封装、继承和多态是什么<br>对象封装的原则是什么?<br>类<br>获得一个类的类对象有哪些方式<br>重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？<br>说出几条 Java 中方法重载的最佳实践<br>抽象类<br>抽象类和接口的区别<br>抽象类中是否可以有静态的main方法<br>抽象类是否可实现(implements)接口<br>抽象类是否可继承具体类(concrete class)<br>匿名类（Anonymous Inner Class）<br>匿名内部类是否可以继承其它类？是否可以实现接口</p>
<p>内部类<br>内部类分为几种<br>内部类可以引用它的包含类（外部类）的成员吗<br>请说一下 Java 中为什么要引入内部类？还有匿名内部类<br>继承<br>继承（Inheritance）与聚合（Aggregation）的区别在哪里<br>继承和组合之间有什么不同<br>为什么类只能单继承，接口可以多继承<br>存在两个类，B 继承 A，C 继承 B，能将 B 转换为 C 么？如 C = (C) B<br>如果类 a 继承类 b，实现接口c，而类 b 和接口 c 中定义了同名变量，请问会出现什么问题<br>接口<br>接口是什么<br>接口是否可继承接口<br>为什么要使用接口而不是直接使用具体类？接口有什么优点<br>泛型</p>
<p>泛型的存在是用来解决什么问题<br>泛型的常用特点<br>List能否转为List<br>工具类</p>
<p>日历<br>Calendar Class的用途<br>如何在Java中获取日历类的实例<br>解释一些日历类中的重要方法<br>GregorianCalendar 类是什么<br>SimpleTimeZone 类是什么<br>Locale类是什么<br>如何格式化日期对象<br>如何添加小时(hour)到一个日期对象(Date Objects)<br>如何将字符串 YYYYMMDD 转换为日期<br>Math<br>Math.round()什么作用？Math.round(11.5) 等于多少？Math.round(-11.5)等于多少？</p>
<p>XML<br>XML文档定义有几种形式？它们之间有何本质区别？解析XML文档有哪几种方式？DOM 和 SAX 解析器有什么不同？<br>Java解析XML的方式<br>用 jdom 解析 xml 文件时如何解决中文问题？如何解析<br>你在项目中用到了 XML 技术的哪些方面？如何实现<br>动态代理</p>
<p>描述动态代理的几种实现方式，分别说出相应的优缺点<br>设计模式</p>
<p>什么是设计模式（Design Patterns）？你用过哪种设计模式？用在什么场合<br>你知道哪些商业级设计模式？<br>哪些设计模式可以增加系统的可扩展性<br>单例模式<br>除了单例模式，你在生产环境中还用过什么设计模式？<br>写 Singleton 单例模式<br>单例模式的双检锁是什么<br>如何创建线程安全的 Singleton<br>什么是类的单例模式<br>写出三种单例模式实现<br>适配器模式<br>适配器模式是什么？什么时候使用<br>适配器模式和代理模式之前有什么不同<br>适配器模式和装饰器模式有什么区别<br>什么时候使用享元模式<br>什么时候使用组合模式<br>什么时候使用访问者模式<br>什么是模板方法模式<br>请给出1个符合开闭原则的设计模式的例子<br>开放问题</p>
<p>用一句话概括 Web 编程的特点<br>Google是如何在一秒内把搜索结果返回给用户<br>哪种依赖注入方式你建议使用，构造器注入，还是 Setter方法注入<br>树（二叉或其他）形成许多普通数据结构的基础。请描述一些这样的数据结构以及何时可以使用它们<br>某一项功能如何设计<br>线上系统突然变得异常缓慢，你如何查找问题<br>什么样的项目不适合用框架<br>新浪微博是如何实现把微博推给订阅者<br>简要介绍下从浏览器输入 URL 开始到获取到请求界面之后 Java Web 应用中发生了什么<br>请你谈谈SSH整合<br>高并发下，如何做到安全的修改同一行数据<br>12306网站的订票系统如何实现，如何保证不会票不被超卖<br>网站性能优化如何优化的<br>聊了下曾经参与设计的服务器架构<br>请思考一个方案，实现分布式环境下的 countDownLatch<br>请思考一个方案，设计一个可以控制缓存总体大小的自动适应的本地缓存<br>在你的职业生涯中，算得上最困难的技术挑战是什么<br>如何写一篇设计文档，目录是什么<br>大写的O是什么？举几个例子<br>编程中自己都怎么考虑一些设计原则的，比如开闭原则，以及在工作中的应用<br>解释一下网络应用的模式及其特点<br>设计一个在线文档系统，文档可以被编辑，如何防止多人同时对同一份文档进行编辑更新<br>说出数据连接池的工作机制是什么<br>怎么获取一个文件中单词出现的最高频率<br>描述一下你最常用的编程风格<br>如果有机会重新设计你们的产品，你会怎么做<br>如何搭建一个高可用系统<br>如何启动时不需输入用户名与密码<br>如何在基于Java的Web项目中实现文件上传和下载<br>如何实现一个秒杀系统，保证只有几位用户能买到某件商品。<br>如何实现负载均衡，有哪些算法可以实现<br>如何设计一个购物车？想想淘宝的购物车如何实现的<br>如何设计一套高并发支付方案，架构如何设计<br>如何设计建立和保持 100w 的长连接<br>如何避免浏览器缓存。<br>如何防止缓存雪崩<br>如果AB两个系统互相依赖，如何解除依<br>如果有人恶意创建非法连接，怎么解决<br>如果有几十亿的白名单，每天白天需要高并发查询，晚上需要更新一次，如何设计这个功能<br>如果系统要使用超大整数（超过long长度范围），请你设计一个数据结构来存储这种超大型数字以及设计一种算法来实现超大整数加法运算）<br>如果要设计一个图形系统，请你设计基本的图形元件(Point,Line,Rectangle,Triangle)的简单实现<br>如果让你实现一个并发安全的链表，你会怎么做<br>应用服务器与WEB 服务器的区别？应用服务器怎么监控性能，各种方式的区别？你使用过的应用服务器优化技术有哪些<br>大型网站在架构上应当考虑哪些问题<br>有没有处理过线上问题？出现内存泄露，CPU利用率标高，应用无响应时如何处理的<br>最近看什么书，印象最深刻的是什么<br>描述下常用的重构技巧<br>你使用什么版本管理工具？分支（Branch）与标签（Tag）之间的区别在哪里<br>你有了解过存在哪些反模式（Anti-Patterns）吗<br>你用过的网站前端优化的技术有哪些<br>如何分析Thread dump<br>你如何理解AOP中的连接点（Joinpoint）、切点（Pointcut）、增强（Advice）、引介（Introduction）、织入（Weaving）、切面（Aspect）这些概念<br>你是如何处理内存泄露或者栈溢出问题的<br>你们线上应用的 JVM 参数有哪些<br>怎么提升系统的QPS和吞吐量<br>知识面</p>
<p>解释什么是 MESI 协议(缓存一致性)<br>谈谈 reactor 模型<br>Java 9 带来了怎样的新功能<br>Java 与 C++ 对比，C++ 或 Java 中的异常处理机制的简单原理和应用<br>简单讲讲 Tomcat 结构，以及其类加载器流程<br>虚拟内存是什么<br>阐述下 SOLID 原则<br>请简要讲一下你对测试驱动开发（TDD）的认识<br>CDN实现原理<br>Maven 和 ANT 有什么区别<br>UML中有哪些常用的图<br>Linux<br>Linux 下 IO 模型有几种，各自的含义是什么。<br>Linux 系统下你关注过哪些内核参数，说说你知道的<br>Linux 下用一行命令查看文件的最后五行<br>平时用到哪些 Linux 命令<br>用一行命令输出正在运行的 Java 进程<br>使用什么命令来确定是否有 Tomcat 实例运行在机器上<br>什么是 N+1 难题<br>什么是 paxos 算法<br>什么是 restful，讲讲你理解的 restful<br>什么是 zab 协议<br>什么是领域模型(domain model)？贫血模型(anaemic domain model) 和充血模型(rich domain model)有什么区别<br>什么是领域驱动开发（Domain Driven Development）<br>介绍一下了解的 Java 领域的 Web Service 框架<br>Web Server、Web Container 与 Application Server 的区别是什么<br>微服务（MicroServices）与巨石型应用（Monolithic Applications）之间的区别在哪里<br>描述 Cookie 和 Session 的作用，区别和各自的应用范围，Session工作原理<br>你常用的持续集成（Continuous Integration）、静态代码分析（Static Code Analysis）工具有哪些<br>简述下数据库正则化（Normalizations）<br>KISS,DRY,YAGNI 等原则是什么含义<br>分布式事务的原理，优缺点，如何使用分布式事务？<br>布式集群下如何做到唯一序列号<br>网络<br>HTTPS 的加密方式是什么，讲讲整个加密解密流程<br>HTTPS和HTTP的区别<br>HTTP连接池实现原理<br>HTTP集群方案<br>Nginx、lighttpd、Apache三大主流 Web服务器的区别<br>是否看过框架的一些代码<br>持久层设计要考虑的问题有哪些？你用过的持久层框架有哪些<br>数值提升是什么<br>你能解释一下里氏替换原则吗<br>你是如何测试一个应用的？知道哪些测试框架<br>传输层常见编程协议有哪些？并说出各自的特点<br>编程题</p>
<p>计算加班费</p>
<p>加班10小时以下加班费是时薪的1.5倍。加班10小时或以上，按4元/时算。提示：（一个月工作26天，一天正常工作8小时）</p>
<p>计算1000月薪，加班9小时的加班费<br>计算2500月薪，加班11小时的加班费<br>计算1000月薪，加班15小时的加班费<br>卖东西</p>
<p>一家商场有红苹果和青苹果出售。（红苹果5元/个，青苹果4元/个）。</p>
<p>模拟一个进货。红苹果跟青苹果各进200个。<br>模拟一个出售。红苹果跟青苹果各买出10个。每卖出一个苹果需要进行统计。<br>提示：一个苹果是一个单独的实体。</p>
<p>日期提取</p>
<p>有这样一个时间字符串：2008-8-8 20:08:08 ， 请编写能够匹配它的正则表达式，并编写Java代码将日期后面的时分秒提取出来，即：20:08:08</p>
<p>线程</p>
<p>8设计4个线程，其中两个线程每次对j增加1，另外两个线程对j每次减少1。写出程序。<br>用Java写一个多线程程序，如写四个线程，二个加1，二个对一个变量减一，输出<br>wait-notify 写一段代码来解决生产者-消费者问题<br>数字</p>
<p>判断101-200之间有多少个素数，并输出所有素数<br>用最有效率的方法算出2乘以17等于多少<br>有 1 亿个数字，其中有 2 个是重复的，快速找到它，时间和空间要最优<br>2 亿个随机生成的无序整数,找出中间大小的值<br>10 亿个数字里里面找最小的 10 个<br>1到1亿的自然数，求所有数的拆分后的数字之和，如286 拆分成2、8、6，如1到11拆分后的数字之和 =&gt; 1 + … + 9 + 1 + 0 + 1 + 1<br>一个数如果恰好等于它的因子之和，这个数就称为 “完数 “。例如6=1＋2＋3.编程 找出1000以内的所有完数<br>一个数组中所有的元素都出现了三次，只有一个元素出现了一次找到这个元素<br>一球从100米高度自由落下，每次落地后反跳回原高度的一半；再落下，求它在 第10次落地时，共经过多少米？第10次反弹多高？<br>求100－1000内质数的和<br>求1到100的和的平均数<br>求s=a+a+aaa+aaaa+aa…a的值，其中a是一个数字。例如2+22+222+2222+22222(此时共有5个数相加)，几个数相加有键盘控制。 求出1到100的和<br>算出1到40的质数，放进数组里<br>显示放组里的数<br>找出第[5]个数<br>删除第[9]个数，再显示删除后的第[9]个<br>有 3n+1 个数字，其中 3n 个中是重复的，只有 1 个是不重复的，怎么找出来。<br>有一组数1.1.2.3.5.8.13.21.34。写出程序随便输入一个数就能给出和前一组数字同规律的头5个数<br>计算指定数字的阶乘<br>开发 Fizz Buzz<br>给定一个包含 N 个整数的数组，找出丢失的整数<br>一个排好序的数组，找出两数之和为m的所有组合<br>将一个正整数分解质因数。例如：输入90,打印出90=2<em>3</em>3*5。<br>打印出所有的 “水仙花数 “，所谓 “水仙花数 “是指一个三位数，其各位数字立方和等于该数本身。例如：153是一个 “水仙花数 “，因为153=1的三次方＋5的三次方＋3的三次方<br>原地交换两个变量的值<br>找出4字节整数的中位数<br>找到整数的平方根<br>实现斐波那契<br>网络</p>
<p>用Java Socket编程，读服务器几个字符，再写入本地显示<br>反射</p>
<p>反射机制提供了什么功能？<br>反射是如何实现的<br>哪里用到反射机制<br>反射中 Class.forName 和 ClassLoader 区别<br>反射创建类实例的三种方式是什么<br>如何通过反射调用对象的方法<br>如何通过反射获取和设置对象私有字段的值<br>反射机制的优缺点<br>数据库</p>
<p>写一段 JDBC 连Oracle的程序,并实现数据查询<br>算法</p>
<p>50个人围坐一圈，当数到三或者三的倍数出圈，问剩下的人是谁，原来的位置是多少<br>实现一个电梯模拟器用<br>写一个冒泡排序<br>写一个折半查找<br>随机产生20个不能重复的字符并排序<br>写一个函数，传入 2 个有序的整数数组，返回一个有序的整数数组<br>写一段代码在遍历 ArrayList 时移除一个元素<br>古典问题：有一对兔子，从出生后第3个月起每个月都生一对兔子，小兔子长到第四个月后每个月又生一对兔子，假如兔子都不死，问每个月的兔子总数为多少<br>约瑟芬环游戏<br>正则</p>
<p>请编写一段匹配IP地址的正则表达式<br>写出一个正则表达式来判断一个字符串是否是一个数字<br>字符串</p>
<p>写一个方法，入一个文件名和一个字符串，统计这个字符串在这个文件中出现的次数。<br>写一个程序找出所有字符串的组合，并检查它们是否是回文串<br>写一个字符串反转函数，输入abcde转换成edcba代码<br>小游戏，倒转句子中的单词<br>将GB2312编码的字符串转换为ISO-8859-1编码的字符串<br>请写一段代码来计算给定文本内字符“A”的个数。分别用迭代和递归两种方式<br>编写一个截取字符串的函数，输入为一个字符串和字节数，输出为按字节截取的字符串。 但是要保证汉字不被截半个，如“我ABC”4，应该截为“我AB”，输入“我ABC汉DEF”，6，应该输出为“我ABC”而不是“我ABC+汉的半个”<br>给定 2 个包含单词列表（每行一个）的文件，编程列出交集<br>打印出一个字符串的所有排列<br>将一个键盘输入的数字转化成中文输出(例如：输入1234567，输出:一百二拾三万四千五百六拾七)<br>在Web应用开发过程中经常遇到输出某种编码的字符，如从 GBK 到 ISO8859-1等，如何输出一个某种编码的字符串<br>日期</p>
<p>计算两个日期之间的差距</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java面试题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java逃逸分析]]></title>
      <url>/Java%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90.html</url>
      <content type="html"><![CDATA[<p>概念引入</p>
<p>我们都知道，Java 创建的对象都是被分配到堆内存上，但是事实并不是这么绝对，通过对Java对象分配的过程分析，可以知道有两个地方会导致Java中创建出来的对象并一定分别在所认为的堆上。这两个点分别是Java中的逃逸分析和TLAB（Thread Local Allocation Buffer）线程私有的缓存区。</p>
<p>基本概念介绍</p>
<p>逃逸分析，是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。<br><a id="more"></a><br>在计算机语言编译器优化原理中，逃逸分析是指分析指针动态范围的方法，它同编译器优化原理的指针分析和外形分析相关联。当变量（或者对象）在方法中分配后，其指针有可能被返回或者被全局引用，这样就会被其他过程或者线程所引用，这种现象称作指针（或者引用）的逃逸(Escape)。通俗点讲，如果一个对象的指针被多个方法或者线程引用时，那么我们就称这个对象的指针发生了逃逸。</p>
<p>Java在Java SE 6u23以及以后的版本中支持并默认开启了逃逸分析的选项。Java的 HotSpot JIT编译器，能够在方法重载或者动态加载代码的时候对代码进行逃逸分析，同时Java对象在堆上分配和内置线程的特点使得逃逸分析成Java的重要功能。</p>
<p>代码示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> me.stormma.gc;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Created on 2017/4/21.&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> stormma</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@title</span> &lt;p&gt;逃逸分析&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EscapeAnalysis</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> B b;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;全局变量赋值发生指针逃逸&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">globalVariablePointerEscape</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        b = <span class="keyword">new</span> B();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;方法返回引用，发生指针逃逸&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> B <span class="title">methodPointerEscape</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> B();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;实例引用发生指针逃逸&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">instancePassPointerEscape</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        methodPointerEscape().printClassName(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printClassName</span><span class="params">(EscapeAnalysis clazz)</span> </span>&#123;</span><br><span class="line">            System.out.println(clazz.getClass().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>逃逸分析研究对于 java 编译器有什么好处呢？我们知道 java 对象总是在堆中被分配的，因此 java 对象的创建和回收对系统的开销是很大的。java 语言被批评的一个地方，也是认为 java 性能慢的一个原因就是 java不支持栈上分配对象。JDK6里的 Swing内存和性能消耗的瓶颈就是由于 GC 来遍历引用树并回收内存的，如果对象的数目比较多，将给 GC 带来较大的压力，也间接得影响了性能。减少临时对象在堆内分配的数量，无疑是最有效的优化方法。java 中应用里普遍存在一种场景，一般是在方法体内，声明了一个局部变量，并且该变量在方法执行生命周期内未发生逃逸，按照 JVM内存分配机制，首先会在堆内存上创建类的实例（对象），然后将此对象的引用压入调用栈，继续执行，这是 JVM优化前的方式。当然，我们可以采用逃逸分析对 JVM 进行优化。即针对栈的重新分配方式，首先我们需要分析并且找到未逃逸的变量，将该变量类的实例化内存直接在栈里分配，无需进入堆，分配完成之后，继续调用栈内执行，最后线程执行结束，栈空间被回收，局部变量对象也被回收，通过这种方式的优化，与优化前的方案主要区别在于对象的存储介质，优化前是在堆中，而优化后的是在栈中，从而减少了堆中临时对象的分配（较耗时），从而优化性能。</p>
<p>使用逃逸分析进行性能优化(-XX:+DoEscapeAnalysis开启逃逸分析)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Test test = <span class="keyword">new</span> Test();</span><br><span class="line">    <span class="comment">//处理逻辑</span></span><br><span class="line">    ......</span><br><span class="line">    test = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这段代码，之所以可以在栈上进行内存分配，是因为没有发生指针逃逸，即是引用没有暴露出这个方法体。</p>
<p>栈和堆内存分配比较<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> me.stormma.gc;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Created on 2017/4/21.&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> stormma</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: &lt;p&gt;内存分配比较&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EscapeAnalysisTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>];</span><br><span class="line">        b[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> b = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++) &#123;</span><br><span class="line">            alloc();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> e = System.currentTimeMillis();</span><br><span class="line">        System.out.println(e - b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>JVM 参数为-server -Xmx10m -Xms10m -XX:-DoEscapeAnalysis -XX:+PrintGC, 运行结果<br>JVM 参数为-server -Xmx10m -Xms10m -XX:+DoEscapeAnalysis -XX:+PrintGC, 运行结果</p>
<p>性能测试<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> me.stormma.gc;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Created on 2017/4/21.&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> stormma</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: &lt;p&gt;利用逃逸分析进行性能优化&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EscapeAnalysisTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> counter;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            x = (++counter);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span> * <span class="number">1000</span> * <span class="number">10</span>; ++i) &#123;</span><br><span class="line">            Foo foo = <span class="keyword">new</span> Foo();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.nanoTime();</span><br><span class="line">        System.out.println(<span class="string">"Time cost is "</span> + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用逃逸分析优化 JVM输出结果( -server -XX:+DoEscapeAnalysis -XX:+PrintGC)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Time cost is 11012345</span><br></pre></td></tr></table></figure></p>
<p>未使用逃逸分析优化 JVM 输出结果( -server -Xmx10m -Xms10m -XX:-DoEscapeAnalysis -XX:+PrintGC)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure)  33280K-&gt;408K(125952K), 0.0010344 secs]</span><br><span class="line">[GC (Allocation Failure)  33688K-&gt;424K(125952K), 0.0009799 secs]</span><br><span class="line">[GC (Allocation Failure)  33704K-&gt;376K(125952K), 0.0007297 secs]</span><br><span class="line">[GC (Allocation Failure)  33656K-&gt;456K(159232K), 0.0014817 secs]</span><br><span class="line">Time cost is 68562263</span><br></pre></td></tr></table></figure></p>
<p>分析结果，性能优化1/6。<br><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLnN0b3JtbWEubWUvMjAxNy8wNC8yMS9qYXZhJUU5JTgwJTgzJUU5JTgwJUI4JUU1JTg4JTg2JUU2JTlFJTkwLw==" title="https://blog.stormma.me/2017/04/21/java%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/">原文出处<i class="fa fa-external-link"></i></span></p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[数据区、代码区、栈区、堆区]]></title>
      <url>/%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%81%E4%BB%A3%E7%A0%81%E5%8C%BA%E3%80%81%E6%A0%88%E5%8C%BA%E3%80%81%E5%A0%86%E5%8C%BA.html</url>
      <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li>栈区(stack)：由系统的编译器自动的释放，主要用来存放 <strong>方法中的参数，一些临时的局部变量</strong> 等，并且方法中的参数一般在操作完后，会由编译器自动的释放掉。</li>
<li>堆区(heap)：由程序员决定，在Java中，如果程序员不释放的话，一般会由垃圾回收机制自动的清理掉。此区域主要存放： <strong>创建的对象、动态申请的临时空间等</strong> 。</li>
<li>数据区(data seg)：也称 <strong>全局区或者静态区</strong> ，存放 <strong>静态变量、全局变量等</strong> 都会存放到数据区，此区域上的东西都被全局所共享。比如我们通常采用 <strong>类名. </strong>的方式就可以访问到方法，这就是所谓的静态方法，存放到数据区的。</li>
<li>代码区：存放程序编译后可以执行代码的地方。比如执行代码时写的While语句、if语句等，都会存放到此。<a id="more"></a>
<h2 id="内存分析"><a href="#内存分析" class="headerlink" title="内存分析"></a>内存分析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Person类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id ;</span><br><span class="line">    <span class="keyword">int</span> age =  <span class="number">20</span> ;</span><br><span class="line">    Person(<span class="keyword">int</span> _id, <span class="keyword">int</span> _age)&#123;</span><br><span class="line">        id = _id ;</span><br><span class="line">        age = _age ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="接下来对new一个对象进行分析"><a href="#接下来对new一个对象进行分析" class="headerlink" title="接下来对new一个对象进行分析"></a>接下来对new一个对象进行分析</h2><p>执行语句： Person tom = new Person(1,25) ;</p>
<h2 id="第一步："><a href="#第一步：" class="headerlink" title="第一步："></a>第一步：</h2><p>我们知道每一个类都有一个默认的构造函数，即Person(),因此上述会先调用默认的构造函数<br><img src="http://ou3xxg3hg.bkt.clouddn.com/堆.png" alt=""></p>
<h2 id="第二步："><a href="#第二步：" class="headerlink" title="第二步："></a>第二步：</h2><p>执行构造函数New Person(1,25)时，我们知道调用的是Person(int _id, int _age)，所以此时栈空间会分配方法的参数的临时变量如下<br><img src="http://ou3xxg3hg.bkt.clouddn.com/栈.png" alt=""></p>
<h2 id="第三步"><a href="#第三步" class="headerlink" title="第三步:"></a>第三步:</h2><p>执行构造函数 Person(int _id, int _age),id = _id; age = _age;此时栈中的临时变量会改变默认构造函数创建的对象,赋值完后，栈中的临时变量会自动的销毁，然后创建的临时变量Tom会自动的指向创建的对象。<br><img src="http://ou3xxg3hg.bkt.clouddn.com/堆栈.png" alt=""></p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java常用类和方法重点总结]]></title>
      <url>/Java%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%92%8C%E6%96%B9%E6%B3%95%E9%87%8D%E7%82%B9%E6%80%BB%E7%BB%93.html</url>
      <content type="html"><![CDATA[<ol>
<li>简述Java中内存分配的问题<ul>
<li style="list-style: none"><input type="checkbox" checked> 凡是new() 出来的东西，都是堆中进行分配的</li>
<li>局部变量【数据类型+变量名】都是在栈中进行分配的</li>
<li>静态变量【static】和字符串常量【”String”】都是在数据区进行分配的</li>
<li>方法【代码】都是在代码区进行存放的</li>
</ul>
</li>
<li>简述Java中Object类的地位<ul>
<li>Java中所有的类【自己定义的类以及Sun公司提供的类】都默认自动继承了Obeject类</li>
<li>Java中所有的类都从Object类中继承了toString()方法、hashCode()方法和equals等方法<a id="more"></a></li>
</ul>
</li>
<li><p>简述Object类中toString()方法的注意事项</p>
<ul>
<li>toString()方法的返回值是一个字符串</li>
<li>toString()方法返回的是类的名字和该对象的哈希码组成的一个字符串，即toString()方法返回的是 <strong>该对象的字符串表现形式</strong></li>
<li><p>在Java中，System.out.println(类对象名)实际输出的是该对象的toString()方法返回的字符串，即括号中的内容等价于类对象名.toString()，toString()方法的好处 <strong>在碰到println方法的时候，会被自动调用，不用显示的写出来</strong> ，</p>
<pre><code>eg: 
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str =  <span class="keyword">new</span> String();</span><br><span class="line">System.out.println(str)   &lt;==&gt; System.out.println(str.toString())      ----&gt;toString()自动隐藏</span><br></pre></td></tr></table></figure>
</li>
<li><p>建议所有的子类都重写从Object类中继承过来toString方法，否则toString方法的返回值没有什么实际含义（为什么要重写的原因）</p>
</li>
</ul>
</li>
<li>简述Object类中equals()类方法的注意事项<ul>
<li>equals方法的返回值为true或false</li>
<li>Object类中equals方法只有在 <strong>两个对象是同一块内存区域时，即不但内容相同、地址还必须相同时，才返回true，否则即便内容相同、如果地址不同只会返回false</strong></li>
<li>重写Object类中的equals方法目的在于：保证只要两个对象的内容相同，equals方法就返回true（为什么要重写的原因）</li>
</ul>
</li>
<li>简述Object类中hashCode()方法的注意事项<ul>
<li>哈希码原本指的是 <strong>内存空间地址的十六进制表示形式</strong></li>
<li>hashCode()方法返回的是 **该对象的哈希码，即该对象的真实内存地址的十六进制表示形式，但是重写完hashCode()方法之后，返回的不再是该对象真实内存地址的十六进制表示形式</li>
</ul>
</li>
<li>学习Java中toString方法、equals方法、hashCode方法共同的一个注意事项<br>在Java中，凡是动态分配的内存都是没有名字的，而是将其地址赋给一个引用变量【引用】，用引用变量去代表这个事物，所以引用和动态分配的内存有本质上的区别，但是学习Java中的toString方法、equals方法和hashCode方法时默认引用和其指向的动态分配的内存是一个事物，不区分彼此</li>
<li>从逻辑上阐述为什么要重写equals方法和hashCode方法 （<strong>重点</strong>）<ul>
<li>对于用户来说，逻辑上只要两个对象的内容相同，其地址以及这两个对象就应该相等，而要保证地址相同就应该重写hashCode方法，而要保证对象相同就应该重写equals方法</li>
<li>凡是Java中自带的类都已经重写了equals方法和hashCode方法，重写之后只要两个对象的内容相同，hashCode方法的返回值就相同，保证地址相同，equals方法就返回true，保证两个对象是同一个对象，而Java中凡是用户自己定义的类只能自己区重写这两个方法（<strong> 为什么我们自己定义的类，要自己重写这两个方法，toString()也要重写 </strong>）；<br>【new Integer(1)与new Integer(2)】</li>
</ul>
</li>
<li>简述String类中的equals方法与Object类中的equals方法的不同点<ul>
<li>String类中的equals方法是用来判断两个对象的内容是否相同、而Object类中的equals方法是用来判断两个对象是否是同一个对象，所谓同一个对象指的是内存中的同一块存储空间</li>
</ul>
</li>
<li>对于Java中StringBuffer类的由来</li>
<li>String类对象表示不可修改的UniCode编码字符串、即String类对象一旦创建就不可在更改，即只要创建一个字符串，就会重新分配一块内存空间，因此如果经常对字符串的内容进行修改而使用String类的话，就会造成空间以及时间的浪费，因此如果经常对字符串的内容进行修改的话，可以使用StringBuffer类，StringBuffer类可以一直对同一块内存空间进行操作，对一个字符串不断的进行修改，正因为StringBuffer类的这个优点，所以StringBuffer类中存在着大量修改字符串的方法，但是String类中却没有</li>
<li>简述String、StringBuffer类中常用的一个方法<ul>
<li>valueOf():将基本类型数据转化为字符串</li>
</ul>
</li>
<li>简述String类与StringBuffer类的关联<ul>
<li>先使用StringBuffer类将字符串的内容不断的进行修改、最后将成品放到String类里面去</li>
<li>StringBuffer类中的toString方法可以将String类对象转化为StringBuffer类对象<br>String str1 = str2.toString（）;</li>
<li>在Java中双引号括起来的字符串也可以被当做String类对象  如：“zhang”.length();</li>
</ul>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[给出一组年龄，用冒泡排序求最大年龄，最小年龄]]></title>
      <url>/%E7%BB%99%E5%87%BA%E4%B8%80%E7%BB%84%E5%B9%B4%E9%BE%84%EF%BC%8C%E6%B1%82%E6%9C%80%E5%A4%A7%E5%B9%B4%E9%BE%84%EF%BC%8C%E6%9C%80%E5%B0%8F%E5%B9%B4%E9%BE%84.html</url>
      <content type="html"><![CDATA[<h2 id="法一"><a href="#法一" class="headerlink" title="法一"></a>法一</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求出最大年龄,求出最小年龄,求出平均年龄</span></span><br><span class="line">        <span class="keyword">int</span>[] ages = &#123;<span class="number">34</span>,<span class="number">11</span>,<span class="number">45</span>,<span class="number">23</span>,<span class="number">16</span>&#125;;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">4</span>; flag &amp;&amp; i &gt;<span class="number">0</span> ; i--) &#123;</span><br><span class="line">            flag = <span class="keyword">false</span> ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(ages[j]&gt;ages[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = ages[j];</span><br><span class="line">                    ages[j] = ages[j+<span class="number">1</span>];</span><br><span class="line">                    ages[j+<span class="number">1</span>] = temp ;</span><br><span class="line">                    flag = <span class="keyword">true</span> ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"-------"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.print(ages[i]+ <span class="string">"\t"</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="法二"><a href="#法二" class="headerlink" title="法二"></a>法二</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] ages = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; flag &amp;&amp; i &lt; ages.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            flag = <span class="keyword">false</span> ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ages.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(ages[j] &gt; ages[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = ages[j];</span><br><span class="line">                    ages[j] = ages[j+<span class="number">1</span>];</span><br><span class="line">                    ages[j+<span class="number">1</span>] = temp ;</span><br><span class="line">                    flag = <span class="keyword">true</span> ;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"-----"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ages.length; i++) &#123;</span><br><span class="line">            System.out.print(ages[i]+<span class="string">"\t"</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[不使用第三个变量交换两变量的值]]></title>
      <url>/%E4%B8%8D%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%B8%89%E4%B8%AA%E5%8F%98%E9%87%8F%E4%BA%A4%E6%8D%A2%E4%B8%A4%E5%8F%98%E9%87%8F%E7%9A%84%E5%80%BC.html</url>
      <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	有两个整数 分别是 a=10 b=8 在不使用第三个变量的情况下  对其值进行交换</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Work1</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">		<span class="keyword">int</span> b = <span class="number">8</span>;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		a=a+b;</span></span><br><span class="line"><span class="comment">		b=a-b;</span></span><br><span class="line"><span class="comment">		a=a-b;</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">		a=a^b;</span></span><br><span class="line"><span class="comment">		b=a^b;</span></span><br><span class="line"><span class="comment">		a=a^b;</span></span><br><span class="line"><span class="comment">		1010</span></span><br><span class="line"><span class="comment">		1000</span></span><br><span class="line"><span class="comment">		----------</span></span><br><span class="line"><span class="comment">		0010 2</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">		0010</span></span><br><span class="line"><span class="comment">		1000</span></span><br><span class="line"><span class="comment">		-----</span></span><br><span class="line"><span class="comment">		1010 10</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">		0010</span></span><br><span class="line"><span class="comment">		1010</span></span><br><span class="line"><span class="comment">		-----</span></span><br><span class="line"><span class="comment">		1000 8</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		a=b+(b=a)*<span class="number">0</span>;</span><br><span class="line">		System.out.println(<span class="string">"a="</span>+a+<span class="string">",b="</span>+b);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用Java倒序输出12345]]></title>
      <url>/%E4%BD%BF%E7%94%A8Java%E5%80%92%E5%BA%8F%E8%BE%93%E5%87%BA12345.html</url>
      <content type="html"><![CDATA[<h2 id="原理：-取最后一位，-取整除掉最后一位"><a href="#原理：-取最后一位，-取整除掉最后一位" class="headerlink" title="原理：%取最后一位，/取整除掉最后一位"></a>原理：%取最后一位，/取整除掉最后一位</h2><h2 id="逐行输出"><a href="#逐行输出" class="headerlink" title="逐行输出"></a>逐行输出</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> t = <span class="number">12345</span> ;</span><br><span class="line"><span class="keyword">while</span>(t&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> num = t%<span class="number">10</span>;</span><br><span class="line">            t /= <span class="number">10</span> ;</span><br><span class="line">            System.out.print(num);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h2 id="一次性输出"><a href="#一次性输出" class="headerlink" title="一次性输出"></a>一次性输出</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">12345</span>;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">			num%10       					5</span></span><br><span class="line"><span class="comment">			num/10%10    					4</span></span><br><span class="line"><span class="comment">			num/100%10   num/10/10%10 		3</span></span><br><span class="line"><span class="comment">			num/1000%10  num/10/10/10%10     2</span></span><br><span class="line"><span class="comment">			num/10000%10 num/10/10/10/10%10 1</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		<span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(num&gt;<span class="number">0</span>)&#123;</span><br><span class="line">			result = result*<span class="number">10</span>+num%<span class="number">10</span>;</span><br><span class="line">			num/=<span class="number">10</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.print(result);</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[并发和并行的区别]]></title>
      <url>/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C%E7%9A%84%E5%8C%BA%E5%88%AB.html</url>
      <content type="html"><![CDATA[<p><img src="http://ou3xxg3hg.bkt.clouddn.com/并行1.jpg" alt=""></p>
<h2 id="观点一"><a href="#观点一" class="headerlink" title="观点一"></a>观点一</h2><p>并行（parallelise）同时刻（某点），并发（concurrency）同时间（某段）</p>
<h2 id="观点二"><a href="#观点二" class="headerlink" title="观点二"></a>观点二</h2><p>深入理解计算机系统CSAPP的回答。并发（Concurrency）是说进程B的开始时间是在进程A的开始时间与结束时间之间，我们就说A和B是并发的。并行（Parallel Execution）是并发的真子集，指同一时间两个进程运行在不同的机器上或者同一个机器不同的核心上。<br><a id="more"></a><br>作者：starrynight<br>链接：<span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzMzNTE1NDgxL2Fuc3dlci82Nzk2Mjc1Ng==" title="https://www.zhihu.com/question/33515481/answer/67962756">https://www.zhihu.com/question/33515481/answer/67962756<i class="fa fa-external-link"></i></span><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h2 id="观点三"><a href="#观点三" class="headerlink" title="观点三"></a>观点三</h2><p>如果某个系统支持两个或者多个动作（Action）同时存在，那么这个系统就是一个并发系统。如果某个系统支持两个或者多个动作同时执行，那么这个系统就是一个并行系统。并发系统与并行系统这两个定义之间的关键差异在于“存在”这个词。在并发程序中可以同时拥有两个或者多个线程。这意味着，如果程序在单核处理器上运行，那么这两个线程将交替地换入或者换出内存。这些线程是同时“存在”的——每个线程都处于执行过程中的某个状态。如果程序能够并行执行，那么就一定是运行在多核处理器上。此时，程序中的每个线程都将分配到一个独立的处理器核上，因此可以同时运行。我相信你已经能够得出结论——“并行”概念是“并发”概念的一个子集。也就是说，你可以编写一个拥有多个线程或者进程的并发程序，但如果没有多核处理器来执行这个程序，那么就不能以并行方式来运行代码。因此，凡是在求解单个问题时涉及多个执行流程的编程模式或者执行行为，都属于并发编程的范畴。摘自：《并发的艺术》 — 〔美〕布雷谢斯在豆瓣阅读书店查看：<span class="exturl" data-url="aHR0cHM6Ly9yZWFkLmRvdWJhbi5jb20vZWJvb2svMTAwMzQ0NTkv" title="https://read.douban.com/ebook/10034459/">https://read.douban.com/ebook/10034459/<i class="fa fa-external-link"></i></span></p>
<p>作者：BeginMan<br>链接：<span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzMzNTE1NDgxL2Fuc3dlci8xMDUzNDgwMTk=" title="https://www.zhihu.com/question/33515481/answer/105348019">https://www.zhihu.com/question/33515481/answer/105348019<i class="fa fa-external-link"></i></span><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h2 id="观点四"><a href="#观点四" class="headerlink" title="观点四"></a>观点四</h2><p>并发：交替或者同时做不同事的能力<br>并行：同时做不同事的能力</p>
<p>行话解释：<br>并发：不同代码块交替或者同时执行的性能<br>并行：不同代码块同时执行的性能</p>
<h2 id="观点五"><a href="#观点五" class="headerlink" title="观点五"></a>观点五</h2><p>作者：李运华<br>链接：<span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzMzNTE1NDgxL2Fuc3dlci8xMjEwNTA1Mzk=" title="https://www.zhihu.com/question/33515481/answer/121050539">https://www.zhihu.com/question/33515481/answer/121050539<i class="fa fa-external-link"></i></span><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p>详细请参考：  <span class="exturl" data-url="aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHAlM0EvL3R1dG9yaWFscy5qZW5rb3YuY29tL2phdmEtY29uY3VycmVuY3kvY29uY3VycmVuY3ktdnMtcGFyYWxsZWxpc20uaHRtbA==" title="https://link.zhihu.com/?target=http%3A//tutorials.jenkov.com/java-concurrency/concurrency-vs-parallelism.html">Concurrency vs. Parallelism<i class="fa fa-external-link"></i></span><br>Concurrency<br><img src="http://ou3xxg3hg.bkt.clouddn.com/并行2.jpg" alt=""><br>并发的反义词是顺序，concurrency vs sequential，例如：</p>
<h2 id="顺序处理："><a href="#顺序处理：" class="headerlink" title="顺序处理："></a>顺序处理：</h2><p>你陪女朋友先看电影（Task1），看完后陪女朋友到花店买了一束花（Task2），然后陪女朋友去西餐厅吃烛光晚餐（Task3），这就是“顺序处理”，因为整个过程中只有你这一个处理器，事情只能一件一件的做（要么是你亲自做，要么你要等别人做）。Task1你要花2小时，Task2等花做好你要花30分钟，Task3等菜做好要30分钟，从你开始看电影到开始吃饭，全程需要3小时（假设走路不算时间）。</p>
<h2 id="并发处理："><a href="#并发处理：" class="headerlink" title="并发处理："></a>并发处理：</h2><p>你陪女朋友先看电影（Task1），同时打电话给花店预定一束花，花店安排人员在20：00送到西餐厅（Task2）；同时你打电话给西餐定预定20：00的浪漫烛光晚餐，西餐厅开始给你准备晚餐（Task3）；等到你电影看完跑到西餐厅，花也送到了，晚餐也准备好了，你跑过去直接献花吃饭然后开房即可，这就是并发处理。Task1还是2小时，但Task2和Task3也在这2小时完成了，从你开始看电影到开始吃饭，全程只需要2小时，3个任务是并发完成的。秘诀就是有3个处理器了：你、花店、餐厅在同一个时间段内都在做各自的任务。Parallelism<br><img src="http://ou3xxg3hg.bkt.clouddn.com/并行3.jpg" alt=""><br>并行的反义词是串行，Parallelism vs Serial，比如说给你一个100万的整形数组，挑出其中最小的值。</p>
<h2 id="串行处理"><a href="#串行处理" class="headerlink" title="串行处理"></a>串行处理</h2><p>从数组的第一个开始扫描到最后一个，类似冒泡排序一样</p>
<h2 id="并行处理"><a href="#并行处理" class="headerlink" title="并行处理"></a>并行处理</h2><p>将数组分为10组，每组10万个整形，同时扫描10组得到10个数值，然后再将这10个数值排列一下。上面这个简单的例子也可以看出，串行改为并行其实并不那么简单，涉及到任务分解（有先后依赖的任务就不能做到并行）、任务运行（可能要考虑互斥、锁、共享等）、结果合并。以Java的并行垃圾回收器Parallel为例，标记阶段、回收阶段各自可以多线程并行，但不能将回收阶段和标记阶段一起并行，因为回收阶段的处理依赖标记阶段的结果。</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java实现九九乘法表]]></title>
      <url>/Java%E5%AE%9E%E7%8E%B0%E4%B9%9D%E4%B9%9D%E4%B9%98%E6%B3%95%E8%A1%A8.html</url>
      <content type="html"><![CDATA[<p>关键难点：内循环的条件判断<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//九九乘法表</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ;i&lt;=<span class="number">9</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;=i;j++)&#123;</span><br><span class="line">                System.out.print(j+<span class="string">"*"</span>+i+<span class="string">"="</span>+j*i+<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>输出结果：<br><img src="http://ou3xxg3hg.bkt.clouddn.com/九九乘法表.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java中内存分配策略及堆和栈的比较]]></title>
      <url>/java%E4%B8%AD%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5%E5%8F%8A%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E6%AF%94%E8%BE%83.html</url>
      <content type="html"><![CDATA[<h2 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h2><p>按照编译原理的观点,程序运行时的内存分配有三种策略,分别是静态的,栈式的,和堆式的.<br>静态存储分配是指在编译时就能确定每个数据目标在运行时刻的存储空间需求,因而在编译时就可以给他们分配固定的内存空间.这种分配策略要求程序代码中不允许有可变数据结构(比如可变数组)的存在,也不允许有嵌套或者递归的结构出现,因为它们都会导致编译程序无法计算准确的存储空间需求.<br>栈式存储分配也可称为动态存储分配,是由一个类似于堆栈的运行栈来实现的.和静态存储分配相反,在栈式存储方案中,程序对数据区的需求在编译时是完全未知的,只有到运行的时候才能够知道,但是规定在运行中进入一个程序模块时,必须知道该程序模块所需的数据区大小才能够为其分配内存.和我们在数据结构所熟知的栈一样,栈式存储分配按照先进后出的原则进行分配。<br>静态存储分配要求在编译时能知道所有变量的存储要求,栈式存储分配要求在过程的入口处必须知道所有的存储要求,而堆式存储分配则专门负责在编译时或运行时模块入口处都无法确定存储要求的数据结构的内存分配,比如可变长度串和对象实例.堆由大片的可利用块或空闲块组成,堆中的内存可以按照任意顺序分配和释放.<br><a id="more"></a></p>
<h2 id="堆和栈的比较"><a href="#堆和栈的比较" class="headerlink" title="堆和栈的比较"></a>堆和栈的比较</h2><p>上面的定义从编译原理的教材中总结而来,除静态存储分配之外,都显得很呆板和难以理解,下面撇开静态存储分配,集中比较堆和栈:<br>从堆和栈的功能和作用来通俗的比较,堆主要用来存放对象的，栈主要是用来执行程序的.而这种不同又主要是由于堆和栈的特点决定的:<br>在编程中，例如C/C++中，所有的方法调用都是通过栈来进行的,所有的局部变量,形式参数都是从栈中分配内存空间的。实际上也不是什么分配,只是从栈顶向上用就行,就好像工厂中的传送带(conveyor belt)一样,Stack Pointer会自动指引你到放东西的位置,你所要做的只是把东西放下来就行.退出函数的时候，修改栈指针就可以把栈中的内容销毁.这样的模式速度最快, 当然要用来运行程序了.需要注意的是,在分配的时候,比如为一个即将要调用的程序模块分配数据区时,应事先知道这个数据区的大小,也就说是虽然分配是在程序运行时进行的,但是分配的大小多少是确定的,不变的,而这个”大小多少”是在编译时确定的,不是在运行时.<br>堆是应用程序在运行的时候请求操作系统分配给自己内存，由于从操作系统管理的内存分配,所以在分配和销毁时都要占用时间，因此用堆的效率非常低.但是堆的优点在于,编译器不必知道要从堆里分配多少存储空间，也不必知道存储的数据要在堆里停留多长的时间,因此,用堆保存数据时会得到更大的灵活性。事实上,面向对象的多态性,堆内存分配是必不可少的,因为多态变量所需的存储空间只有在运行时创建了对象之后才能确定.在C++中，要求创建一个对象时，只需用 new命令编制相关的代码即可。执行这些代码时，会在堆里自动进行数据的保存.当然，为达到这种灵活性，必然会付出一定的代价:在堆里分配存储空间时会花掉更长的时间！这也正是导致我们刚才所说的效率低的原因,看来列宁同志说的好,人的优点往往也是人的缺点,人的缺点往往也是人的优点(晕~). </p>
<h2 id="JVM中的堆和栈"><a href="#JVM中的堆和栈" class="headerlink" title="JVM中的堆和栈"></a>JVM中的堆和栈</h2><p>JVM是基于堆栈的虚拟机.JVM为每个新创建的线程都分配一个堆栈.也就是说,对于一个Java程序来说，它的运行就是通过对堆栈的操作来完成的。堆栈以帧为单位保存线程的状态。JVM对堆栈只进行两种操作:以帧为单位的压栈和出栈操作。<br>我们知道,某个线程正在执行的方法称为此线程的当前方法.我们可能不知道,当前方法使用的帧称为当前帧。当线程激活一个Java方法,JVM就会在线程的 Java堆栈里新压入一个帧。这个帧自然成为了当前帧.在此方法执行期间,这个帧将用来保存参数,局部变量,中间计算过程和其他数据.这个帧在这里和编译原理中的活动纪录的概念是差不多的.<br>从Java的这种分配机制来看,堆栈又可以这样理解:堆栈(Stack)是操作系统在建立某个进程时或者线程(在支持多线程的操作系统中是线程)为这个线程建立的存储区域，该区域具有先进后出的特性。<br>个Java应用都唯一对应一个JVM实例，每一个实例唯一对应一个堆。应用程序在运行中所创建的所有类实例或数组都放在这个堆中,并由应用所有的线程共享.跟C/C++不同，Java中分配堆内存是自动初始化的。Java中所有对象的存储空间都是在堆中分配的，但是这个对象的引用却是在堆栈中分配,也就是说在建立一个对象时从两个地方都分配内存，在堆中分配的内存实际建立这个对象，而在堆栈中分配的内存只是一个指向这个堆对象的指针(引用)而已。<br>JVM运行时，将内存分为堆和栈，堆中存放的是创建的对象，JAVA字符串对象内存实现时，在堆中开辟了一快很小的内存，叫字符串常量池，用来存放特定的字符串对象。<br>关于String对象的创建，两种方式是不同的，第一种不用new的简单语法，即<br>String s1=”JAVA”;<br>创建步骤是先看常量池中有没有与”JAVA”相同的的字符串对象，如果有，将s1指向该对象，若没有，则创建一个新对象，并让s1指向它。<br>第二种是new语法<br>String s2=”JAVA”;<br>这种语法是在堆而不是在常量池中创建对象，并将s2指向它，然后去字符串常量池中看看，是否有与之相同的内容的对象，如果有，则将new出来的字符串对象与字符串常量池中的对象联系起来，如果没有，则在字符串常量池中再创建一个包含该内容的字符串对象，并将堆内存中的对象与字符串常量池中新建出来的对象联系起来。<br>这就是字符串的一次投入，终生回报的内存机制，对字符串的比较带来好处。</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java内存机制和内存地址]]></title>
      <url>/Java%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6%E5%92%8C%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80.html</url>
      <content type="html"><![CDATA[<h2 id="问题一："><a href="#问题一：" class="headerlink" title="问题一："></a>问题一：</h2><p>String str1 = “abc”;<br>String str2 = “abc”;<br>System.out.println(str1==str2); //true </p>
<h2 id="问题二："><a href="#问题二：" class="headerlink" title="问题二："></a>问题二：</h2><p>String str1 =new String (“abc”);<br>String str2 =new String (“abc”);<br>System.out.println(str1==str2); // false </p>
<h2 id="问题三："><a href="#问题三：" class="headerlink" title="问题三："></a>问题三：</h2><p>String s1 = “ja”;<br>String s2 = “va”;<br>String s3 = “java”;<br>String s4 = s1 + s2;<br>System.out.println(s3 == s4);//false<br>System.out.println(s3.equals(s4));//true<br>由于以上问题让我含糊不清，于是特地搜集了一些有关java内存分配的资料,以下是网摘：<br><a id="more"></a></p>
<h2 id="Java-中的堆和栈"><a href="#Java-中的堆和栈" class="headerlink" title="Java 中的堆和栈"></a>Java 中的堆和栈</h2><p>Java把内存划分成两种：一种是栈内存，一种是堆内存。<br>在函数中定义的一些基本类型的变量和对象的引用变量都在函数的栈内存中分配。<br>当在一段代码块定义一个变量时，Java就在栈中为这个变量分配内存空间，当超过变量的作用域后，Java会自动释放掉为该变量所分配的内存空间，该内存空间可以立即被另作他用。<br>堆内存用来存放由new创建的对象和数组。<br>在堆中分配的内存，由Java虚拟机的自动垃圾回收器来管理。<br>在堆中产生了一个数组或对象后，还可以在栈中定义一个特殊的变量，让栈中这个变量的取值等于数组或对象在堆内存中的首地址，栈中的这个变量就成了数组或对象的引用变量。<br>引用变量就相当于是为数组或对象起的一个名称，以后就可以在程序中使用栈中的引用变量来访问堆中的数组或对象。 </p>
<h2 id="具体的说："><a href="#具体的说：" class="headerlink" title="具体的说："></a>具体的说：</h2><p>栈与堆都是Java用来在Ram中存放数据的地方。与C++不同，Java自动管理栈和堆，程序员不能直接地设置栈或堆。<br>Java的堆是一个运行时数据区,类的(对象从中分配空间。这些对象通过new、newarray、anewarray和multianewarray等指令建立，它们不需要程序代码来显式的释放。堆是由垃圾回收来负责的，堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，因为它是在运行时动态分配内存的，Java的垃圾收集器会自动收走这些不再使用的数据。但缺点是，由于要在运行时动态分配内存，存取速度较慢。<br>栈的优势是，存取速度比堆要快，仅次于寄存器，栈数据可以共享。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。栈中主要存放一些基本类型的变量（,int, short, long, byte, float, double, boolean, char）和对象句柄。<br>栈有一个很重要的特殊性，就是存在栈中的数据可以共享。假设我们同时定义：<br>int a = 3;<br>int b = 3；<br>编译器先处理int a = 3；首先它会在栈中创建一个变量为a的引用，然后查找栈中是否有3这个值，如果没找到，就将3存放进来，然后将a指向3。接着处理int b = 3；在创建完b的引用变量后，因为在栈中已经有3这个值，便将b直接指向3。这样，就出现了a与b同时均指向3的情况。这时，如果再令a=4；那么编译器会重新搜索栈中是否有4值，如果没有，则将4存放进来，并令a指向4；如果已经有了，则直接将a指向这个地址。因此a值的改变不会影响到b的值。要注意这种数据的共享与两个对象的引用同时指向一个对象的这种共享是不同的，因为这种情况a的修改并不会影响到b, 它是由编译器完成的，它有利于节省空间。而一个对象引用变量修改了这个对象的内部状态，会影响到另一个对象引用变量。<br>String是一个特殊的包装类数据。可以用：<br>String str = new String(“abc”);<br>String str = “abc”;<br>两种的形式来创建，第一种是用new()来新建对象的，它会在存放于堆中。每调用一次就会创建一个新的对象。<br>而第二种是先在栈中创建一个对String类的对象引用变量str，然后查找栈中有没有存放”abc”，如果没有，则将”abc”存放进栈，并令str指向”abc”，如果已经有”abc” 则直接令str指向“abc”。<br>          比较类里面的数值是否相等时，用equals()方法；当测试两个包装类的引用是否指向同一个对象时，用==，下面用例子说明上面的理论。 </p>
<h2 id="方式一："><a href="#方式一：" class="headerlink" title="方式一："></a>方式一：</h2><p>String str1 = “abc”;<br>String str2 = “abc”;<br>System.out.println(str1==str2); //true<br>可以看出str1和str2是指向同一个对象的。 </p>
<h2 id="方式二："><a href="#方式二：" class="headerlink" title="方式二："></a>方式二：</h2><p>String str1 =new String (“abc”);<br>String str2 =new String (“abc”);<br>System.out.println(str1==str2); // false<br>用new的方式是生成不同的对象。每一次生成一个。<br>因此用第一种方式创建多个”abc”字符串,在内存中其实只存在一个对象而已. 这种写法有利与节省内存空间. 同时它可以在一定程度上提高程序的运行速度，因为JVM会自动根据栈中数据的实际情况来决定是否有必要创建新对象。而对于String str = new String(“abc”)；的代码，则一概在堆中创建新对象，而不管其字符串值是否相等，是否有必要创建新对象，从而加重了程序的负担。<br>另一方面, 要注意: 我们在使用诸如String str = “abc”；的格式定义类时，总是想当然地认为，创建了String类的对象str。担心陷阱！对象可能并没有被创建！而可能只是指向一个先前已经创建的对象。只有通过new()方法才能保证每次都创建一个新的对象。由于String类的immutable性质，当String变量需要经常变换其值时，应该考虑使用StringBuffer类，以提高程序效率。</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java语言基础]]></title>
      <url>/Java%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80.html</url>
      <content type="html"><![CDATA[<h2 id="1、-java程序的组成："><a href="#1、-java程序的组成：" class="headerlink" title="1、    java程序的组成："></a>1、    java程序的组成：</h2><p>关键字，标识符，注释，变量，语句，表达式，数组，方法</p>
<h2 id="2、-关键字："><a href="#2、-关键字：" class="headerlink" title="2、    关键字："></a>2、    关键字：</h2><p>Java语言内部使用了的一些用于特殊用途的词汇，那么在程序中用户不能使用。语言本身保留了一些词汇用于语言的语法等用途。<br><img src="http://ou3xxg3hg.bkt.clouddn.com/关键字.jpg" alt=""></p>
<h2 id="3、-已用到的关键字："><a href="#3、-已用到的关键字：" class="headerlink" title="3、    已用到的关键字："></a>3、    已用到的关键字：</h2><p>class 声明一个类。<br>public: 表示该类可以被外界调用  如果一个类被声明为public,那么该类所在的文件名要和类名一致。编译后的文件名和类名相同。<br>static:表示是静态的。<br>void：表示没有返回值<br><a id="more"></a></p>
<h2 id="4、-关键字都是小写的。"><a href="#4、-关键字都是小写的。" class="headerlink" title="4、    关键字都是小写的。"></a>4、    关键字都是小写的。</h2><h2 id="5、-标识符："><a href="#5、-标识符：" class="headerlink" title="5、    标识符："></a>5、    标识符：</h2><p>标识符就是用户在程序自定义使用的一些名词。在程序中标识符可以用来表示类名，变量名，方法名，参数名等。<br>在java中标识符的组成：<br>大小写字母，数字，下划线以及$组成。不能以数字开头。标识符通常要有意义。不能随便乱取。建议使用英文表示。<br>类名：以大写字母开头，所有单词首字母大写。采用的Pascal命名规则<br>变量名：第一个单词首字母以小写开头，其后的所有单词首字母以大写开头。采用的驼峰命名规则。</p>
<h2 id="6、-注释："><a href="#6、-注释：" class="headerlink" title="6、    注释："></a>6、    注释：</h2><p>在程序中，方便人们阅读代码而写的一些说明文字。<br>在java中有3类注释：<br>单行注释：用// 开头<br>多行注释：用/<em>开头  </em>/结尾<br>文档注释：用/<em>* 开头  </em>/结尾，并且在其中会用到一些java定义好的注解来声明<br>注意：单行注释和多行注释不会被编译 也不会被jvm解释执行，文档注释会编译，可以通过jvm生成对应的html文档,方便用户查询使用。</p>
<h2 id="7、-总结："><a href="#7、-总结：" class="headerlink" title="7、    总结："></a>7、    总结：</h2><p>第一条：常用的关键字要熟悉，能够记住。<br>第二条：标识符的命名要符合规范。<br>第三条：程序一定要注释。建议先写注释，再写代码。</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[变量和常量]]></title>
      <url>/%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F.html</url>
      <content type="html"><![CDATA[<h2 id="1、为什么需要变量？"><a href="#1、为什么需要变量？" class="headerlink" title="1、为什么需要变量？"></a>1、为什么需要变量？</h2><p>方便对一个数据的修改和使用。如：一个数据在多处使用时，如果要修改，那么多个地方同时都需要修改，这个需要一个变量用于存储数据，在使用时，直接使用变量即可，这样当修改数据时，只需要修改变量本身的值就可以了。</p>
<h2 id="2、什么是变量？"><a href="#2、什么是变量？" class="headerlink" title="2、什么是变量？"></a>2、什么是变量？</h2><p>在java中，变量是一个存储空间的表示。</p>
<h2 id="3、使用变量的语法："><a href="#3、使用变量的语法：" class="headerlink" title="3、使用变量的语法："></a>3、使用变量的语法：</h2><p>数据类型 变量名 = 值</p>
<h2 id="4、数据类型"><a href="#4、数据类型" class="headerlink" title="4、数据类型"></a>4、数据类型</h2><p>基本可以分为两类：基本数据类型和引用数据类型<br>基本数据类型：整数、小数、布尔、字符<br><a id="more"></a></p>
<h3 id="整数："><a href="#整数：" class="headerlink" title="整数："></a>整数：</h3><p>byte:表示是字节  占用的内存空间是1字节<br>short:表示是短整形  占用的内存空间是2字节<br>int:表示整形 占用的内存空间是4字节<br>long:表示长整形 占用的内存空间是8字节</p>
<h3 id="小数："><a href="#小数：" class="headerlink" title="小数："></a>小数：</h3><p>float：单精度浮点数 占用的内存空间是4字节<br>double:双精度浮点数 占用的内存空间是8字节</p>
<h3 id="布尔："><a href="#布尔：" class="headerlink" title="布尔："></a>布尔：</h3><p>boolean:布尔类型的值 只有true和false 1字节</p>
<h3 id="字符：用于表示单个字符"><a href="#字符：用于表示单个字符" class="headerlink" title="字符：用于表示单个字符"></a>字符：用于表示单个字符</h3><p>char:2个字节</p>
<h3 id="引用数据类型：class-interface-数组"><a href="#引用数据类型：class-interface-数组" class="headerlink" title="引用数据类型：class ,interface,数组"></a>引用数据类型：class ,interface,数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">byte</span> age = <span class="number">125</span> ;</span><br><span class="line">    <span class="keyword">short</span> t = <span class="number">23</span> ;</span><br><span class="line">    <span class="keyword">char</span> ch = <span class="string">'中'</span>;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">true</span> ;</span><br><span class="line">    <span class="keyword">float</span> score = <span class="number">98.5f</span> ;</span><br><span class="line">    <span class="keyword">double</span> avgScore = <span class="number">80.4</span> ;</span><br><span class="line">    System.out.println(age);</span><br><span class="line">    System.out.println(t);</span><br><span class="line">    System.out.println(ch);</span><br><span class="line">   System.out.println(flag);</span><br><span class="line">   System.out.println(score);</span><br><span class="line">   System.out.println(avgScore);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整数默认是 int,小数默认是 double<br>单精度后面的 f 表示是单精度浮点，需要明确出来，可以 f 或者 F .</p>
<h2 id="5、5-整数在java中有4种表现形式："><a href="#5、5-整数在java中有4种表现形式：" class="headerlink" title="5、5.    整数在java中有4种表现形式："></a>5、5.    整数在java中有4种表现形式：</h2><p>二进制：是由数字0和1组成的。<br>八进制：是由数字0到7组成的。<br>十进制：是由数字0到9组成的。<br>十六进制：是由数字0到9和ABCDEF组成。<br>进制之间转换：<br><img src="http://ou3xxg3hg.bkt.clouddn.com/进制.jpg" alt="进制的转换"></p>
<h2 id="6、-变量名：命名规则采用驼峰命名法。"><a href="#6、-变量名：命名规则采用驼峰命名法。" class="headerlink" title="6、    变量名：命名规则采用驼峰命名法。"></a>6、    变量名：命名规则采用驼峰命名法。</h2><h2 id="7、-数据类型的转换："><a href="#7、-数据类型的转换：" class="headerlink" title="7、    数据类型的转换："></a>7、    数据类型的转换：</h2><p>自动类型转换：<br><img src="http://ou3xxg3hg.bkt.clouddn.com/自动类型转换.jpg" alt=""><br>强制类型转换：<br><img src="http://ou3xxg3hg.bkt.clouddn.com/强制类型转换.jpg" alt=""><br>类型提升：<br>当是byte，short，char 进行运算时会自动提升为int。<br>当有float类型，提升为float类型<br>当有double类型，提升为double类型<br>当有long类型，提升为long类型<br><img src="http://ou3xxg3hg.bkt.clouddn.com/类的自动提升.jpg" alt=""></p>
<h2 id="8、-字符类型：在java中，char用来表示一个字符，一个字符也就是一个字母-用单引号括起来。’A’；也可以用char来表示一个中文。表示中文时特别需要注意编码问题。"><a href="#8、-字符类型：在java中，char用来表示一个字符，一个字符也就是一个字母-用单引号括起来。’A’；也可以用char来表示一个中文。表示中文时特别需要注意编码问题。" class="headerlink" title="8、    字符类型：在java中，char用来表示一个字符，一个字符也就是一个字母,用单引号括起来。’A’；也可以用char来表示一个中文。表示中文时特别需要注意编码问题。"></a>8、    字符类型：在java中，char用来表示一个字符，一个字符也就是一个字母,用单引号括起来。’A’；也可以用char来表示一个中文。表示中文时特别需要注意编码问题。</h2>]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java入门]]></title>
      <url>/Java%E5%85%A5%E9%97%A8.html</url>
      <content type="html"><![CDATA[<h2 id="1-Java-是SUN-Starfard-University-Network-公司在1995年开发了一门完全面向对象的，开源的高级编程语言。"><a href="#1-Java-是SUN-Starfard-University-Network-公司在1995年开发了一门完全面向对象的，开源的高级编程语言。" class="headerlink" title="1.    Java:是SUN(Starfard University Network)公司在1995年开发了一门完全面向对象的，开源的高级编程语言。"></a>1.    Java:是SUN(Starfard University Network)公司在1995年开发了一门完全面向对象的，开源的高级编程语言。</h2><h2 id="2-Java发展历史："><a href="#2-Java发展历史：" class="headerlink" title="2.    Java发展历史："></a>2.    Java发展历史：</h2><p>1995 java诞生<br>1996 jdk1.0发布<br>1998 jdk1.2 发布  J2SE(1.2,1.3,1.4)<br>2004 jdk1.5 发布  JAVASE5<br>2014 jdk1.8 发布  JAVASE8</p>
<h2 id="3-Java的优势：跨平台"><a href="#3-Java的优势：跨平台" class="headerlink" title="3.    Java的优势：跨平台"></a>3.    Java的优势：跨平台</h2><p>一次编写 多次运行<br>Java是运行在JVM（Java virtual machine）之上的。为不同平台下开发不同的JVM。所有JVM对java语言本身的规范是一样的。</p>
<h2 id="4-Java的版本："><a href="#4-Java的版本：" class="headerlink" title="4.    Java的版本："></a>4.    Java的版本：</h2><p>JavaSE：java standard edition java标准版 是Java的基础。<br>JavaME：java micro edition :移动端，小型设备，PDA等<br>JavaEE：java enterprise edition：java的企业级版本，java web等<br><a id="more"></a></p>
<h2 id="5-JVM-JRE-JDK"><a href="#5-JVM-JRE-JDK" class="headerlink" title="5.    JVM,JRE,JDK"></a>5.    JVM,JRE,JDK</h2><p>Jvm java virtual machine         java虚拟机 运行java程序<br>Jre  java runtime environment      java运行时环境<br>Jdk  java development kit java    开发工具包<br>JDK—&gt;JRE—-&gt;JVM</p>
<h2 id="6-下载jdk来安装："><a href="#6-下载jdk来安装：" class="headerlink" title="6.    下载jdk来安装："></a>6.    下载jdk来安装：</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cub3JhY2xlLmNvbQ==" title="https://www.oracle.com">官方下载地址<i class="fa fa-external-link"></i></span><br>指定安装位置后 傻瓜式安装<br>在命令行运行时：</p>
<p>需要配置环境变量。<br>在dos中执行命令，操作系统会根据系统的环境变量Path去寻找对应的可执行程序（.exe,.bat）。</p>
<h2 id="7-Path变量的配置"><a href="#7-Path变量的配置" class="headerlink" title="7.    Path变量的配置"></a>7.    Path变量的配置</h2><p>计算机  右键  属性  高级系统设置  环境变量<br>添加一个JAVA_HOME变量 值为jdk的安装目录<br>在Path变量中的前面添加%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;<br>注意：使用分号对每个路径进行分割，都是英文下的分号</p>
<h2 id="8-编写第一个HelloWorld应用程序：所有java程序都是以-java结尾的。"><a href="#8-编写第一个HelloWorld应用程序：所有java程序都是以-java结尾的。" class="headerlink" title="8.    编写第一个HelloWorld应用程序：所有java程序都是以.java结尾的。"></a>8.    编写第一个HelloWorld应用程序：所有java程序都是以.java结尾的。</h2><p>class HelloWorld{<br>    public static void main(String[] args){<br>         System.out.println(“hello world”);<br>    }<br>}<br>保存为HelloWorld.java文件</p>
<h2 id="9-编写好的应用程序-也就是以-java结尾的文件，称为源文件。编写好的源文件需要通过javac命令进行编译，编译的目的是为了让jvm可以认识并且执行。"><a href="#9-编写好的应用程序-也就是以-java结尾的文件，称为源文件。编写好的源文件需要通过javac命令进行编译，编译的目的是为了让jvm可以认识并且执行。" class="headerlink" title="9.    编写好的应用程序,也就是以.java结尾的文件，称为源文件。编写好的源文件需要通过javac命令进行编译，编译的目的是为了让jvm可以认识并且执行。"></a>9.    编写好的应用程序,也就是以.java结尾的文件，称为源文件。编写好的源文件需要通过javac命令进行编译，编译的目的是为了让jvm可以认识并且执行。</h2><p>编译后会生成一个.class文件，该文件称为字节码文件，能够被jvm认识并且执行。<br>运行程序：使用java命令进行运行。运行的是.class文件</p>
<h2 id="10-Java程序的编写流程："><a href="#10-Java程序的编写流程：" class="headerlink" title="10.    Java程序的编写流程："></a>10.    Java程序的编写流程：</h2><p>编写源文件——–&gt;通过javac命令编译源文件——–&gt;通过java命令执行字节码文件。<br>Javac编译时 需要跟上后缀.java,而java命令后直接跟文件即可 不需要后缀。</p>
<h2 id="11-HelloWorld程序详解："><a href="#11-HelloWorld程序详解：" class="headerlink" title="11.    HelloWorld程序详解："></a>11.    HelloWorld程序详解：</h2><h2 id="12-classpath环境变量："><a href="#12-classpath环境变量：" class="headerlink" title="12.    classpath环境变量："></a>12.    classpath环境变量：</h2><p>配置path环境变量的目的是在任意路径下都可以执行java,javac命令<br>配置classpath的目的是为了在任意路径下都可以执行.class文件。所谓的classpath指定的是.class文件所在的位置。<br>classpath不设置的时候：java命令会在当前路径下查找.class，如果找不到</p>
<p>如果设置了classpath，那么会从classpath指定的路径去查找.class<br>如果classpath的值后面不加分号：查找的classpath指定的路径下是否有.class文件，<br>如果加了分号：先查询classpath指定的路径，再查找当前目录下是否有.class文件。<br>注意：通常配置classpath会以.;开头，表示先查询的是当前路径<br>CLASSPATH=.;%JAVA_HOME%\lib\tools.jar;%JAVA_HOME%\lib\dt.jar;</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[计算机的基础]]></title>
      <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%9F%BA%E7%A1%80.html</url>
      <content type="html"><![CDATA[<h2 id="1、计算机的组成：硬件和软件"><a href="#1、计算机的组成：硬件和软件" class="headerlink" title="1、计算机的组成：硬件和软件"></a>1、计算机的组成：硬件和软件</h2><h2 id="2、硬件：物理设备（主板、CPU、显示器、存储设备、外设、内存条）"><a href="#2、硬件：物理设备（主板、CPU、显示器、存储设备、外设、内存条）" class="headerlink" title="2、硬件：物理设备（主板、CPU、显示器、存储设备、外设、内存条）"></a>2、硬件：物理设备（主板、CPU、显示器、存储设备、外设、内存条）</h2><h2 id="3、没有软件的计算机：裸机"><a href="#3、没有软件的计算机：裸机" class="headerlink" title="3、没有软件的计算机：裸机"></a>3、没有软件的计算机：裸机</h2><h2 id="4、软件：按照一定顺序和逻辑组成的计算机指令——-程序、软件。"><a href="#4、软件：按照一定顺序和逻辑组成的计算机指令——-程序、软件。" class="headerlink" title="4、软件：按照一定顺序和逻辑组成的计算机指令——-程序、软件。"></a>4、软件：按照一定顺序和逻辑组成的计算机指令——-程序、软件。</h2><p>软件 = 程序 +　数据结构。</p>
<h2 id="5、软件开发：制作软件的过程。"><a href="#5、软件开发：制作软件的过程。" class="headerlink" title="5、软件开发：制作软件的过程。"></a>5、软件开发：制作软件的过程。</h2><h2 id="6、人机交互：命令（dos）、图形界面。"><a href="#6、人机交互：命令（dos）、图形界面。" class="headerlink" title="6、人机交互：命令（dos）、图形界面。"></a>6、人机交互：命令（dos）、图形界面。</h2><h2 id="7、计算机语言：人和计算机交流的一种方式。"><a href="#7、计算机语言：人和计算机交流的一种方式。" class="headerlink" title="7、计算机语言：人和计算机交流的一种方式。"></a>7、计算机语言：人和计算机交流的一种方式。</h2><h2 id="8、计算机语言的分类："><a href="#8、计算机语言的分类：" class="headerlink" title="8、计算机语言的分类："></a>8、计算机语言的分类：</h2><p>a)  机器语言<br>b) 汇编语言<br>c) 高级语言：c , c++ , java , scala , python<br>越高级的语言越接近人们的习惯。越高级的语言执行效率是越低的。<br><a id="more"></a></p>
<h2 id="9、操作系统"><a href="#9、操作系统" class="headerlink" title="9、操作系统"></a>9、操作系统</h2><h2 id="10、了解一些常见的dos命令：win-r-—-gt-运行"><a href="#10、了解一些常见的dos命令：win-r-—-gt-运行" class="headerlink" title="10、了解一些常见的dos命令：win+r —-&gt;运行"></a>10、了解一些常见的dos命令：win+r —-&gt;运行</h2><p>a) dir 显示当前目录信息<br>b) cd.. 回到上一级目录<br>c) cd. 到当前目录<br>d) cd/ 到根目录<br>e) D: 到D盘<br>f) cd path — &gt; 到指定的目录，不能跳盘符<br>g) md 目录名  — &gt; 新建一个目录 make directory<br>h) ren oldname newname —–&gt; 重命名 rename<br>i) rd 目录名 —-&gt;删除目录 remove directory<br>j) move 文件 目标目录 —–&gt; 移动文件<br>k) notepad 打开记事本<br>l) copy 源文件 目标文件 —–&gt; 复制文件<br>m) del 文件名 —-&gt; 删除文件<br>n) cls 清屏</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MySQL备份]]></title>
      <url>/MySQL%E5%A4%87%E4%BB%BD.html</url>
      <content type="html"><![CDATA[<h2 id="定时完成数据库的备份"><a href="#定时完成数据库的备份" class="headerlink" title="定时完成数据库的备份"></a>定时完成数据库的备份</h2><h3 id="①-手动备份数据库-表的-方法"><a href="#①-手动备份数据库-表的-方法" class="headerlink" title="①    手动备份数据库(表的)方法"></a>①    手动备份数据库(表的)方法</h3><p>cmd控制台:<br>mysqldump –u root –proot 数据库 [表名1 表名2..]  &gt; 文件路径<br>比如: 把temp数据库备份到 d:\temp.bak<br>mysqldump –u root –proot temp &gt; d:\temp.bak<br>如果你希望备份是，数据库的某几张表<br>mysqldump –u root –prot temp dept &gt; d:\temp.dept.bak</p>
<h2 id="如何使用备份文件恢复我们的数据"><a href="#如何使用备份文件恢复我们的数据" class="headerlink" title="如何使用备份文件恢复我们的数据."></a>如何使用备份文件恢复我们的数据.</h2><p>mysql控制台<br>source d:\temp.dept.bak<br><a id="more"></a></p>
<h3 id="②-使用定时器来自定完成"><a href="#②-使用定时器来自定完成" class="headerlink" title="②    使用定时器来自定完成"></a>②    使用定时器来自定完成</h3><p>把备份数据库的指令，写入到 bat文件, 然后通过任务管理器去定时调用 bat文件.<br>mytask.bat 内容是:<br>C:\myenv\mysql5.5.27\bin\mysqldump -u root -proot temp dept &gt; d:\temp.dept.bak<br>☞ 如果你的mysqldump.exe文件路径有空格，则一定要使用 “” 包括.<br>把mytask.bat 做成一个任务，并定时调用在 2:00 调用一次<br>步骤 任务计划-&gt;增加一个任务，选中你的mytask.bat文件 ，最后配置:<br>测试ok</p>
<h2 id="如何在linux下完成定时任务"><a href="#如何在linux下完成定时任务" class="headerlink" title="如何在linux下完成定时任务:"></a>如何在linux下完成定时任务:</h2><p>linux如何备份.</p>
<ol>
<li>直接执行PHP脚本, 需要在同一个服务器上执行.<h1 id="crontab-e"><a href="#crontab-e" class="headerlink" title="crontab -e"></a>crontab -e</h1>00 <em> </em> <em> </em> /usr/local/bin/php /home/htdocs/phptimer.php<br>2.通过HTTP请求来触发脚本, PHP文件允许不在同一服务器上<h1 id="crontab-e-1"><a href="#crontab-e-1" class="headerlink" title="crontab -e"></a>crontab -e</h1>00 <em> </em> <em> </em> /usr/bin/wget -q -O temp.txt <span class="exturl" data-url="aHR0cDovL3d3dy5waHB0aW1lci5jb20vcGhwdGltZXIucGhw" title="http://www.phptimer.com/phptimer.php">http://www.phptimer.com/phptimer.php<i class="fa fa-external-link"></i></span><br>上面是通过wget来请求PHP文件, PHP输出会保存在临时文件temp.txt中<h1 id="crontab-e-2"><a href="#crontab-e-2" class="headerlink" title="crontab -e"></a>crontab -e</h1>00 <em> </em> <em> </em> /usr/bin/curl -o temp.txt <span class="exturl" data-url="aHR0cDovL3d3dy5waHB0aW1lci5jb20vcGhwdGltZXIucGhw" title="http://www.phptimer.com/phptimer.php">http://www.phptimer.com/phptimer.php<i class="fa fa-external-link"></i></span><br>上面是通过curl -o来请求PHP文件, PHP输出会保存在临时文件temp.txt中<h1 id="crontab-e-3"><a href="#crontab-e-3" class="headerlink" title="crontab -e"></a>crontab -e</h1>00 <em> </em> <em> </em> lynx -dump <span class="exturl" data-url="aHR0cDovL3d3dy5waHB0aW1lci5jb20vcGhwdGltZXIucGhw" title="http://www.phptimer.com/phptimer.php">http://www.phptimer.com/phptimer.php<i class="fa fa-external-link"></i></span><br>上面是通过Lynx文本浏览器来请求PHP文件</li>
</ol>
<h2 id="分表技术"><a href="#分表技术" class="headerlink" title="分表技术"></a>分表技术</h2><p>分表技术有(水平分割和垂直分割)<br>当一张越来越大时候，即使添加索引还慢的话，我们可以使用分表<br>以qq用户表来具体的说明一下分表的操作.<br>思路如图 ：<br>首先我创建三张表 user0 / user1 /user2 , 然后我再创建 uuid表，该表的作用就是提供自增的id,<br>走代码:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> user0(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">int</span> <span class="keyword">unsigned</span> primary <span class="keyword">key</span> ,</span><br><span class="line"><span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">default</span> <span class="string">''</span>,</span><br><span class="line">pwd  <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">default</span> <span class="string">''</span>)</span><br><span class="line"><span class="keyword">engine</span>=myisam <span class="keyword">charset</span> utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> user1(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">int</span> <span class="keyword">unsigned</span> primary <span class="keyword">key</span> ,</span><br><span class="line"><span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">default</span> <span class="string">''</span>,</span><br><span class="line">pwd  <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">default</span> <span class="string">''</span>)</span><br><span class="line"><span class="keyword">engine</span>=myisam <span class="keyword">charset</span> utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> user2(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">int</span> <span class="keyword">unsigned</span> primary <span class="keyword">key</span> ,</span><br><span class="line"><span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">default</span> <span class="string">''</span>,</span><br><span class="line">pwd  <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">default</span> <span class="string">''</span>)</span><br><span class="line"><span class="keyword">engine</span>=myisam <span class="keyword">charset</span> utf8;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">uuid</span>(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">int</span> <span class="keyword">unsigned</span> primary <span class="keyword">key</span> auto_increment)<span class="keyword">engine</span>=myisam <span class="keyword">charset</span> utf8;</span><br></pre></td></tr></table></figure></p>
<p>思考: 如果我们做的是一个平安保险公司的一个订单(8999999999000000条)查询功能更.<br>,如何处理海量表?-&gt;按时间.</p>
<ol>
<li>分表的标准是依赖业务逻辑(时间/地区/….)</li>
<li>安装字符不同. a-z</li>
<li>我们给用户提供的查询界面一定是有条件，不能让用户进行大范围.(世界)，如果需要的可以根据不同的规则，对应多套分表.</li>
<li>检索时候，带分页条件，减少返回的数据.</li>
<li>项目中，灵活的根据需求来考虑.</li>
</ol>
<h2 id="垂直分割"><a href="#垂直分割" class="headerlink" title="垂直分割"></a>垂直分割</h2><p>如果一张表某个字段，信息量大，但是我们很少查询，则可以考虑把这些字段，单独的放入到一张表中，这种方式称为垂直分割.</p>
]]></content>
      
        <categories>
            
            <category> 数据库 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Intellij IDEA 激活方法]]></title>
      <url>/Intellij%20IDEA%20%E6%BF%80%E6%B4%BB%E6%96%B9%E6%B3%95.html</url>
      <content type="html"><![CDATA[<h2 id="填入下面的license-server"><a href="#填入下面的license-server" class="headerlink" title="填入下面的license server:"></a>填入下面的license server:</h2><p>　　<span class="exturl" data-url="aHR0cDovL2ludGVsbGlqLm1hbmRyb2lkLmNuLw==" title="http://intellij.mandroid.cn/">http://intellij.mandroid.cn/<i class="fa fa-external-link"></i></span><br>　　<span class="exturl" data-url="aHR0cDovL2lkZWEuaW1zeG0uY29tLw==" title="http://idea.imsxm.com/">http://idea.imsxm.com/<i class="fa fa-external-link"></i></span><br>　　<span class="exturl" data-url="aHR0cDovL2lkZWEuaXRlYmxvZy5jb20va2V5LnBocA==" title="http://idea.iteblog.com/key.php">http://idea.iteblog.com/key.php<i class="fa fa-external-link"></i></span></p>
]]></content>
      
        <categories>
            
            <category> 有料 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 编程工具 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MySQL优化（二）]]></title>
      <url>/MySQL%E4%BC%98%E5%8C%96%EF%BC%88%E4%BA%8C%EF%BC%89.html</url>
      <content type="html"><![CDATA[<h2 id="四种索引-主键索引-唯一索引-全文索引-普通索引"><a href="#四种索引-主键索引-唯一索引-全文索引-普通索引" class="headerlink" title="四种索引(主键索引/唯一索引/全文索引/普通索引)"></a>四种索引(主键索引/唯一索引/全文索引/普通索引)</h2><h3 id="1-添加"><a href="#1-添加" class="headerlink" title="1.    添加"></a>1.    添加</h3><h4 id="1-1主键索引添加"><a href="#1-1主键索引添加" class="headerlink" title="1.1主键索引添加"></a>1.1主键索引添加</h4><p>当一张表，把某个列设为主键的时候，则该列就是主键索引<br>create table aaa (id int unsigned primary key auto_increment , name varchar(32) not null defaul ‘’);<br>这是id 列就是主键索引.<br>如果你创建表时，没有指定主键索引，也可以在创建表后，在添加, 指令:<br>alter table 表名 add primary key (列名);<br>举例:<br>create table bbb (id int , name varchar(32) not null default ‘’);<br>alter table bbb add primary key (id);</p>
<h4 id="1-2普通索引"><a href="#1-2普通索引" class="headerlink" title="1.2普通索引"></a>1.2普通索引</h4><p>一般来说，普通索引的创建，是先创建表，然后在创建普通索引<br>比如:<br>create table ccc(<br>id int unsigned,<br>name varchar(32)<br>)<br>create index 索引名 on 表 (列1,列名2);<br><a id="more"></a></p>
<h4 id="1-3创建全文索引"><a href="#1-3创建全文索引" class="headerlink" title="1.3创建全文索引"></a>1.3创建全文索引</h4><p>全文索引，主要是针对对文件，文本的检索, 比如文章, 全文索引针对MyISAM有用.<br>创建 ：<br>CREATE TABLE articles (<br>       id INT UNSIGNED AUTO_INCREMENT NOT NULL PRIMARY KEY,<br>       title VARCHAR(200),<br>       body TEXT,<br>       FULLTEXT (title,body)<br>     )engine=myisam charset utf8;</p>
<p>INSERT INTO articles (title,body) VALUES<br>     (‘MySQL Tutorial’,’DBMS stands for DataBase …’),<br>     (‘How To Use MySQL Well’,’After you went through a …’),<br>     (‘Optimizing MySQL’,’In this tutorial we will show …’),<br>     (‘1001 MySQL Tricks’,’1. Never run mysqld as root. 2. …’),<br>     (‘MySQL vs. YourSQL’,’In the following database comparison …’),<br>     (‘MySQL Security’,’When configured properly, MySQL …’);</p>
<p>如何使用全文索引:<br>错误用法:<br>select <em> from articles where body like ‘%mysql%’; 【不会使用到全文索引】<br>证明:<br>explain  select </em> from articles where body like ‘%mysql%’</p>
<p>正确的用法是:<br>select * from articles where match(title,body) against(‘database’); 【可以】</p>
<p>☞ 说明:</p>
<ol>
<li>在mysql中fulltext 索引只针对 myisam生效</li>
<li>mysql自己提供的fulltext针对英文生效-&gt;sphinx (coreseek) 技术处理中文</li>
<li>使用方法是 match(字段名..) against(‘关键字’)</li>
<li>全文索引一个 叫 停止词,  因为在一个文本中，创建索引是一个无穷大的数，因此，对一些常用词和字符，就不会创建，这些词，称为停止词.</li>
</ol>
<h4 id="1-4唯一索引"><a href="#1-4唯一索引" class="headerlink" title="1.4唯一索引"></a>1.4唯一索引</h4><p>①当表的某列被指定为unique约束时，这列就是一个唯一索引<br>create table ddd(id int primary key auto_increment , name varchar(32) unique);<br>这时, name 列就是一个唯一索引.<br>unique字段可以为NULL,并可以有多NULL, 但是如果是具体内容，则不能重复.<br>主键字段，不能为NULL,也不能重复.<br>②在创建表后，再去创建唯一索引<br>create table eee(id int primary key auto_increment, name varchar(32));<br>create unique index 索引名  on 表名 (列表..);</p>
<h3 id="2-查询索引"><a href="#2-查询索引" class="headerlink" title="2.    查询索引"></a>2.    查询索引</h3><p>desc 表名 【该方法的缺点是：　不能够显示索引名.】<br>show index(es) from 表名<br>show keys from 表名</p>
<p>###　3.    删除</p>
<p>alter table 表名 drop index 索引名;<br>如果删除主键索引。<br>alter table 表名 drop primary key       [这里有一个小问题]</p>
<h3 id="4-修改"><a href="#4-修改" class="headerlink" title="4.    修改"></a>4.    修改</h3><p>先删除，再重新创建.<br>为什么创建索引后，速度就会变快?</p>
<h2 id="索引使用的注意事项"><a href="#索引使用的注意事项" class="headerlink" title="索引使用的注意事项"></a>索引使用的注意事项</h2><h3 id="索引的代价"><a href="#索引的代价" class="headerlink" title="索引的代价:"></a>索引的代价:</h3><ol>
<li>占用磁盘空间</li>
<li>对dml操作有影响，变慢</li>
</ol>
<h2 id="在哪些列上适合添加索引"><a href="#在哪些列上适合添加索引" class="headerlink" title="在哪些列上适合添加索引?"></a>在哪些列上适合添加索引?</h2><p>总结: 满足以下条件的字段，才应该创建索引.<br>a: 肯定在where条经常使用 b: 该字段的内容不是唯一的几个值(sex) c: 字段内容不是频繁变化.</p>
<h2 id="使用索引的注意事项"><a href="#使用索引的注意事项" class="headerlink" title="使用索引的注意事项"></a>使用索引的注意事项</h2><p>把dept表中，我增加几个部门:<br>alter table dept add index my<em>ind (dname,loc); //  dname 左边的列,loc就是右边的列<br>说明，如果我们的表中有复合索引(索引作用在多列上)， 此时我们注意:<br>1，    对于创建的多列索引，只要查询条件使用了最左边的列，索引一般就会被使用。<br>explain select <em> from dept where loc=’aaa’\G<br>就不会使用到索引<br>2，对于使用like的查询，查询如果是  ‘%aaa’ 不会使用到索引<br>    ‘aaa%’ 会使用到索引。<br>比如: explain select </em> from dept where dname like ‘%aaa’\G<br>不能使用索引，即，在like查询时，关键的 ‘关键字’ , 最前面，不能使用 % 或者 </em>这样的字符.， 如果一定要前面有变化的值，则考虑使用 全文索引-&gt;sphinx.</p>
<ol>
<li>如果条件中有or，即使其中有条件带索引也不会使用。换言之，就是要求使用的所有字段，都必须建立索引, 我们建议大家尽量避免使用or 关键字<br>select * from dept where dname=’xxx’ or loc=’xx’ or deptno=45</li>
<li>如果列类型是字符串，那一定要在条件中将数据使用引号引用起来。否则不使用索引。(添加时,字符串必须’’), 也就是，如果列是字符串类型，就一定要用 ‘’ 把他包括起来.</li>
<li>如果mysql估计使用全表扫描要比使用索引快，则不使用索引。<br>explain 可以帮助我们在不真正执行某个sql语句时，就执行mysql怎样执行，这样利用我们去分析sql指令.</li>
</ol>
<h2 id="如何查看索引使用的情况"><a href="#如何查看索引使用的情况" class="headerlink" title="如何查看索引使用的情况:"></a>如何查看索引使用的情况:</h2><p>show status like ‘Handler_read%’;<br>大家可以注意：<br>handler_read_key:这个值越高越好，越高表示使用索引查询到的次数。<br>    handler_read_rnd_next:这个值越高，说明查询低效。</p>
<h2 id="sql语句的小技巧"><a href="#sql语句的小技巧" class="headerlink" title="sql语句的小技巧"></a>sql语句的小技巧</h2><ol>
<li>在使用group by 分组查询是，默认分组后，还会排序，可能会降低速度.<br>比如:<br>在group by 后面增加 order by null 就可以防止排序.</li>
<li>有些情况下，可以使用连接来替代子查询。因为使用join，MySQL不需要在内存中创建临时表。<br>select <em> from dept, emp where dept.deptno=emp.deptno; [简单处理方式]<br>select </em> from dept left join emp on dept.deptno=emp.deptno;  [左外连接，更ok!]</li>
</ol>
<h2 id="如何选择mysql的存储引擎"><a href="#如何选择mysql的存储引擎" class="headerlink" title="如何选择mysql的存储引擎"></a>如何选择mysql的存储引擎</h2><p>在开发中，我们经常使用的存储引擎 myisam / innodb/ memory<br>myisam 存储: 如果表对事务要求不高，同时是以查询和添加为主的，我们考虑使用myisam存储引擎. ,比如 bbs 中的 发帖表，回复表.<br>INNODB 存储: 对事务要求高，保存的数据都是重要数据，我们建议使用INNODB,比如订单表，账号表.</p>
<h2 id="问-MyISAM-和-INNODB的区别"><a href="#问-MyISAM-和-INNODB的区别" class="headerlink" title="问 MyISAM 和 INNODB的区别"></a>问 MyISAM 和 INNODB的区别</h2><ol>
<li>事务安全</li>
<li>查询和添加速度</li>
<li>支持全文索引</li>
<li>锁机制</li>
<li>外键 MyISAM 不支持外键， INNODB支持外键. (在PHP开发中，通常不设置外键，通常是在程序中保证数据的一致)<br>Memory 存储，比如我们数据变化频繁，不需要入库，同时又频繁的查询和修改，我们考虑使用memory, 速度极快. </li>
</ol>
<h2 id="如果你的数据库的存储引擎是myisam-请一定记住要定时进行碎片整理"><a href="#如果你的数据库的存储引擎是myisam-请一定记住要定时进行碎片整理" class="headerlink" title="如果你的数据库的存储引擎是myisam,请一定记住要定时进行碎片整理"></a>如果你的数据库的存储引擎是myisam,请一定记住要定时进行碎片整理</h2><p>举例说明:<br>create table test100(id int unsigned ,name varchar(32))engine=myisam;<br>insert into test100 values(1,’aaaaa’);<br>insert into test100 values(2,’bbbb’);<br>insert into test100 values(3,’ccccc’);<br>我们应该定义对myisam进行整理<br>optimize table test100;<br>mysql_query(“optimize tables $表名”);</p>
]]></content>
      
        <categories>
            
            <category> 数据库 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MySQL优化（一）]]></title>
      <url>/MySQL%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89.html</url>
      <content type="html"><![CDATA[<h2 id="MySQL数据库的优化技术"><a href="#MySQL数据库的优化技术" class="headerlink" title="MySQL数据库的优化技术"></a>MySQL数据库的优化技术</h2><h3 id="对MySQL优化时一个综合性的技术，主要包括"><a href="#对MySQL优化时一个综合性的技术，主要包括" class="headerlink" title="对MySQL优化时一个综合性的技术，主要包括"></a>对MySQL优化时一个综合性的技术，主要包括</h3><p>1、表的设计合理化（符合 3NF）<br>2、添加适当索引(index)：普通索引、主键索引、唯一索引(unique)、全文索引<br>3、分表技术（水平分割、垂直分割）<br>4、读写分离<br>5、存储过程（模块化编程，可以提供读写速度）<br>6、对MySQL配置优化（配置最大并发数my.ini，调整缓存大小）<br>7、升级MySQL服务器硬件<br>8、定时清楚不需要的数据，定时进行碎片处理（MyISAM）</p>
<h2 id="什么样的表才是符合3NF"><a href="#什么样的表才是符合3NF" class="headerlink" title="什么样的表才是符合3NF"></a>什么样的表才是符合3NF</h2><p>表的范式，是首先符合1NF，才能满足2NF，进一步满足3NF<br>1NF：即表的列具有原子性，不可再分解，即列的信息，不能分解，只要数据库是关系型数据库（mysql/oracle/db2/infomix/sysbase/sql server），就自动满足1NF<br><a id="more"></a></p>
<h3 id="数据库的分类"><a href="#数据库的分类" class="headerlink" title="数据库的分类"></a>数据库的分类</h3><p>关系型数据库：MySQL/oracle/db2/infomix/sysbase/sql server<br>非关系型数据库：（特点：面向对象或者集合）<br>NoSQL数据库：MongoDB(特点是面向文档)<br>2NF：表中的记录是唯一的，就满足2NF，通常我们设计一个主键来实现<br>3NF：即表中不要冗余数据，就是说，表的信息，如果能够被推导出来，就不应该单独的设计一个字段来存放。</p>
<h2 id="SQL语句本身的优化"><a href="#SQL语句本身的优化" class="headerlink" title="SQL语句本身的优化"></a>SQL语句本身的优化</h2><p>问题是： 如何从一个大项目中，迅速的定位执行速度慢的语句. (定位慢查询)<br>①    首先我们了解mysql数据库的一些运行状态如何查询(比如想知道当前mysql运行的时间/一共执行了多少次select/update/delete.. / 当前连接)<br>show status<br>常用的:<br>show status like ‘uptime’ ;<br>show  stauts like ‘com_select’  show stauts like ‘com_insert’ …类推 update  delete<br>☞ show [session|global] status like …. 如果你不写  [session|global] 默认是session 会话，指取出当前窗口的执行，如果你想看所有(从mysql 启动到现在，则应该 global)<br>show status like ‘connections’;<br>//显示慢查询次数<br>show status like ‘slow_queries’;</p>
<p>②    如何去定位慢查询<br>构建一个大表(400 万)-&gt; 存储过程构建<br>默认情况下，mysql认为10秒才是一个慢查询.<br>    修改mysql的慢查询.<br>show variables like ‘long_query_time’ ; //可以显示当前慢查询时间<br>set long_query_time=1 ;//可以修改慢查询时间</p>
<p>构建大表-&gt;大表中记录有要求, 记录是不同才有用，否则测试效果和真实的相差大.<br>创建:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> dept( <span class="comment">/*部门表*/</span></span><br><span class="line">deptno MEDIUMINT   <span class="keyword">UNSIGNED</span>  <span class="keyword">NOT</span> <span class="literal">NULL</span>  <span class="keyword">DEFAULT</span> <span class="number">0</span>,  <span class="comment">/*编号*/</span></span><br><span class="line">dname <span class="built_in">VARCHAR</span>(<span class="number">20</span>)  <span class="keyword">NOT</span> <span class="literal">NULL</span>  <span class="keyword">DEFAULT</span> <span class="string">""</span>, <span class="comment">/*名称*/</span></span><br><span class="line">loc <span class="built_in">VARCHAR</span>(<span class="number">13</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">""</span> <span class="comment">/*地点*/</span></span><br><span class="line">) <span class="keyword">ENGINE</span>=MyISAM <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp</span><br><span class="line">(empno  MEDIUMINT <span class="keyword">UNSIGNED</span>  <span class="keyword">NOT</span> <span class="literal">NULL</span>  <span class="keyword">DEFAULT</span> <span class="number">0</span>, <span class="comment">/*编号*/</span></span><br><span class="line">ename <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">""</span>, <span class="comment">/*名字*/</span></span><br><span class="line">job <span class="built_in">VARCHAR</span>(<span class="number">9</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">""</span>,<span class="comment">/*工作*/</span></span><br><span class="line">mgr MEDIUMINT <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,<span class="comment">/*上级编号*/</span></span><br><span class="line">hiredate <span class="built_in">DATE</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,<span class="comment">/*入职时间*/</span></span><br><span class="line">sal <span class="built_in">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>)  <span class="keyword">NOT</span> <span class="literal">NULL</span>,<span class="comment">/*薪水*/</span></span><br><span class="line">comm <span class="built_in">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,<span class="comment">/*红利*/</span></span><br><span class="line">deptno MEDIUMINT <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="comment">/*部门编号*/</span></span><br><span class="line">)<span class="keyword">ENGINE</span>=MyISAM <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> salgrade</span><br><span class="line">(</span><br><span class="line">grade MEDIUMINT <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">losal <span class="built_in">DECIMAL</span>(<span class="number">17</span>,<span class="number">2</span>)  <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">hisal <span class="built_in">DECIMAL</span>(<span class="number">17</span>,<span class="number">2</span>)  <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line">)<span class="keyword">ENGINE</span>=MyISAM <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure></p>
<p>测试数据：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> salgrade <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="number">700</span>,<span class="number">1200</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> salgrade <span class="keyword">VALUES</span> (<span class="number">2</span>,<span class="number">1201</span>,<span class="number">1400</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> salgrade <span class="keyword">VALUES</span> (<span class="number">3</span>,<span class="number">1401</span>,<span class="number">2000</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> salgrade <span class="keyword">VALUES</span> (<span class="number">4</span>,<span class="number">2001</span>,<span class="number">3000</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> salgrade <span class="keyword">VALUES</span> (<span class="number">5</span>,<span class="number">3001</span>,<span class="number">9999</span>);</span><br></pre></td></tr></table></figure></p>
<p>为了存储过程能够正常执行，我们需要把命令执行结束符修改<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">delimiter $$</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> rand_string(n <span class="built_in">INT</span>) </span><br><span class="line"><span class="keyword">returns</span> <span class="built_in">varchar</span>(<span class="number">255</span>) #该函数会返回一个字符串</span><br><span class="line"><span class="keyword">begin</span> </span><br><span class="line">#chars_str定义一个变量 chars_str,类型是 <span class="built_in">varchar</span>(<span class="number">100</span>),默认值<span class="string">'abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ'</span>;</span><br><span class="line"> <span class="keyword">declare</span> chars_str <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">default</span></span><br><span class="line">   <span class="string">'abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ'</span>;</span><br><span class="line"> <span class="keyword">declare</span> return_str <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">default</span> <span class="string">''</span>;</span><br><span class="line"> <span class="keyword">declare</span> i <span class="built_in">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line"> while i &lt; n do </span><br><span class="line">   <span class="keyword">set</span> return_str =<span class="keyword">concat</span>(return_str,<span class="keyword">substring</span>(chars_str,<span class="keyword">floor</span>(<span class="number">1</span>+<span class="keyword">rand</span>()*<span class="number">52</span>),<span class="number">1</span>));</span><br><span class="line">   <span class="keyword">set</span> i = i + <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">end</span> <span class="keyword">while</span>;</span><br><span class="line">  return return_str;</span><br><span class="line">  <span class="keyword">end</span> $$</span><br></pre></td></tr></table></figure></p>
<p>创建一个存储过程:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> insert_emp(<span class="keyword">in</span> <span class="keyword">start</span> <span class="built_in">int</span>(<span class="number">10</span>),<span class="keyword">in</span> max_num <span class="built_in">int</span>(<span class="number">10</span>))</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">declare</span> i <span class="built_in">int</span> <span class="keyword">default</span> <span class="number">0</span>; </span><br><span class="line">#set autocommit =0 把autocommit设置成0</span><br><span class="line"> <span class="keyword">set</span> autocommit = <span class="number">0</span>;  </span><br><span class="line"> repeat</span><br><span class="line"> <span class="keyword">set</span> i = i + <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">insert</span> <span class="keyword">into</span> emp <span class="keyword">values</span> ((<span class="keyword">start</span>+i) ,rand_string(<span class="number">6</span>),<span class="string">'SALESMAN'</span>,<span class="number">0001</span>,<span class="keyword">curdate</span>(),<span class="number">2000</span>,<span class="number">400</span>,rand_num());</span><br><span class="line">  until i = max_num</span><br><span class="line"> <span class="keyword">end</span> <span class="keyword">repeat</span>;</span><br><span class="line">   <span class="keyword">commit</span>;</span><br><span class="line"> <span class="keyword">end</span> $$</span><br></pre></td></tr></table></figure></p>
<p>#调用刚刚写好的函数, 1800000条记录,从100001号开始<br>call insert_emp(100001,4000000);<br>③    这时我们如果出现一条语句执行时间超过1秒中，就会统计到.<br>④    如果把慢查询的sql记录到我们的一个日志中<br>在默认情况下，我们的mysql不会记录慢查询，需要在启动mysql时候，指定记录慢查询才可以<br>bin\mysqld.exe - -safe-mode  - -slow-query-log [mysql5.5 可以在my.ini指定]<br>bin\mysqld.exe –log-slow-queries=d:/abc.log [低版本mysql5.0可以在my.ini指定]</p>
<p>先关闭mysql,再启动, 如果启用了慢查询日志，默认把这个文件放在<br>my.ini 文件中记录的位置</p>
<p>#Path to the database root<br>datadir=”C:/Documents and Settings/All Users/Application Data/MySQL/MySQL Server 5.5/Data/“</p>
<p>⑤    测试,可以看到在日志中就记录下我们的mysql慢sql语句.<br>优化问题.<br>通过 explain 语句可以分析，mysql如何执行你的sql语句</p>
]]></content>
      
        <categories>
            
            <category> 数据库 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[如何阅读源代码]]></title>
      <url>/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E6%BA%90%E4%BB%A3%E7%A0%81.html</url>
      <content type="html"><![CDATA[<p>阅读别人的代码作为开发人员是一件经常要做的事情。一个是学习新的编程语言的时候通过阅读别人的代码是一个最好的学习方法，另外是积累编程经验。如果你有机会阅读一些操作系统的代码会帮助你理解一些基本的原理。还有就是在你作为一个质量保证人员或一个小领导的时候如果你要做白盒测试的时候没有阅读代码的能力是不能完成相应的任务。最后一个就是如果你中途接手一个项目的时候或给一个项目做售后服务的时候是要有阅读代码的能力的。</p>
<h2 id="收集所有可能收集的材料"><a href="#收集所有可能收集的材料" class="headerlink" title="收集所有可能收集的材料"></a>收集所有可能收集的材料</h2><p>　　阅读代码要做的第一件事情是收集所有和项目相关的资料。比如你要做一个项目的售后服务，那么你首先要搞明白项目做什么用的，那么调研文档、概要设计文档、详细设计文档、测试文档、使用手册都是你要最先搞到手的。如果你是为了学习那么尽量收集和你的学习有关的资料，比如你想学习Linux的文件系统的代码，那最好要找到linux的使用手册、以及文件系统设计的方法、数据结构的说明。(这些资料在书店里都可以找到)。<br><a id="more"></a></p>
<h2 id="材料的种类分为几种类型"><a href="#材料的种类分为几种类型" class="headerlink" title="材料的种类分为几种类型"></a>材料的种类分为几种类型</h2><h3 id="基础资料。"><a href="#基础资料。" class="headerlink" title="基础资料。"></a>基础资料。</h3><p>　　比如你阅读turbo c2的源代码你要有turbo c2的函数手册，使用手册等专业书籍，msc 6.0或者Java 的话不但要有函数手册，还要有类库函数手册。这些资料都是你的基础资料。另外你要有一些关于uml的资料可以作为查询手册也是一个不错的选择</p>
<h3 id="和程序相关的专业资料。"><a href="#和程序相关的专业资料。" class="headerlink" title="和程序相关的专业资料。"></a>和程序相关的专业资料。</h3><p>　　每一个程序都是和相关行业相关的。比如我阅读过一个关于气象分析方面的代码，因为里边用到了一个复杂的数据转换公式，所以不得不把自己的大学时候课本 找出来来复习一下高等数学的内容。如果你想阅读linux的文件管理的代码，那么找一本讲解linux文件系统的书对你的帮助会很大。</p>
<h3 id="相关项目的文档资料"><a href="#相关项目的文档资料" class="headerlink" title="相关项目的文档资料"></a>相关项目的文档资料</h3><p>　　这一部分的资料分为两种，一个相关行业的资料，比如你要阅读一个税务系统的代码那么有一些财务/税务系统的专业资料和国家的相关的法律、法规的资料是 必不可少的。此外就是关于这个项目的需求分析报告、概要设计报告、详细设计报告，使用手册、测试报告等，尽量多收集对你以后的代码阅读是很重要的</p>
<h2 id="知识准备"><a href="#知识准备" class="headerlink" title="知识准备"></a>知识准备</h2><p>　　了解基础知识，不要上来就阅读代码，打好基础可以做到事半功倍的效果</p>
<h2 id="留备份-构造可运行的环境"><a href="#留备份-构造可运行的环境" class="headerlink" title="留备份,构造可运行的环境"></a>留备份,构造可运行的环境</h2><p>　　代码拿到手之后的第一件事情是先做备份，最好是刻在一个光盘上，在代码阅读的时候一点不动代码是很困难的一件事情，特别是你要做一些修改性或增强性维护的时候。而一旦做修改就可能发生问题，到时候要恢复是经常发生的事情，如果你不能很好的使用版本控制软件那么先留一个备份是一个最起码的要求了。<br>　　在做完备份之后最好给自己构造一个可运行的环境，当然可能会很麻烦，但可运行代码和不可运行的代码阅读起来难度会差很多的。所以多用一点时间搭建一个环境是很值得的，而且我们阅读代码主要是为了修改其中的问题或做移植操作。不能运行的代码除了可以学到一些技术以外，用处有限。</p>
<h2 id="找开始的地方"><a href="#找开始的地方" class="headerlink" title="找开始的地方"></a>找开始的地方</h2><p>　　做什么事情都要知道从那里开始，读程序也不例外。在C语言里,首先要找到main()函数，然后逐层去阅读，其他的程序无论是vb、delphi都要首先找到程序头，否则你是很难分析清楚程序的层次关系。</p>
<h2 id="分层次阅读"><a href="#分层次阅读" class="headerlink" title="分层次阅读"></a>分层次阅读</h2><p>　　在阅读代码的时候不要一头就扎下去，这样往往容易只见树木不见森林，阅读代码比较好的方法有一点象二叉树的广度优先的遍历。在程序主体一般会比较简 单，调用的函数会比较少，根据函数的名字以及层次关系一般可以确定每一个函数的大致用途，将你的理解作为注解写在这些函数的边上。当然很难一次就将全部注 解都写正确，有时候甚至可能是你猜测的结果，不过没有关系这些注解在阅读过程是不断修正的，直到你全部理解了代码为止。一般来说采用逐层阅读的方法可以是 你系统的理解保持在一个正确的方向上。避免一下子扎入到细节的问题上。在分层次阅读的时候要注意一个问题，就是将系统的函数和开发人员编写代码区分开。在 c, c++，java ,delphi中都有自己的系统函数，不要去阅读这些系统函数，除非你要学习他们的编程方法，否则只会浪费你的时间。将系统函数表示出来，注明它们的作用 即可，区分系统函数和自编函数有几个方法，一个是系统函数的编程风格一般会比较好，而自编的函数的编程风格一般比较会比较差。从变量名、行之间的缩进、注 解等方面一般可以分辨出来，另外一个是象ms c6++会在你编程的时候给你生成一大堆文件出来，其中有很多文件是你用不到了，可以根据文件名来区分一下时候是系统函数，最后如果你实在确定不了，那就 用开发系统的帮助系统去查一下函数名，对一下参数等来确定即可。</p>
<h2 id="写注解"><a href="#写注解" class="headerlink" title="写注解"></a>写注解</h2><p>　　写注解是在阅读代码中最重要的一个步骤，在我们阅读的源代码一般来说是我们不熟悉的系统,阅读别人的代码一般会有几个问题，1搞明白别人的编程思想不 是一件很容易的事情，即使你知道这段程序的思路的时候也是一样。2阅读代码的时候代码量一般会比较大，如果不及时写注解往往会造成读明白了后边忘了前边的 现象。3阅读代码的时候难免会出现理解错误，如果没有及时的写注解很难及时的发现这些错误。4不写注解有时候你发生你很难确定一个函数你时候阅读过，它的功能是什么，经常会发生重复阅读、理解的现象。<br>　　好了，说一些写注解的基本方法：1猜测的去写，刚开始阅读一个代码的时候，你很难一下子就确定所有的函数的功能，不妨采用采用猜测的方法去写注解，根 据函数的名字、位置写一个大致的注解，当然一般会有错误，但你的注解实际是不但调整的，直到最后你理解了全部代码。2按功能去写，别把注解写成语法说明 书，千万别看到fopen就写打开文件，看到fread就写读数据，这样的注解一点用处都没有，而应该写在此处开发参数配置文件(<em>**</em>。dat)读出 系统初始化参数。。。。。，这样才是有用的注解。3在写注解的使用另外要注意的一个问题是分清楚系统自动生成的代码和用户自 己开发的代码，一般来说没有必要写系统自动生成的代码。象delphi的代码，我们往往要自己编写一些自己的代码段，还要对一些系统自动生成的代码段进行 修改，这些代码在阅读过程是要写注解的，但有一些没有修改过的自动生成的代码就没有必要写注解了。4在主要代码段要写较为详细的注解。有一些函数或类在程 序中起关键的作用，那么要写比较详细的注解。这样对你理解代码有很大的帮助。5对你理解起来比较困难的地方要写详细的注解，在这些地方往往会有一些编程的技巧。不理解这些编程技巧对你以后的理解或移植会有问题。6写中文注解。如果你的英文足够的好，不用看这条了，但很多的人英文实在不怎么样，那就写中文注解吧，我们写注解是为了加快自己的理解速度。中文在大多数的时候比英文更适应中国人。与其写一些谁也看不懂的英文注解还不如不写。</p>
<h2 id="重复阅读"><a href="#重复阅读" class="headerlink" title="重复阅读"></a>重复阅读</h2><p>　　一次就可以将所有的代码都阅读明白的人是没有的。至少我还没有遇到过。反复的去阅读同一段代码有助于得代码的理解。一般来说，在第一次阅读代码的时候 你可以跳过很多一时不明白的代码段，只写一些简单的注解，在以后的重复阅读过程用，你对代码的理解会比上一次理解的更深刻，这样你可以修改那些注解错误的 地方和上一次没有理解的对方。一般来说，对代码阅读3，4次基本可以理解代码的含义和作用。</p>
<h2 id="运行并修改代码"><a href="#运行并修改代码" class="headerlink" title="运行并修改代码"></a>运行并修改代码</h2><p>　　如果你的代码是可运行的，那么先让它运行起来，用单步跟踪的方法来阅读代码，会提高你的代码速度。代码通过看中间变量了解代码的含义,而且对 以后的修改会提供很大的帮助<br>　　用自己的代码代替原有代码，看效果，但在之前要保留源代码<br>　　600行的一个函数，阅读起来很困难，编程的人不是一个好的习惯。在阅读这个代码的时候将代码进行修改，变成了14个函数。每一个大约是40-50 行左右.</p>
]]></content>
      
        <categories>
            
            <category> 转载 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 源码 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[简析String、StringBuffer与StringBuilder]]></title>
      <url>/%E7%AE%80%E6%9E%90String%E3%80%81StringBuffer%E4%B8%8EStringBuilder.html</url>
      <content type="html"><![CDATA[<h2 id="字符串类String"><a href="#字符串类String" class="headerlink" title="字符串类String"></a>字符串类String</h2><p>String是final类。Java程序中的所有字符串字面值(如”abc”)都作为此类的实例实现。字符串是常量，它们的值在创建之后不能更改，如果对已经存在的String对象进行修改，都是重新new一个对象，然后把修改后的值保存进去。字符串缓存区支持可变的字符串。因为String对象是不可变的，所以可以共享。<br>字符串的定义很简单，直接给一个字符串类型的变量赋值即可，例如:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String Str = <span class="string">"abc"</span>;</span><br></pre></td></tr></table></figure></p>
<p>等价于:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> data[] = &#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>&#125;</span><br><span class="line">String str = <span class="keyword">new</span> String(data);</span><br></pre></td></tr></table></figure></p>
<h2 id="线程安全的可变字符串类StringBuffer"><a href="#线程安全的可变字符串类StringBuffer" class="headerlink" title="线程安全的可变字符串类StringBuffer"></a>线程安全的可变字符串类StringBuffer</h2><p>StringBuffer 是一个线程安全的可变字符串类，通过构造方法创建对象。类似于String的字符串，不同的是它通过某些方法调用改变该序列的长度和内容。它可将字符串缓存区安全地用于多个线程，可以在必要时对这些方法进行同步。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer();                                <span class="comment">//构造一个空字符串的字符串缓存区</span></span><br><span class="line">StringBuffer(String str);                <span class="comment">//构造一个字符串缓存区，并将其内容初始化为指定的字符串内容</span></span><br></pre></td></tr></table></figure></p>
<p>StringBuffer上的主要操作是append()和insert()方法。通过查看StringBuffer类的三段源码，我们会发现最后调用了System.arraycopy来进行来修改字符串。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>.append(str);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AbstractStringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="keyword">null</span>) str = <span class="string">"null"</span>;</span><br><span class="line">        <span class="keyword">int</span> len = str.length();</span><br><span class="line">        ensureCapacityInternal(count + len);</span><br><span class="line">        str.getChars(<span class="number">0</span>, len, value, count);</span><br><span class="line">        count += len;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getChars</span><span class="params">(<span class="keyword">int</span> srcBegin, <span class="keyword">int</span> srcEnd, <span class="keyword">char</span> dst[], <span class="keyword">int</span> dstBegin)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (srcBegin &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(srcBegin);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (srcEnd &gt; value.length) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(srcEnd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (srcBegin &gt; srcEnd) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(srcEnd - srcBegin);</span><br><span class="line">        &#125;</span><br><span class="line">        System.arraycopy(value, srcBegin, dst, dstBegin, srcEnd - srcBegin);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="可变字符串类StringBuilder"><a href="#可变字符串类StringBuilder" class="headerlink" title="可变字符串类StringBuilder"></a>可变字符串类StringBuilder</h2><p>此类提供一个与StringBuffer兼容的API，但不保证同步。该类被设计用作StringBuffer的一个简易替换，用在字符串缓冲区被单个线程使用的时候。如果可能，建议优先采用该类，因为在大多数实现中，它比StringBuffer要快。</p>
<h2 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h2><ul>
<li>String是字符串常量</li>
<li>StringBuffer是字符串变量(线程安全)</li>
<li>StringBuilder是字符串变量(非线程安全)</li>
</ul>
<p>简单地说，String类型和StringBuffer类型的主要性能区别在于: String是不可改变的对象，每次对String类型进行改变的时候，其实都等同于生成了一个新的String对象，然后将引用指向该对象；而对于StringBuffer类，每次操作都是对StringBuffer对象本身进行更改。<br>所以，如果经常改变内容的字符串最好不要用String，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后，JVM的GC就会开始工作，那速度是一定会相当慢的。这种情况推荐使用StringBuffer，特别是字符串对象经常改变的情况下。但是某些特别情况下，String对象的字符串拼接其实是被JVM解释成了StringBuffer对象的拼接，所以这个时候String对象的速度并不会比StringBuffer对象慢，而特别是以下的字符串对象生成中，String效率是远要比StringBuffer快的:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"This is only a "</span> + <span class="string">"simple"</span> + <span class="string">"test"</span>;</span><br><span class="line">StringBuffer builder = <span class="keyword">new</span> StringBuilder(<span class="string">"This is only a "</span>).append(<span class="string">"simple"</span>).append(<span class="string">"test"</span>);</span><br></pre></td></tr></table></figure></p>
<p>你会发现，生成str对象的速度明显快多了。其实这是JVM的一个隐藏的实现机制，实际上:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"This is only a "</span> + <span class="string">"simple"</span> + <span class="string">"test"</span>;</span><br></pre></td></tr></table></figure></p>
<p>其实就是:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"This is only a simple test"</span>;</span><br></pre></td></tr></table></figure></p>
<p>但是要注意，如果你的字符串是来自另外的String对象，速度就没那么快了,譬如:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">"This is only a "</span>;</span><br><span class="line">String str2 = <span class="string">"simple"</span>;</span><br><span class="line">String str3 = <span class="string">"test"</span>;</span><br><span class="line">String str4 = str1+str2+str3;</span><br></pre></td></tr></table></figure></p>
<p>为了测试这3种类型当累加不同次数字符串时的效率，我们编写一个测试类，分别按次数累加字符串:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">100</span>; <span class="comment">//循环次数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试String</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">        String str = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            str += <span class="string">","</span> + i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.nanoTime();</span><br><span class="line">        System.out.println(<span class="string">"String: "</span> + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试StringBuffer</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testStringBuffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">        StringBuffer str = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            str.append(<span class="string">","</span>).append(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.nanoTime();</span><br><span class="line">        System.out.println(<span class="string">"StringBuffer: "</span> + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试StringBuilder</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testStringBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">        StringBuilder str = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            str = str.append(<span class="string">","</span>).append(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.nanoTime();</span><br><span class="line">        System.out.println(<span class="string">"StringBuilder: "</span> + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestString.testString();</span><br><span class="line">        TestString.testStringBuffer();</span><br><span class="line">        TestString.testStringBuilder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行该程序执行的测试时间如表所示:</p>
<table>
<thead>
<tr>
<th style="text-align:center">毫微秒</th>
<th style="text-align:center">String</th>
<th style="text-align:center">StringBuffer</th>
<th style="text-align:center">StringBuilder</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1次</td>
<td style="text-align:center">38292</td>
<td style="text-align:center">32765</td>
<td style="text-align:center">1579</td>
</tr>
<tr>
<td style="text-align:center">10次</td>
<td style="text-align:center">52108</td>
<td style="text-align:center">45792</td>
<td style="text-align:center">6711</td>
</tr>
<tr>
<td style="text-align:center">100次</td>
<td style="text-align:center">230143</td>
<td style="text-align:center">70662</td>
<td style="text-align:center">64345</td>
</tr>
<tr>
<td style="text-align:center">1000次</td>
<td style="text-align:center">11072907</td>
<td style="text-align:center">308305</td>
<td style="text-align:center">181193</td>
</tr>
<tr>
<td style="text-align:center">1万次</td>
<td style="text-align:center">400656874</td>
<td style="text-align:center">892543</td>
<td style="text-align:center">814777</td>
</tr>
<tr>
<td style="text-align:center">10万次</td>
<td style="text-align:center">溢出</td>
<td style="text-align:center">4308762</td>
<td style="text-align:center">4372318</td>
</tr>
<tr>
<td style="text-align:center">100万次</td>
<td style="text-align:center">溢出</td>
<td style="text-align:center">100687270</td>
<td style="text-align:center">49812689</td>
</tr>
</tbody>
</table>
<p>String在10万次循环时就溢出了，而StringBuffer在100万次循环时间为100ms，StringBuilder的时间为49ms。显然选择优先级为: StringBuilder &gt; StringBuffer &gt; String 。因此，对于这3个类的使用，我们需要按照以下情况去选择。</p>
<ul>
<li>如果偶尔对简单的字符串常量进行拼接，那么可以使用String，它足够简单而且轻量级。</li>
<li>如果需要经常进行字符串的拼接、累加操作，请使用StringBuffer或者StringBuilder。</li>
<li>如果是在单线程的环境中，建议使用StringBuilder,它要比StringBuffer快；如果是在多线程的环境中，建议使用StringBuffer，它是线程安全的。<br>因此，StringBuilder实际上是我们的首选，只有在多线程时才可以考虑使用StringBuffer，只有在字符串的拼接足够简单时才使用String。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java基础 </tag>
            
            <tag> String </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaEE软件开发体系架构]]></title>
      <url>/JavaEE%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84.html</url>
      <content type="html"><![CDATA[<h2 id="两层架构"><a href="#两层架构" class="headerlink" title="两层架构"></a>两层架构</h2><p>传统的客户服务器系统仅只简单地基于两层体系来构建，即客户端（前台）和企业信息系统（后台），没有任何中间件，业务逻辑层与表示层或数据层混在一起。这种两层架构无论从开发、部署、扩展、维护来说，综其只有一个特点——成本高。</p>
<h2 id="三层架构"><a href="#三层架构" class="headerlink" title="三层架构"></a>三层架构</h2><p>三层架构自上而下将系统分为表示层、逻辑层、持久层。<br>表示层由处理用户交互的客户端组件及其容器所组成；<br>业务逻辑层由解决业务问题的组件组成；<br>数据层由一个或多个数据库组成，并可包含存储过程。<br>这种三层架构，在处理客户端的请求时，使客户端不用进行复杂的数据库处理；透明地为客户端执行许多工作，如查询数据库、执行业务规则和连接现有的应用程序；并且能够帮助开发人员创建适用于企业的大型分布式应用程序。<br><img src="http://ou3xxg3hg.bkt.clouddn.com/三层.jpg" alt=""><br><a id="more"></a></p>
<h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><p>在MVC模式中，应用程序被划分为模型层（Model）、视图层（View）、控制层（Controller）三部分。MVC模型就是把一个应用程序的开发按照业务逻辑、数据、视图进行分离分层并组织代码。MVC要求把应用的模型按一定的层次规则抽取出来，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。模型层负责封装应用的状态，并实现功能，视图层负责将内容呈现给用户，控制层负责控制视图层发送的请求以及程序的流程。<br>Servlet+JSP+JavaBean（MVC）这种模式比较适合开发复杂的web应用，在这种模式下，Servlet负责处理用户请求，JSP负责数据显示，JavaBean负责封装数据。<br><img src="http://ou3xxg3hg.bkt.clouddn.com/mvc.jpg" alt=""></p>
<h2 id="基于JavaEE架构模式下的MVC"><a href="#基于JavaEE架构模式下的MVC" class="headerlink" title="基于JavaEE架构模式下的MVC"></a>基于JavaEE架构模式下的MVC</h2><p>在这种架构模式下，模型层（Model）定义了数据模型和业务逻辑。为了将数据访问与业务逻辑分离，降低代码之间的耦合，提高业务精度，模型层又具体划分为了DAO层和业务层，DAO即Data Access Object，其主要职能是将访问数据库的代码封装起来，让这些代码不会在其它层出现或者暴露出来给其它层；业务层是整个系统最核心也是最具有价值的一层，该层封装应用程序的业务逻辑，处理数据，关注客户需求，在业务处理过程中会访问原始数据或产生新数据，DAO层提供的DAO类能很好地帮助业务层完成数据处理，业务层本身侧重于对客户需求的理解和业务规则的适应，总体说来，DAO层不处理业务逻辑，只为业务层提供辅助，完成获取原始数据或持久层数据等操作。<br><img src="http://ou3xxg3hg.bkt.clouddn.com/javaEEmvc.png" alt=""><br>JSP：JSP被用来产生Web的动态内容。这层把应用数据以网页的形式呈现给浏览器，然后数据按照在JSP中开发的预定的方式表示出来，这层也可以称之为布局层。<br>Servlet：JSP建立在Servlet之上，Servlet是J2EE的重要组成部分。Servlet负责处理用户请求，Java Web项目的所有配置都写在了web.xml配置文件里，当项目运行的时候，web.xml会将http请求映射给对应的Servlet类。<br>JavaBean：由一些具有私有属性的Java类组成，对外提供get和set方法。JavaBean负责数据，负责处理视图层和业务逻辑之间的通信。<br>Service：业务处理类，对数据进行一些预处理。<br>DAO：数据访问层，JDBC调用存储过程，从数据库（DataBase）那里获取到数据，再封装到Model实体类中去。</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaEE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaWeb开发]]></title>
      <url>/JavaWeb%E5%AD%A6%E4%B9%A0.html</url>
      <content type="html"><![CDATA[<p>1 JSP3个编译指令 : page,include,taglib<br>2 JSP动作指令7个：<br>jsp:forward ： 执行页面转向，将请求的处理转发到下一个页面<br>jsp:aram : 用于传递参数，必须与其他支持参数的标签一起使用<br>jsp:include ： 用于动态引入一个JSP页面<br>jsp:plugin : 用于下载JavaBean 或 Applet到客户端执行<br>jsp:useBean : 创建一个JavaBean的实例<br>jsp:setProperty : 设置JavaBean 实例的属性值<br>jsp:getProperty : 输出JavaBean 实例的属性值<br>3 include指令<br>include指令是一个动态include指令，也用于包含某个页面，它不会导入被include页面的编译指令，仅仅将被导入页面的body内容插入本页面<br>forward动作指令和include指令的区别：执行forward时，被forward的页面将完全代替原有页面；而执行include时，被include的页面只是插入原有页面。简而言之：forward拿目标页面代替原有页面，而include则拿目标页面插入原有页面。<br><img src="http://ou3xxg3hg.bkt.clouddn.com/JSP9%E5%A4%A7%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1.png" alt=""></p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaWeb </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Annotations]]></title>
      <url>/Annotations.html</url>
      <content type="html"><![CDATA[<h2 id="原文："><a href="#原文：" class="headerlink" title="原文："></a>原文：</h2><p>You\’ve probably encountered the need to annotate elements of your Java applications by associating metadata (data that describes other data) with them. java has always provided an ad hoc annotation mechanism via the transient reserved word, which lets you annotate fields that are to be excluded during serialization. But it didn\’t offer a standard way to annotate program elements until Java 5.<br>Java 5\’s general annotation mechanism consists of four components:<br>1.An @interface mechanism for declaring annotation types.<br>2.Meta-annotation types, which you can use to identify the application elements to which an annotation type applies; to identify the lifetime of an annotation (an instance of an annotation type); and more.<br>3.Support for annotation processing via an extension to the Java Reflection API, which you can use to discover a program\’s runtime annotations, and the introduction of a generalized tool for processing annotations.<br>4.Standard annotation types.<br>I\’ll explain how to use these components and point out some of the challenges of annotations in the examples that follow.<br><a id="more"></a><br>译文：<br>你可能曾遇到过这种需求：通过关联元数据（描述其他数据的数据）来注解你的java应用程序元素。一直以来，java通过transient关键字来提供一种即时注解机制，它可以让你标注一个成员变量在序列化过程中被排除。但是，直到java 5.0版本才提供一种标准的方式来注解程序。<br>Java 5.0常规注解机制包括四部分：<br>1． 声明注解类型@interface机制<br>2． 元注解类型，你可以用来识别注解类型的程序元素应用以及注解的声明周期（注解类型的一个实例）等；<br>3． 通过java反射API的扩展来支持注解处理，你可以用来发现程序运行时的注解，并引入一个泛型注解处理工具。<br>4． 标准的注解类型。<br>接下来，我将通过下面的例子解释如何运用这些机制，并对一些比较有挑战性的注解部分进行标明。</p>
]]></content>
      
        <categories>
            
            <category> 译文 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[IE8开发工具“无法附加进程”]]></title>
      <url>/IE8%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E2%80%9C%E6%97%A0%E6%B3%95%E9%99%84%E5%8A%A0%E8%BF%9B%E7%A8%8B%E2%80%9D.html</url>
      <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>使用IE8开发工具调试时，遇到“无法附加进程，进程可能附加了另一个调试程序”的解决方案<br>本人在遇到此问题时，百度网上的解决方案一般都是重置IE8设置（工具-&gt;Internet选项-&gt;高级-&gt;重置），卸载重装IE8，或者选择别的浏览器进行调试，但是本人的情况是，项目在其他浏览器均可以正常显示，只有IE8以下版本不可以，后面发现是js兼容性问题。我的想法是，通过IE8自带调试工具调试，看看哪里不兼容。后面折腾了好久发现，360浏览器由于用的是IE内核，其开发工具调用的也是IE的开发工具。如果你的系统安装IE9以上版本，可以选择调用IE9以上版本进行开发调试。<a id="more"></a></p>
]]></content>
      
        <categories>
            
            <category> 前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> IE8 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MyBatis上手入门实例]]></title>
      <url>/MyBatis%E4%B8%8A%E6%89%8B%E5%85%A5%E9%97%A8%E5%AE%9E%E4%BE%8B.html</url>
      <content type="html"><![CDATA[<h2 id="MyBatis下载、配置及测试"><a href="#MyBatis下载、配置及测试" class="headerlink" title="MyBatis下载、配置及测试"></a>MyBatis下载、配置及测试</h2><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL215YmF0aXMvbXliYXRpcy0zL3JlbGVhc2Vz" title="https://github.com/mybatis/mybatis-3/releases">点击下载<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cDovL3d3dy5teWJhdGlzLm9yZy9teWJhdGlzLTMvemgvaW5kZXguaHRtbA==" title="http://www.mybatis.org/mybatis-3/zh/index.html">MyBatis在线中文文档<i class="fa fa-external-link"></i></span><br>下载之后打开，如图：<br><img src="http://img.blog.csdn.net/20160413162531439" alt="这里写图片描述"><br>第一个使我们需要用到的包，pdf文档是MyBatis英文手册，后面两个分别是javadoc文档和源码。<br>在这里我们还需要导入MySQL数据库驱动jar包。<span class="exturl" data-url="aHR0cDovL2Rldi5teXNxbC5jb20vZG93bmxvYWRzL2Nvbm5lY3Rvci9qLw==" title="http://dev.mysql.com/downloads/connector/j/">官方驱动jar包下载地址<i class="fa fa-external-link"></i></span><br>这些准备以后，我们开始配置。</p>
<ol>
<li>打开MyEclipse，导入jar包。在src下新建一个包，并新建配置文件conf.xml。如图：<br><img src="http://img.blog.csdn.net/20160413163951348" alt="这里写图片描述"> <a id="more"></a></li>
<li><p>新建测试数据库mybatis，并新建两条数据。</p>
<p><img src="http://img.blog.csdn.net/20160413165119517" alt="这里写图片描述"></p>
</li>
<li><p>在Mybatis中定义Mapper信息有两种方式，一种是利用xml写一个对应的包含Mapper信息的配置文件；另一种就是定义一个Mapper接口，然后定义一些相应的操作方法，再辅以相应的操作注解。conf.xml代码，具体参数的解释请看文档。</p>
</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration PUBLIC <span class="string">"-//mybatis.org//DTD Config 3.0//EN"</span></span><br><span class="line"><span class="string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">	&lt;environments <span class="keyword">default</span>=<span class="string">"development"</span>&gt;</span><br><span class="line">		&lt;environment id=<span class="string">"development"</span>&gt;</span><br><span class="line">			&lt;transactionManager type=<span class="string">"JDBC"</span> /&gt;</span><br><span class="line">			&lt;dataSource type=<span class="string">"POOLED"</span>&gt;</span><br><span class="line">				&lt;property name=<span class="string">"driver"</span> value=<span class="string">"com.mysql.jdbc.Driver"</span> /&gt;</span><br><span class="line">				&lt;property name=<span class="string">"url"</span> value=<span class="string">"jdbc:mysql://localhost:3306/mybatis"</span> /&gt;</span><br><span class="line">				&lt;property name=<span class="string">"username"</span> value=<span class="string">"root"</span> /&gt;</span><br><span class="line">				&lt;property name=<span class="string">"password"</span> value=<span class="string">"root"</span> /&gt;</span><br><span class="line">			&lt;/dataSource&gt;</span><br><span class="line">		&lt;/environment&gt;</span><br><span class="line">	&lt;/environments&gt;</span><br><span class="line">	&lt;mappers&gt;</span><br><span class="line">		&lt;mapper resource=<span class="string">"com/MyBatis/test1/userMapper.xml"</span>/&gt;</span><br><span class="line">		&lt;mapper <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.MyBatis.test1.UserMapper1"</span>/&gt;</span><br><span class="line">	&lt;/mappers&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>
<p> 4.新建一个实体类User。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.MyBatis.test1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> id, String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"User [id="</span> + id + <span class="string">", name="</span> + name + <span class="string">", age="</span> + age + <span class="string">"]"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 5.新建userMapper.xml文件，文件参数解释请看文档，代码如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;!DOCTYPE  mapper  PUBLIC  <span class="string">"-//mybatis.org//DTD  Mapper  3.0//EN"</span></span><br><span class="line"><span class="string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span><br><span class="line">&lt;mapper namespace=<span class="string">"com.MyBatis.test1.userMapper"</span>&gt;</span><br><span class="line">	&lt;select id=<span class="string">"getUser"</span> parameterType=<span class="string">"int"</span></span><br><span class="line">		resultType=<span class="string">"com.MyBatis.test1.User"</span>&gt;</span><br><span class="line">		select * from users where id=#&#123;id&#125;</span><br><span class="line">	&lt;/select&gt;</span><br><span class="line">	&lt;select id = <span class="string">"insertUser"</span> parameterType=<span class="string">"com.MyBatis.test1.User"</span>&gt;</span><br><span class="line">		<span class="function">insert into <span class="title">users</span><span class="params">(name,age)</span> <span class="title">values</span><span class="params">(#&#123;name&#125;,#&#123;age&#125;)</span></span>;</span><br><span class="line">	&lt;/select&gt;</span><br><span class="line">	&lt;delete id=<span class="string">"deleteUser"</span> parameterType=<span class="string">"int"</span>&gt;</span><br><span class="line">		delete from users where id=#&#123;id&#125;;</span><br><span class="line">	&lt;/delete&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;update id=<span class="string">"updateUser"</span> parameterType=<span class="string">"com.MyBatis.test1.User"</span>&gt;</span><br><span class="line">		update users set name =#&#123;name&#125;,age=#&#123;age&#125; where id = #&#123;id&#125;;</span><br><span class="line">	&lt;/update&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;select id=<span class="string">"selectAllUsers"</span> resultType=<span class="string">"com.MyBatis.test1.User"</span>&gt;</span><br><span class="line">		select * from users;</span><br><span class="line">	&lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure></p>
<p>6.新建 测试类test，此处采用JUnit4测试，然后逐个方法进行测试。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.MyBatis.test1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	String resource = <span class="string">"conf.xml"</span>;</span><br><span class="line">	InputStream is = Test1.class.getClassLoader().getResourceAsStream(resource);</span><br><span class="line">	SqlSessionFactory factory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(is);</span><br><span class="line">	SqlSession session = factory.openSession(<span class="keyword">true</span>);</span><br><span class="line">	UserMapper1 mapper = session.getMapper(UserMapper1.class);</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		User user = <span class="keyword">new</span> User();</span><br><span class="line">		user.setName(<span class="string">"dudefu"</span>);</span><br><span class="line">		user.setAge(<span class="number">20</span>);</span><br><span class="line">		String statementInsert = <span class="string">"com.MyBatis.test1.userMapper.insertUser"</span>;</span><br><span class="line">		session.insert(statementInsert, user);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		User user = <span class="keyword">new</span> User();</span><br><span class="line">		user.setName(<span class="string">"ddf"</span>);</span><br><span class="line">		user.setAge(<span class="number">20</span>);</span><br><span class="line">		user.setId(<span class="number">6</span>);</span><br><span class="line">		String statement = <span class="string">"com.MyBatis.test1.userMapper.updateUser"</span>;</span><br><span class="line">		session.update(statement, user);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectAllUsers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String statementSelectAll = <span class="string">"com.MyBatis.test1.userMapper.selectAllUsers"</span>;</span><br><span class="line">		List&lt;User&gt; selectAllUser = session.selectList(statementSelectAll);</span><br><span class="line">		System.out.println(selectAllUser);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String statement = <span class="string">"com.MyBatis.test1.userMapper.deleteUser"</span>;</span><br><span class="line">		<span class="keyword">int</span> a = session.delete(statement, <span class="number">10</span>);</span><br><span class="line">		System.out.println(a);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>7.采用注解的方式。首先新建接口类userMapper1，此处注意，如果接口类和userMpper.xml在同一个包内，则接口类的名字不能和userMapper.xml的名字相同，否则会报错<br><code>java.lang.NoClassDefFoundError: com/MyBatis/test1/userMapper (wrong name: com/MyBatis/test1/UserMapper</code><br>具体原因，启动程序后，程序首先会加载所有文件，这时userMpper.class和userMpper.xml会发生冲突。所以如果在同一个包内需改名，此处改名为userMapper1.class。userMapper1.class代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.MyBatis.test1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Delete;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Insert;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Select;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Update;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper1</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Insert</span>(<span class="string">"insert into users(name,age) values(#&#123;name&#125;,#&#123;age&#125;)"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insertUser</span><span class="params">(User user)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Delete</span>(<span class="string">"delete from users where id=#&#123;id&#125;"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteUserById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Update</span>(<span class="string">"update users set name =#&#123;name&#125;,age=#&#123;age&#125; where id = #&#123;id&#125;"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">updateUser</span><span class="params">(User user)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Select</span>(<span class="string">"select * from users where id=#&#123;id&#125;"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> User <span class="title">getUserById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Select</span>(<span class="string">"select * from users"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;User&gt;  <span class="title">getAllUser</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>8.新建测试类test2。代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.MyBatis.test2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	String resource = <span class="string">"conf.xml"</span>;</span><br><span class="line">	InputStream is = Test1.class.getClassLoader().getResourceAsStream(resource);</span><br><span class="line">	SqlSessionFactory factory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(is);</span><br><span class="line">	SqlSession session = factory.openSession(<span class="keyword">true</span>);</span><br><span class="line">	UserMapper1 mapper = session.getMapper(UserMapper1.class);</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInsert</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> insert = mapper.insertUser(<span class="keyword">new</span> User(-<span class="number">1</span>,<span class="string">"dudefu"</span>,<span class="number">23</span>));</span><br><span class="line">		System.out.println(insert);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpdate</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> update = mapper.updateUser(<span class="keyword">new</span> User(<span class="number">11</span>,<span class="string">"ddf"</span>,<span class="number">34</span>));</span><br><span class="line">		System.out.println(update);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testdelete</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> delete = mapper.deleteUserById(<span class="number">11</span>);</span><br><span class="line">		System.out.println(delete);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectAllUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">		List&lt;User&gt; selectAllUsers = mapper.getAllUser();</span><br><span class="line">		System.out.println(selectAllUsers);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>按照以上步骤进行操作，测试应该是不报错的。如果出错了，一般出错在 conf.xml中的路径配置，如下段代码；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;mappers&gt;</span><br><span class="line">		&lt;mapper resource=&quot;com/MyBatis/test1/userMapper.xml&quot;/&gt;</span><br><span class="line">		&lt;mapper class=&quot;com.MyBatis.test1.UserMapper1&quot;/&gt;</span><br><span class="line">	&lt;/mappers&gt;</span><br></pre></td></tr></table></figure>
<p>和userMapper.xml中。</p>
]]></content>
      
        <categories>
            
            <category> 框架 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[阿里云Maven仓库地址]]></title>
      <url>/%E9%98%BF%E9%87%8C%E4%BA%91Maven%E4%BB%93%E5%BA%93%E5%9C%B0%E5%9D%80.html</url>
      <content type="html"><![CDATA[<h2 id="阿里云Maven仓库地址"><a href="#阿里云Maven仓库地址" class="headerlink" title="阿里云Maven仓库地址"></a>阿里云Maven仓库地址</h2><p><span class="exturl" data-url="aHR0cDovL21hdmVuLmFsaXl1bi5jb20vbmV4dXMvI3ZpZXctcmVwb3NpdG9yaWVzO3B1YmxpY35icm93c2VzdG9yYWdl" title="http://maven.aliyun.com/nexus/#view-repositories;public~browsestorage">http://maven.aliyun.com/nexus/#view-repositories;public~browsestorage<i class="fa fa-external-link"></i></span><br>在maven的settings.xml 文件里配置mirrors的子节点，添加如下mirror<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;mirror&gt;</span><br><span class="line">       &lt;id&gt;nexus-aliyun&lt;/id&gt;</span><br><span class="line">       &lt;mirrorOf&gt;*&lt;/mirrorOf&gt;</span><br><span class="line">       &lt;name&gt;Nexus aliyun&lt;/name&gt;</span><br><span class="line">       &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;</span><br><span class="line">&lt;/mirror&gt;</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>]]></content>
      
        <categories>
            
            <category> 有料 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[deepin下搭建基于github和hexo的个人博客]]></title>
      <url>/deepin%E4%B8%8B%E6%90%AD%E5%BB%BA%E5%9F%BA%E4%BA%8Egithub%E5%92%8Chexo%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2.html</url>
      <content type="html"><![CDATA[<h3 id="系统：Linux-Deepin-15-4-x64"><a href="#系统：Linux-Deepin-15-4-x64" class="headerlink" title="系统：Linux Deepin 15.4 x64"></a>系统：Linux Deepin 15.4 x64</h3><h3 id="搭建步骤："><a href="#搭建步骤：" class="headerlink" title="搭建步骤："></a>搭建步骤：</h3><p>1、 安装git<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo apt-get install git</span><br></pre></td></tr></table></figure></p>
<p>  查看git版本<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git version</span><br></pre></td></tr></table></figure></p>
<p>2、 安装Node.js及npm<br>a. 可以直接命令安装,但是命令安装的不是最新版本。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo apt-get install nodejs</span><br><span class="line"><span class="meta">$</span> sudo apt-get install npm</span><br></pre></td></tr></table></figure></p>
<p>b. 本博客采用第二种方法，首先官网<span class="exturl" data-url="aHR0cDovL25vZGVqcy5vcmcvemgtY24v" title="http://nodejs.org/zh-cn/">下载<i class="fa fa-external-link"></i></span>最新版，然后解压。将node,npm命令设置全局命令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo ln -s /home/dudefu/Documents/node-v8.6.0-linux-x64/bin/node /usr/local/bin/node</span><br><span class="line"><span class="meta">$</span> sudo ln -s /home/dudefu/Documents/node-v8.6.0-linux-x64/bin/npm /usr/local/bin/npm</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>查看版本：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> node -v</span><br><span class="line"><span class="meta">$</span> npm -v</span><br></pre></td></tr></table></figure></p>
<p>3、 安装hexo<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> npm install -g hexo-cli</span><br></pre></td></tr></table></figure></p>
<p>hexo-cli安装路径/home/dudefu/Documents/node-v8.6.0-linux-x64/lib/node_modules/hexo-cli，此时输入命令hexo会提示“未找到命令”，此时要将hexo-cli/bin/文件夹下的hexo命令设置为全局：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo ln -s /home/dudefu/Documents/node-v8.6.0-linux-x64/lib/node_modules/hexo-cli/bin/</span><br><span class="line"><span class="meta">$</span> hexo /usr/local/bin/hexo</span><br></pre></td></tr></table></figure></p>
<p>再输入hexo命令可以正常显示。<br>创建一个空文件夹，此处名为hexo：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> mkdir hexo</span><br><span class="line"><span class="meta">$</span> cd hexo</span><br><span class="line"><span class="meta">$</span> hexo init .</span><br><span class="line"><span class="meta">$</span> npm install </span><br><span class="line"><span class="meta">$</span> hexo server -p 5000</span><br></pre></td></tr></table></figure></p>
<p>到此，hexo安装完毕。浏览器输入<span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo1MDAw" title="http://localhost:5000">本地<i class="fa fa-external-link"></i></span>，前面配置均正确的情况下，正常显示博客首页。<br>4、 hexo配置<br>主要分为两块站点配置和主题配置。此处先<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lpc3NuYW4vaGV4by10aGVtZS1uZXh0" title="https://github.com/iissnan/hexo-theme-next">下载<i class="fa fa-external-link"></i></span>NexT主题：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git clone https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure></p>
<p>接下来的详细配置就不细说了，直接看<span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL3poLWNuL2RvY3Mv" title="https://hexo.io/zh-cn/docs/">hexo<i class="fa fa-external-link"></i></span>文档，<span class="exturl" data-url="aHR0cDovL3RoZW1lLW5leHQuaWlzc25hbi5jb20v" title="http://theme-next.iissnan.com/">NexT<i class="fa fa-external-link"></i></span>使用文档，主题配置遇到难点的可以访问<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lpc3NuYW4vaGV4by10aGVtZS1uZXh0L2lzc3Vlcw==" title="https://github.com/iissnan/hexo-theme-next/issues">github<i class="fa fa-external-link"></i></span>：，所有的问题基本可以解决。</p>
<p><span class="exturl" data-url="aHR0cDovL3d3dy5kdWRlZnUuaW5mbw==" title="http://www.dudefu.info">我的博客<i class="fa fa-external-link"></i></span></p>
]]></content>
      
        <categories>
            
            <category> 有料 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
